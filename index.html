<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Sam Nolan" />
  <title>A living review of Interactive Theorem Provers</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script defer src="src/bundle.js"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">A living review of Interactive Theorem Provers</h1>
<div class="header-logo">
<img src="Images/rmit-logo.png" width="300px" />
</div>
<p class="author">Sam Nolan</p>
<p class="date">29th of September 2021</p>
</header>

<h2>Declaration</h2>
<p>
I certify that except where due acknowledgment has been made, the work is that of the author alone; the work has not been submitted previously, in whole or in part, to qualify for any other academic award; the content of the thesis is the result of work which has been carried out since the official commencement date of the approved research program; any editorial work, paid or unpaid, carried out by a third party is acknowledged; and, ethics procedures and guidelines have been followed.<br />
Signed: Sam Nolan<br />
Date: 29th of September 2021<br />
</p>

<h2>Abstract</h2>
<p>Interactive Theorem Provers allow you to prove that software is correct. However, the adoption of ITPs is far from widespread. This thesis creates a living review about usability issues that may prohibit ITPs from being used, and further creates a tool to help aid decision in choosing what ITP should be used for a given project.</p>

<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Table of Contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#background">Background</a>
<ul>
<li><a href="#sec:background_itp">Interactive Theorem Provers</a></li>
<li><a href="#formal-methods">Formal Methods</a></li>
<li><a href="#sec:living_review">Living Reviews</a></li>
<li><a href="#cognitive-dimensions-of-notation">Cognitive Dimensions of Notation</a></li>
</ul></li>
<li><a href="#methodology">Methodology</a>
<ul>
<li><a href="#sec:review_methodology">Systematic Literature Review Methodology</a></li>
<li><a href="#living-review-methodology">Living Review Methodology</a>
<ul>
<li><a href="#general-features-of-about-itps">General features of about ITPs</a></li>
<li><a href="#comparing-projects-between-itps">Comparing projects between ITPs</a></li>
<li><a href="#comparing-progress-on-usability-issues-for-itps">Comparing progress on usability issues for ITPs</a></li>
</ul></li>
</ul></li>
<li><a href="#literature-review">Literature Review</a>
<ul>
<li><a href="#theorem-provers">Theorem Provers</a></li>
<li><a href="#interaction-paradigms">Interaction Paradigms</a></li>
<li><a href="#abstraction-gradient-1">Abstraction Gradient</a></li>
<li><a href="#closeness-of-mapping-1">Closeness of Mapping</a></li>
<li><a href="#consistency-1">Consistency</a></li>
<li><a href="#diffuseness-terseness">Diffuseness / terseness</a></li>
<li><a href="#error-proneness-1">Error Proneness</a></li>
<li><a href="#hard-mental-operations-1">Hard mental operations</a></li>
<li><a href="#hidden-dependencies-1">Hidden dependencies</a></li>
<li><a href="#perceptual-cues-1">Perceptual cues</a></li>
<li><a href="#premature-commitment-1">Premature Commitment</a></li>
<li><a href="#progressive-evaluation-1">Progressive Evaluation</a></li>
<li><a href="#secondary-notation-1">Secondary Notation</a></li>
<li><a href="#viscosity-1">Viscosity</a></li>
<li><a href="#visibility">Visibility</a></li>
<li><a href="#final-analysis">Final Analysis</a></li>
</ul></li>
<li><a href="#results">Results</a></li>
<li><a href="#discussion">Discussion</a></li>
<li><a href="#bibliography">Bibliography</a></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>This is a thesis about <strong>Interactive Theorem Provers</strong>, what they are, how they’ve been used in the past and whether you should explore using them in your next project.</p>
<p>An <strong>Interactive Theorem Prover</strong> (henceforth ITPs) is a program that interactively guides the user in proving mathematical theorems. They are also synonymous called <strong>Proof Assistants</strong>. ITPs are often called upon in mathematics, and have been used to create original proofs of theorems such as the four colour theorem <span class="citation" data-cites="four_colour_2008">[<a href="#ref-four_colour_2008" role="doc-biblioref">15</a>]</span>.</p>
<p>ITPs also have another use. As computer programs can be computer programs can often be expressed through a type of mathematical logic, and have a lot of similarities, ITPs can be used to prove the correctness of software systems.</p>
<p>Projects that use ITPs include the certified C compiler CompCert <span class="citation" data-cites="leroy_formal_2009">[<a href="#ref-leroy_formal_2009" role="doc-biblioref">29</a>]</span>, which is a C compiler that allows for a fully correct compilation of C. Or the fully verified microkernel SeL4 <span class="citation" data-cites="klein_sel4_2009">[<a href="#ref-klein_sel4_2009" role="doc-biblioref">28</a>]</span>. <!-- Might need better description --></p>
<p>However, ITPs are far from commonplace for verifying software. This is likely due to verifying software being very difficult, requiring a lot of knowledge about proof theory.</p>
<p>Ensuring that software operates correctly is very important, especially as systems get more and more complicated. The goal of this thesis is to identify the roadblocks in adaption, and help users decide between what technology they should use in their next project.</p>
<p>The research questions for this thesis are:</p>
<p>RQ1 <em>What usability issues and solutions have been mentioned in literature regarding ITPs?</em></p>
<p>RQ2 <em>Do these usability issues and solutions still exist in the ITPs?</em></p>
<p>RQ3 <em>What, if any, ITP should be used for a specific project?</em></p>
<h1 id="background">Background</h1>
<h2 id="sec:background_itp">Interactive Theorem Provers</h2>
<p>An <strong>Interactive Theorem Prover</strong> or <strong>Proof Assistant</strong> is a piece of software that helps prove mathematical theorems, or equivalently, prove correctness properties about software. Some of the more well known examples of provers include <a href="https://coq.inria.fr/">Coq</a> and <a href="https://isabelle.in.tum.de/">Isabelle</a>.</p>
<p>In computer science, often correctness proofs of algorithms (like Dijkstra in an undergraduate context) are described and proved on pen and paper. The use of an ITP in analogous to this type of activity.</p>
<p>You first specify what it is that you would like to prove, for example, that Dijkstra’s algorithm always finds the shortest path between two nodes in a weighted graph. In this step, you would specify what Dijkstra’s algorithm, graphs , and shortest paths are, then state that Dijkstra’s algorithm finds the shortest path.</p>
<p>This leaves you with a <strong>proof obligation</strong>. It is then up to the user to provide to the ITP the reasoning as to why this theorem is correct. This can be done in several ways, sometimes through the use of automated software, or manipulating with the proof by pointing and clicking, or writing down a <strong>proof script</strong> that describes the steps made to prove the theorem.</p>
<p>The ITP then checks whether the proof of the theorem is valid, assisting you along the way in any errors that you make, until you have specified a proof of the statement you wish to claim. Once that proof is made, you can be assured that the system works correctly.</p>
<p>Proving software is correct is far from a trivial task, and proving correctness of different types of systems requires a strong understanding of formal proof theory and the ITP at hand. The inspiration for this thesis was due to nature of ITPs producing proofs that are readable for a computer but not for a user. A full description of usability issues with ITPs are discussed in the literature review.</p>
<p>Another way of approaching ITPs is through programming languages. Often a goal in programming language design is to create languages where you cannot make a certain class of errors. For instance, Rust is designed to allow systems level programming that’s protected from memory errors, and Elm is designed to create web programs that do not have runtime errors. Languages often accomplish this through Type Systems and Functional Programming. ITPs are languages that have design features that allow you to go as far as proving the correctness of your software. Almost all ITPs use Type Systems and Functional Programming to assist in proving software.</p>
<h2 id="formal-methods">Formal Methods</h2>
<p>ITPs are not the only way to verify software. They belong to a class of techniques named <strong>Formal Methods</strong>.</p>
<p>In essence, formal methods attempts to improve the process that users can prove the correctness of their software systems. Use of formal methods can be done without any tools at all, by simply proving properties by hand.</p>
<p>However, computers and tools have aided people in providing large proofs for software systems. The tools used in Formal Methods can be roughly divided into three categories, Model Checkers, Automated Theorem Provers and Interactive Theorem Provers.</p>
<p>These three techniques are a trade off in three dimensions. You can pick two but not all three:</p>
<p><strong>Automation</strong>: Whether finding a proof is fully automated. That is, the user does not need to specify a proof manually for the proposition, the system simply attempts to find one automatically.</p>
<p><strong>Termination</strong>: Whether the tool terminates in a reasonable amount of time when attempting to find a proof.</p>
<p><strong>Scope</strong>: Whether the system can prove arbitrarily theorems.</p>
<p><strong>Model Checkers</strong> are fully automated and terminate in reasonable time. However, Model checkers can do this by restricting the scope of the systems that they can prove. They allow for a specification for a system in a (usually finite) state machine, and can prove properties about this state machine.</p>
<p><strong>Automated Theorem Provers</strong> (ATPs) are fully automated and can prove arbitrary theorems, however may not terminate in reasonable time. For larger systems or more complicated theorems, they may run forever and never identify a proof or disproof for the proposition.</p>
<p><strong>Interactive Theorem Provers</strong> terminate in reasonable time and can prove arbitrary theorems. However, they are not fully automated, and require the user’s input to guide the proof of the theorem.</p>
<p>The distinction between ATPs and ITPs is however not clear cut. ATPs can often include minor user interaction in order to correct it’s path and find a proof. And ITPs often have automatic features and can even call external ATPs to discharge proof obligations.</p>
<p>ITPs were chosen for this thesis due to their application in fully certified software. A Model Checker cannot be used to create fully certified software, and ATPs can be used as a component of ITPs.</p>
<h2 id="sec:living_review">Living Reviews</h2>
<p>A living review is a review of a field that updates periodically to reflect the current state of the research. These reviews are often published electronically, such as to a website. The goal of a living review is to ensure that the review never goes stale, and can be used as a reference years to come.</p>
<h2 id="cognitive-dimensions-of-notation">Cognitive Dimensions of Notation</h2>
<p>Cognitive Dimensions of Notation is a framework used to evaluate the effectiveness of notations <span class="citation" data-cites="green_usability_1996">[<a href="#ref-green_usability_1996" role="doc-biblioref">18</a>]</span>, that is, ways of writing down information. The notation was originally proposed by Green as a way of discussing the design trade-offs of visual programming languages, but has been applied elsewhere for a variety of notations. These dimensions are not an evaluation framework for notations, as often increasing one dimension will also change other dimensions, and different tasks may require different dimensions. For instance, in textual ITPs, dependencies are not shown between theorems, and doing so would increase the Diffuseness of the notation, allowing less to be shown and understood on a single screen. However, debugging why some theorem might fail given a change in other theorems would aid from a more diffuse representation showing the hidden dependencies.</p>
<p>Cognitive Dimensions focus mainly on the way that users understand and work with the meaning of the program. Cognitive Dimensions make an important distinction between difficulties of understanding and working with the notation vs difficulties with the actual problem itself. Because proving theorems is a very cognitively demanding task, that no matter how perfect the notation will always have an inherit difficulties. We can only try and improve the notations rather than making the actual problems easier.</p>
<p>The notation has been adopted as a way of evaluating the usability of ITPs in Kadoda PhD Thesis <span class="citation" data-cites="kadoda_desirable_1999">[<a href="#ref-kadoda_desirable_1999" role="doc-biblioref">26</a>]</span>. The interpretation of Cognitive Dimensions in regards to ITPs has been inspired by their work, but has some notable differences.</p>
<p>The Cognitive Dimensions of Notation are:</p>
<h4 id="abstraction-gradient">Abstraction Gradient</h4>
<p>Does the ITP offer ways of abstracting components? Abstraction here refers to methods, classes and encapsulation. Green classifies notations as either being abstraction-hating, abstraction-tolerant or abstraction-hungry. An abstraction-hating ITP would be one that forces you to work with low level constructs often. An abstraction-tolerant ITP would be one that gives some methods for abstraction, but still nevertheless requires constant low level interaction. An abstraction-hungry ITP would offer many methods of abstraction, that could even in the end obscure what is actually happening behind the scenes.</p>
<h4 id="closeness-of-mapping">Closeness of Mapping</h4>
<p>Closeness of Mapping is how similar the notation is to the problem domain. At some point, a representation of the problem has to be put into notation suitable for the ITP. The easier this is to do the better the closeness of mapping, or how close the proof state is represented vs what the user would expect.</p>
<h4 id="consistency">Consistency</h4>
<p>Once you know the basics of an ITP, how much of the rest can be inferred? A notation that is not consistent would require constant lookup of features in the theorem prover. Consistency is particularly important for learning ITPs. Consistency can become an issue when there are a large amount of abstractions.</p>
<h4 id="error-proneness">Error-Proneness</h4>
<p>Is it easy to make careless mistakes? A common "careless mistake" in theorem provers is trying to apply a tactic in a textual theorem prover that is not valid for the current proof state.</p>
<h4 id="diffuseness">Diffuseness</h4>
<p>How much does it represent a proof relative to the complexity of the proposition proven? This is an easier cognitive dimension to measure, and represents the verbosity of the notation. ITPs with high diffuseness often have lower abstractions and are easier to understand, but more difficult to change.</p>
<h4 id="hard-mental-operations">Hard Mental Operations</h4>
<p>Are there parts of the notation that require getting out a pencil and paper to understand what it means? The domain of ITPs by it’s very nature requires Hard Mental Operations, so it’s important to separate the inherit difficulty vs difficulty created by the notation. Hard Mental Operations may arise out of particularly complicated tactics, especially since tactics can be composed together. An ITP with a consistent set of tactics would reduce Hard Mental Operations.</p>
<h4 id="hidden-dependencies">Hidden Dependencies</h4>
<p>Are there dependencies in the notation that are not presented? In ITPs and programming languages, it’s usually possible to find what a function/lemma references, but is difficult to find what lemmas/functions reference the one we are working in. Furthermore, automation often uses lemmas in the context without indicating at all that it is using them. This makes the issue of hidden dependencies even more difficult. An ITP with low hidden dependencies makes these dependencies between parts of the program explicit</p>
<h4 id="perceptual-cues">Perceptual cues</h4>
<p>Does the notation force the user to make decisions before they have the information they need to make it? Especially for novice users, ITPs need to allow the user to explore different paths for proving a statement. This often represents a premature commitment as the user has to commit to a strategy before evaluating whether that strategy would work. ITPs that offer undo features and allow postponing making decisions require less premature commitment.</p>
<h4 id="premature-commitment">Premature commitment</h4>
<p>Does the notation force the user to make decisions before they have the information they need to make it? Especially for novice users, ITPs need to allow the user to explore different paths for proving a statement. This often represents a premature commitment as the user has to commit to a strategy before evaluating whether that strategy would work. ITPs that offer undo features and allow postponing making decisions require less premature commitment.</p>
<h4 id="progressive-evaluation">Progressive Evaluation</h4>
<p>Does the system give adequate feedback? Error messages, display of current proof state and ability to work with incomplete proofs are all features of progressive evaluation. Getting feedback from the system is absolutely essential for learning the ITPs.</p>
<h4 id="role-expressiveness">Role Expressiveness</h4>
<p>Is it easy to identify what the purpose of a component is? Lack of role expressiveness, particularly within the proofs of textual ITPs, was one of the main motivations of this study. It is often very difficult on retrospect to identify how the components of a proof relate to each other. An ITP with high Role Expressiveness would make it clear how a lemma or component of a proof contributes to the proof.</p>
<h4 id="secondary-notation">Secondary Notation</h4>
<p>Are there avenues for comments, colours and representation of the code that helps with comprehension? A Secondary Notation is a way of representing understanding by not changing the actual meaning of the notation. ITPs that offer comments, colours and whitespace grouping help with representing secondary notation.</p>
<h4 id="viscosity">Viscosity</h4>
<p>Is it easy to make a change in the system? ITPs with low abstraction make it difficult to make changes. Sometimes a small difference to what you are wanting to prove requires a disproportionate change of the proof. ITPs with high viscosity make it difficult to change.</p>
<h4 id="visibility-and-juxtaposability">Visibility and Juxtaposability</h4>
<p>How easy is to get a particular piece of desired information? How easy is it to compare part of your proof with proofs elsewhere? Sometimes critical information is difficult to obtain when creating or understanding a proof state. A common example is being able to inspect intermediate proof steps. When a proof relies heavily on automation, it is sometimes difficult to understand how the automated tactic managed to get in a particular proof state. Having this information helps understand the proof and how to move forward. ITPs with low visibility make it difficult to find such information.</p>
<p>Juxtaposability is showing two parts of the system side by side. This is important as often a proof might only be a refinement of a previous proof, and might need to be understood in context.</p>
<h1 id="methodology">Methodology</h1>
<p>To recall our research questions:</p>
<p>RQ1 <em>What usability issues and solutions have been mentioned in literature regarding ITPs?</em></p>
<p>RQ2 <em>Do these usability issues and solutions still exist in the ITPs?</em></p>
<p>RQ3 <em>What, if any, ITP should be used for a specific project?</em></p>
<p>The natural method for answering RQ1 is to perform a systematic literature review. This literature review intends to identify and categorize usability issues related to different theorem provers.</p>
<p>Answering RQ2 requires going through the theorem provers and identifying the issues. However, ITPs are continually in development, and any issue that arises could be solved at a future date. As of such, we created a <strong>living review</strong> (See sec. <a href="#sec:living_review">2.3</a> for definition) to answer this question.</p>
<p>The creation of this living review will answer RQ3, and provide descriptions of the current state of the field for ITPs.</p>
<h2 id="sec:review_methodology">Systematic Literature Review Methodology</h2>
<p>A preliminary literature review was done in order to survey what usability problems occurred about theorem provers. This preliminary review came from a search for “usability interactive theorem provers" on the ACM digital library and Google Scholar. The review found several papers on the topic. We then attempted to construct a query that would match these papers and also other papers in the field.</p>
<p>Papers were searched for having the title matching the following query: <code>("Interactive" OR "Deductive") AND ("prover" OR "provers" OR "proving" OR "verifier") AND ("usability" OR "user" OR "users")</code></p>
<p>The justification for using quotes around prover, provers and proving is that some search engines will return papers with the text "prove" when looking for "prover". "prove" therefore comes up with many more records that are unrelated to our topic. "Usability" is also quoted to prevent searching for "use", which clearly would bring in papers that are unrelated.</p>
<p>We searched the following databases using this query string:</p>
<ul>
<li>Scopus</li>
<li>DBLP</li>
<li>Springer Link</li>
<li>Science Direct</li>
<li>ACM</li>
<li>IEEE Xplore</li>
</ul>
<p>From the papers discovered in this way, we went through the abstracts and discerned whether the paper was relevant to the research question.</p>
<p>Our inclusion criteria for the papers included in the systematic literature review was the following:</p>
<ul>
<li>A peer review published paper AND</li>
<li>Notes particular usability issues with theorem provers OR</li>
<li>Offers direct recommendations to the improvement of the usability of interactive theorem provers</li>
</ul>
<p>We particularly excluded papers written in languages other than English, workshops, tutorials, extended abstracts, unpublished and non peer reviewed papers.</p>
<p>From the papers that were deemed relevant to the research question, we found papers that cited the papers discovered. That is, we applied forward snowballing. Semantic scholar was used to perform the forward snowballing.</p>
<p>We then tried to discover whether these papers were relevant to the research question, and repeated the process of forward snowballing until there were no more papers discovered.</p>
<p>We then read the paper to discover:</p>
<ul>
<li>A problem and/or solution to usability of interactive theorem provers</li>
<li>Which theorem prover the issue is relevant to</li>
<li>Evidence behind issues and proposed solutions</li>
</ul>
<p>The issues were then categorized by Green’s cognitive dimensions of notations <span class="citation" data-cites="green_usability_1996">[<a href="#ref-green_usability_1996" role="doc-biblioref">18</a>]</span>.</p>
<h2 id="living-review-methodology">Living Review Methodology</h2>
<p>The living review has the end goal of determining whether usability issues still exist, and then further offering a tool to help decision about ITPs (RQ3).</p>
<p>To do this, the living review is scoped as follows:</p>
<ul>
<li>Comparing general properties about ITPs (RQ3)</li>
<li>Comparing past projects that have been completed by ITPs (RQ3)</li>
<li>Comparing progress on usability issues about ITPs (RQ2)</li>
</ul>
<h3 id="general-features-of-about-itps">General features of about ITPs</h3>
<p>To compare between different ITPs, general features about them need to be collected.</p>
<p>We decided to use a 2019 Systematic Literature Reviews on Theorem Provers as our starting dataset <span class="citation" data-cites="nawaz_survey_2019">[<a href="#ref-nawaz_survey_2019" role="doc-biblioref">33</a>]</span>. This review went through 27 theorem provers and described the features that each prover had. This was converted into a dataset and used to compare general features.</p>
<p>This dataset contained several properties about ITPs, and properties to compare between them.</p>
<p>The full set of properties are:</p>
<ul>
<li>What the ITP is based on</li>
<li>The logic of the ITP</li>
<li>The Truth value of the ITP</li>
<li>Whether it supports Set theory</li>
<li>Whether it has a library</li>
<li>What its calculus is</li>
<li>What’s its architecture</li>
<li>The programming language it’s based on</li>
<li>The User interface</li>
<li>The Platforms its supported on</li>
<li>Whether it’s scalable</li>
<li>Multithreaded support</li>
<li>Whether it has an IDE</li>
<li>When it was first released.</li>
<li>Its latest release</li>
</ul>
<p>A lot of these features (such as the logic, truth value etc) require explanations as to what they refer to. These explanations will be included within the tool. This allows people unfamiliar to the field to learn what the components of ITPs are and why they are important.</p>
<p>Some Newer ITPs were not included in the dataset, such as Lean, F* and Idris. These were added manually to the dataset.</p>
<p>The systematic literature review we source our data from however, is already out of date for the latest release of its provers. As of such, we have a python script that automatically retrieves whether any newer versions of a prover have been released by checking GitHub Tags. It gets the latest tag to be published and adds that as the latest release on the living review, ensuring that the review doesn’t go out of date by having newer releases.</p>
<h3 id="comparing-projects-between-itps">Comparing projects between ITPs</h3>
<p>One important thing to consider when making decisions about ITPs to choose is what past projects have been completed within the ITP. As of such, we contain a literature review of different notable projects within the ITP.</p>
<!-- Need to be more specific -->
<h3 id="comparing-progress-on-usability-issues-for-itps">Comparing progress on usability issues for ITPs</h3>
<p>Finally, depending on the results of the literature review, progress on different usability issues will be reported in this living review.</p>
<h1 id="literature-review">Literature Review</h1>
<p>The amount of papers found in each section of the review are shown in tbl. <a href="#tbl:litresults">1</a>. This totals to 45 papers found on the topic. However, 1 paper had to be remove due to not being able to access it, making 44.</p>
<p>There was a surprisingly small amount of papers caught by query in comparison to snowballing. This is because many papers that discuss usability issues about ITPs do not tackle the problem directly (28/38 of the papers), but rather showcase a feature that has been coded into an ITP interface. These features do indeed solve a usability problem implicitly, and represent the bulk of the work on improving interfaces for ITPs. However, comparatively little research has been done identifying the issues with ITP interfaces and empirically comparing these user interface modifications for merit (10/38 of the papers).</p>
<div id="tbl:litresults">
<table>
<caption>Table 1: Literature review papers</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Round</th>
<th style="text-align: left;">Found</th>
<th style="text-align: left;">Relevant</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Query</td>
<td style="text-align: left;">45</td>
<td style="text-align: left;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;">Snowball 1</td>
<td style="text-align: left;">121</td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Snowball 2</td>
<td style="text-align: left;">191</td>
<td style="text-align: left;">5</td>
</tr>
<tr class="even">
<td style="text-align: left;">Snowball 3</td>
<td style="text-align: left;">99</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Snowball 4</td>
<td style="text-align: left;">44</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Snowball 5</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
</div>
<p>When going through papers, it was interesting to find a large amount of papers proposing user interface models, but not actually identifying the problems that they solve, nor evaluating their effectiveness. In fact, out of the 28 papers that showcased user interface improvements, only 2 papers evaluated the their interface improvement to without the improvement <span class="citation" data-cites="hentschel_empirical_2016 berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>, <a href="#ref-hentschel_empirical_2016" role="doc-biblioref">21</a>]</span>. That there is not enough empirical studies verifying usability issues has been cited as an issue that needs to addressed in the past <span class="citation" data-cites="hahnle_deductive_2019">[<a href="#ref-hahnle_deductive_2019" role="doc-biblioref">20</a>]</span>.</p>
<p>The following sections outline usability issues and solutions to those issues. Tables are included outlining the usability issues mentioned. If the same problem is mentioned in two papers, it is given two rows.</p>
<p>The theorem prover column refers to the theorem prover the usability issue was found in. If the problem is a general comment “General" is written.”Textual" means a theorem prover that uses proof script to solve theorems, such as Isabelle/HOL, Coq, Agda. “Direct Manipulation" means a theorem prover that uses direct manipulation to solve theorems, such as KeY.</p>
<p>The discovered column indicates the evidence that that problem exists. "Suggested" simply means that problem or solution was simply inferred or has not actually been evaluated as effective. Other values indicate the type of study that the paper used to observe or evaluate this problem or solution.</p>
<h2 id="theorem-provers">Theorem Provers</h2>
<p>First of all, a brief overview of the theorem provers is in order.</p>
<h4 id="key">KeY</h4>
<p>KeY is a Direct Manipulation theorem prover, meaning that unlike Textual theorem provers, does not prove theorems by writing proof scripts, but instead works by modifying a proof object directly until all proof obligations have been solved. KeY works by annotating Java programs with preconditions and postconditions. These conditions are then fed into KeY as proof obligations. KeY can act as a fully automatic prover, but also allows the user to attempt to find a proof if the prover fails. KeY has also formed the basis of KeYmaera and KeYmaera X, which are for proving properties of hybrid systems.</p>
<h4 id="hol">HOL</h4>
<p>HOL is actually a family of theorem provers. Notably HOL4, ProofPower, HOL Light and HOL Zero. HOL is one of the oldest provers in this list, and HOL Light is known to be used as a lightweight prover, with a very easily checkable kernel. HOL provers are textual, and have a simple type system and use tactics to prove propositions.</p>
<h4 id="isabelle">Isabelle</h4>
<p>Isabelle (also known as Isabelle/HOL, but for this paper will remain as Isabelle to prevent confusion) is one of the most popular theorem provers. The prover has been used for the verification of the SeL4 prover, and exists as the state-of-the-art of ITPs. Isabelle like HOL has a simple type system and is based of the Logic for Computable Functions.</p>
<h4 id="coq">Coq</h4>
<p>Coq is another popular ITP that also supports a dependent type system. It’s based on the Calculus of (Co)Inductive Constructions, which was designed specifically for Coq. Coq has been used to prove the four colour theorem, and create the CompCert certified C compiler.</p>
<h4 id="matita">Matita</h4>
<p>Matita is a theorem prover based on Coq’s Calculus of (Co)Inductive Constructions, and was designed to address many of the pain points in working with Coq. Matita is a much simpler prover that aims to present the theorem prover as editing a mathematical library. As of such, Matita’s solutions to problems are often pain points in Coq (mathematical notation, Tinycals etc).</p>
<p>There are a few other provers also in this review, such as iCon, CardiZ and Dafny. These ITPs are often either coded as proofs of concepts (such as iCon), or are no longer maintained (in the case of CardiZ or Dafny). The problems raised by them however, are often relevant for current day ITPs.</p>
<p>This is by no means a complete list of modern ITPs. Such compilations have been done <span class="citation" data-cites="nawaz_survey_2019">[<a href="#ref-nawaz_survey_2019" role="doc-biblioref">33</a>]</span>. These are only the ITPs discussed in the papers found in the review. There are notable ITPs that are missing from this list that caught us by surprise, including Agda, Lean and Mizar.</p>
<h2 id="interaction-paradigms">Interaction Paradigms</h2>
<p>Before moving into the actual problems and solutions found in ITPs, it’s worth giving a short history of the interaction paradigms of ITPs, and possible developments.</p>
<p>Direct Manipulation ITPs such as KeY work by editing proof objects until the obligations have been resolved. These provers often have issues with tedious interactions, and work has even been done add textual elements to KeY <span class="citation" data-cites="beckert_interaction_2017">[<a href="#ref-beckert_interaction_2017" role="doc-biblioref">9</a>]</span>. The development of interfaces to Direct Manipulation provers often differs from textual ones.</p>
<p>Textual ITPs such as HOL, Isabelle, Coq and Matita work by writing a proof script that attempts to prove a proposition. Interacting with textual ITPs often involves a very simple read-evaluate-print-loop (REPL) for their interfaces. One very stark example of this is HOL-Light, which you interact with by opening up the OCaml REPL (a general purpose ML based functional programming language) and loading the HOL library. All OCaml is available to you alongside the HOL library. Although this is rather primitive, modern ITP interfaces such as Isabelle/jEdit and CoqIDE usually offer only a small layer of abstraction over a REPL for their own languages.</p>
<p>These interfaces have two main windows, the first has code and the second has proof state. The code can be evaluated up to a certain point, and the output from the REPL in terms of proof state are printed in the second window. The only major difference between this and a standard REPL is that you can rewind to evaluate up to a previous line. This simple style of interface has consequences for usability. In particular, if any error is found either in proof or in syntax, execution stops until that error is resolved. Further, for larger projects, it can take a very long time for systems to recompile. It also means that you can only identify things that have already been identified (it has to be a single pass). This is particularly an issue when automated tactics attempt to use lemmas above them to find solutions to theorems (such as Isabelle). This means that simply changing the order of lemmas in an Isabelle document, even if they never reference lemmas that are below them, could cause a lemma that was proven before to become unproven.</p>
<p>Developments in IDEs to allow asynchronous interfaces, reloading only parts needed and loading proofs out of order have been introduces to fix this problem. They are called "Prover IDEs", with two examples being Isabelle/PIDE <span class="citation" data-cites="wenzel_asynchronous_2014">[<a href="#ref-wenzel_asynchronous_2014" role="doc-biblioref">39</a>]</span> and Coq/PIDE <span class="citation" data-cites="barras_asynchronous_2015">[<a href="#ref-barras_asynchronous_2015" role="doc-biblioref">6</a>]</span>. These hopefully will resolve some of the issues cited above.</p>
<p>Although we have examples of large projects undertaken with ITPs, optimal interaction paradigms are still up for debate, and several novel interaction paradigms have surfaced. Including proving theorems and writing tactics with diagrams <span class="citation" data-cites="grov_tinker_2018 lin_understanding_2016 shams_accessible_2018">[<a href="#ref-grov_tinker_2018" role="doc-biblioref">19</a>, <a href="#ref-lin_understanding_2016" role="doc-biblioref">30</a>, <a href="#ref-shams_accessible_2018" role="doc-biblioref">36</a>]</span>, or providing agent based interfaces <span class="citation" data-cites="hunter_agent-based_2005">[<a href="#ref-hunter_agent-based_2005" role="doc-biblioref">24</a>]</span>.</p>
<p>We now move into the usability problems and solutions found in ITPs.</p>
<h2 id="abstraction-gradient-1">Abstraction Gradient</h2>
<div id="tbl:abstraction_gradient">
<table>
<caption>Table 2: Abstraction Gradient Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Interaction with low level logic</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Missing Library</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>The abstraction gradient dimension concerns itself with the highest and lowest levels of abstraction that are presented. Are they at the appropriate level of abstraction?</p>
<p>Issues in this dimension were uncommon. KeY was found to require interacting on low level logic formulas consistently. Similar issues with tedious interactions with KeY are mentioned in the viscosity’s section. No solutions were found or suggested to this problem, and it has not been empirically tested.</p>
<p>Focus Groups found that Isabelle’s library lacks the appropriate mathematical foundations. Interestingly, this is the only issue of this class and is not mentioned elsewhere, often library issues are more about managing and searching large libraries, which Matita attempts to handle, and correct documentation of libraries. This has not been tested empirically. Other than the implicit solution of providing better library support for theorem provers, no solution has been provided for this problem.</p>
<h2 id="closeness-of-mapping-1">Closeness of Mapping</h2>
<div id="tbl:closeness_of_mapping">
<table>
<caption>Table 3: Closeness of Mapping Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Unintuitive mapping between formula and program</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">CardiZ</td>
<td style="text-align: left;">Cannot sketch out proofs</td>
<td style="text-align: left;">Questionnaire</td>
<td style="text-align: left;"><span class="citation" data-cites="kadoda_cognitive_2000">[<a href="#ref-kadoda_cognitive_2000" role="doc-biblioref">25</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot use mathematical notation</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot use mathematical notation</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="asperti_user_2007 zacchiroli_user_2007">[<a href="#ref-asperti_user_2007" role="doc-biblioref">3</a>, <a href="#ref-zacchiroli_user_2007" role="doc-biblioref">42</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>The dimension of closeness of mapping is whether the interface maps well to the problem world. For interactive theorem provers, it has to do with how well the proof state is understood in comparison to the actual problem.</p>
<p>Focus groups found that because KeY attempts to prove properties through annotations and java source code, it can sometimes be difficult to see how this proof state maps to the program <span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span>. This issue is not mentioned in any other source and not tested empirically. No solutions have been suggested for this.</p>
<p>CardiZ, an ITP that can be used to prove properties of Z specifications, found that you could not sketch out proofs before an attempt. This is the only paper on CardiZ, as CardiZ is not a popular prover. No solutions have been suggested for this.</p>
<p>A common issue that came up with Coq was the inability to use mathematical notation. Notation issues are problematic in ITPs. One one hand, theorem provers such as Isabelle and Agda allow using mathematical notation in their theorems. This helps the user understand the theorem in a terse syntax. On the other hand, mathematical notation can often be ambiguous and difficult to type. Isabelle allows using LaTeX style commands such as rightarrow to render math notation, whereas Agda allows Unicode in source files. In order to avoid ambiguity, Coq has no support for math notation, and in response to this, Matita has LaTeX style mathematical notation <span class="citation" data-cites="asperti_user_2007 zacchiroli_user_2007">[<a href="#ref-asperti_user_2007" role="doc-biblioref">3</a>, <a href="#ref-zacchiroli_user_2007" role="doc-biblioref">42</a>]</span>. This issue came up in three different sources.</p>
<h2 id="consistency-1">Consistency</h2>
<div id="tbl:consistency">
<table>
<caption>Table 4: Consistency Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Difficult to know what tactics and lemmas to use</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015 beckert_interaction_2017">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>, <a href="#ref-beckert_interaction_2017" role="doc-biblioref">9</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Difficult to know what tactic to apply next</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_interactive_1998">[<a href="#ref-aitken_interactive_1998" role="doc-biblioref">1</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hard to remember prover specific details</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="nagashima_pamper_2018">[<a href="#ref-nagashima_pamper_2018" role="doc-biblioref">32</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Difficult to know what tactic to apply next</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="mitsch_keymaera_2017">[<a href="#ref-mitsch_keymaera_2017" role="doc-biblioref">31</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle,HOL</td>
<td style="text-align: left;">Difficult to remember names of theorems</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_analysis_2000">[<a href="#ref-aitken_analysis_2000" role="doc-biblioref">2</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Difficult to find relevant lemmas</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Difficult to find arguments for tactics</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="ringer_replica_2020">[<a href="#ref-ringer_replica_2020" role="doc-biblioref">34</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Bad Library, inconsistent naming</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>Consistency is the cognitive dimension of whether, once learning part of the notation, you are able to infer the rest of the notation.</p>
<p>In textual theorem provers, it is often difficult to remember the name of the next tactic, theorems or lemmas should be applied in any situation. This has been bought up in focus groups <span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span>, observational studies <span class="citation" data-cites="aitken_analysis_2000">[<a href="#ref-aitken_analysis_2000" role="doc-biblioref">2</a>]</span>, surveys <span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span> and suggested as a problem from various other sources.</p>
<p>Solutions to this problem often include choosing applicable tactics by menu <span class="citation" data-cites="aitken_analysis_2000 aitken_interactive_1998">[<a href="#ref-aitken_interactive_1998" role="doc-biblioref">1</a>, <a href="#ref-aitken_analysis_2000" role="doc-biblioref">2</a>]</span> Which has been implemented in Coq through Proof Previews <span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span> and in KeYmaera X <span class="citation" data-cites="mitsch_keymaera_2017">[<a href="#ref-mitsch_keymaera_2017" role="doc-biblioref">31</a>]</span>. Machine learning for choosing appropriate recommendations has been suggested for this problem <span class="citation" data-cites="ringer_replica_2020">[<a href="#ref-ringer_replica_2020" role="doc-biblioref">34</a>]</span>, and has also been implemented through the PaMpeR tool in Isabelle <span class="citation" data-cites="nagashima_pamper_2018">[<a href="#ref-nagashima_pamper_2018" role="doc-biblioref">32</a>]</span>. A second way of tackling this problem is to improve library searching, which was suggested <span class="citation" data-cites="aitken_analysis_2000">[<a href="#ref-aitken_analysis_2000" role="doc-biblioref">2</a>]</span> and is a focus in Matita <span class="citation" data-cites="tassi_interactive_2008">[<a href="#ref-tassi_interactive_2008" role="doc-biblioref">38</a>]</span>. Improving these tools is a promising area for improving the usability of ITPs</p>
<h2 id="diffuseness-terseness">Diffuseness / terseness</h2>
<div id="tbl:diffuseness">
<table>
<caption>Table 5: Diffuseness / Terseness Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Bloated Formulas</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Large proofs correspond to large effort</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>Diffuseness is the cognitive dimension of the tersity/verbosity of the syntax. Bloated formulas were mentioned in Isabelle in Focus Groups, and projects with more lines of code were strongly correlated with more effort. No solutions have been suggested to reducing the size of code bases or formulas.</p>
<h2 id="error-proneness-1">Error Proneness</h2>
<div id="tbl:error_proneness">
<table>
<caption>Table 6: Error Proneness Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle,HOL</td>
<td style="text-align: left;">Easy to get errors in Object Level Constructions</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_analysis_2000">[<a href="#ref-aitken_analysis_2000" role="doc-biblioref">2</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle,HOL</td>
<td style="text-align: left;">Incorrect predictions made about tactics</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_analysis_2000">[<a href="#ref-aitken_analysis_2000" role="doc-biblioref">2</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Difficult to manage namespace</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>Error proneness is the cognitive dimension of whether a system allows its users to make errors.</p>
<p>Observational studies have found that in Isabelle and HOL it is easy to make errors in syntax. Considering the frequency of syntax errors, this issue came up surprisingly little other sources. This could be because syntax errors are relatively easy to fix and also decrease with usage. It’s been suggested that this problem could be solved my improving feedback in Object Level syntax input <span class="citation" data-cites="aitken_analysis_2000">[<a href="#ref-aitken_analysis_2000" role="doc-biblioref">2</a>]</span>. A more interesting solution has been implemented for Coq is a structure editor based off keyboard cards <span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span>. This uses rolling chords (like <em>vi</em>) keyboard interfaces to interact with the theorem prover. This means that it is only possible to enter syntactically valid statements. This current solution only works on a subset of Coq’s syntax. It was found to be slightly quicker than using dropdown menus.</p>
<p>Sometimes when applying a tactic, an unexpected result would occur, causing the user to back up and try to understand the current state. This issue could be solved by Proof Previews <span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span>, which allow you to see a proof state when selecting tactics from a menu without actually applying the tactic. That way the user can cheaply explore tactics to continue in the proof.</p>
<p>Finally, for large verification projects such as SeL4, there is an issue with managing the namespaces of large amounts of theorems and lemmas. No verification of this problem nor solution has been suggested.</p>
<h2 id="hard-mental-operations-1">Hard mental operations</h2>
<div id="tbl:hard_mental_operations">
<table>
<caption>Table 7: Hard Mental Operations Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Hard to understand proof scripts statically</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="zacchiroli_user_2007">[<a href="#ref-zacchiroli_user_2007" role="doc-biblioref">42</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Difficult to understand tacticals</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="grov_tinker_2018 lin_understanding_2016">[<a href="#ref-grov_tinker_2018" role="doc-biblioref">19</a>, <a href="#ref-lin_understanding_2016" role="doc-biblioref">30</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Proof scripts can become complicated</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aspinall_towards_2016">[<a href="#ref-aspinall_towards_2016" role="doc-biblioref">5</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>The dimension of Hard Mental operations refer to the difficulty in understanding and using the interface on a syntax level. This type of issue is common with ITPs, as the actual domain is complicated, so this is reflected with difficult syntax.</p>
<p>Proofs are hard enough to understand while viewing the dynamic nature of the proof, investigating proof state bit by bit. They are often near impossible to understand statically <span class="citation" data-cites="zacchiroli_user_2007">[<a href="#ref-zacchiroli_user_2007" role="doc-biblioref">42</a>]</span>. This issue has not been investigated empirically, but solutions often involve changing the syntax around proofs. One notable example of this is Isar for Isabelle <span class="citation" data-cites="wenzel_structured_2006">[<a href="#ref-wenzel_structured_2006" role="doc-biblioref">41</a>]</span>, which attempts to mirror how a pen and paper proof is structured.</p>
<p>It is often difficult to understand tacticals, and the problem is made even worse when it is not possible to view the state of a tactical mid way through interaction. This problem has been suggested in several sources <span class="citation" data-cites="grov_tinker_2018 lin_understanding_2016 zacchiroli_user_2007">[<a href="#ref-grov_tinker_2018" role="doc-biblioref">19</a>, <a href="#ref-lin_understanding_2016" role="doc-biblioref">30</a>, <a href="#ref-zacchiroli_user_2007" role="doc-biblioref">42</a>]</span> but never empirically investigated. Solutions to this include representing tacticals as graphs <span class="citation" data-cites="grov_tinker_2018 lin_understanding_2016">[<a href="#ref-grov_tinker_2018" role="doc-biblioref">19</a>, <a href="#ref-lin_understanding_2016" role="doc-biblioref">30</a>]</span>. This solution has not been tested with users.</p>
<p>Proof scripts can also get very complicated for larger propositions. Keeping track of this complexity has been suggested with proof metrics, which are similar to classic code complexity metrics <span class="citation" data-cites="aspinall_towards_2016">[<a href="#ref-aspinall_towards_2016" role="doc-biblioref">5</a>]</span>.</p>
<h2 id="hidden-dependencies-1">Hidden dependencies</h2>
<div id="tbl:hidden_dependencies">
<table>
<caption>Table 8: Hidden Dependencies Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hard to see dependencies between proofs</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="spichkova_human-centred_2017">[<a href="#ref-spichkova_human-centred_2017" role="doc-biblioref">37</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Difficult to patch proofs that have slightly changed</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">[<a href="#ref-beckert_evaluating_2012" role="doc-biblioref">10</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hidden automation dependencies</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Difficult to patch proofs when dependencies change</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hard to see dependencies between proofs</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aspinall_towards_2016">[<a href="#ref-aspinall_towards_2016" role="doc-biblioref">5</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>Hidden dependencies represent dependencies between components that are not shown explicitly. Hidden dependencies are everywhere in theorem provers. Like functions in many programming languages, lemmas can reference the lemmas that they use, but it is difficult to find where a particular lemma has been used. Automation makes this problem even worse, where in Isabelle, an automatic tactic will try lemmas that are above it in the theory. This makes moving lemmas around a theory document difficult. Moving a lemma around a document, even if all the other lemmas it is references are above it, may cause it to fail due to it using a lemma by automation. Monitoring dependencies has been suggested as part of formal proof metrics. It’s been suggested and implemented within CoqPIE to show these dependencies within the IDE <span class="citation" data-cites="roe_coqpie_2016">[<a href="#ref-roe_coqpie_2016" role="doc-biblioref">35</a>]</span>. Tools have also been built to analyse dependencies between Isabelle proofs <span class="citation" data-cites="spichkova_human-centred_2017">[<a href="#ref-spichkova_human-centred_2017" role="doc-biblioref">37</a>]</span>. For automated tactics, Isabelle’s sledgehammer offers a unique solution to showing dependencies. The automatic tactic, after execution, simply prints a set of manual tactics that were used to prove the theorem into the document. That way, all the lemmas that were used in the automated tactic are made explicit <span class="citation" data-cites="bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span>. None of these solutions have been empirically tested for validity.</p>
<p>Furthermore, often changing a definition or proof slightly requires changing the proof in order to match the new definitions. This is a tedious process.</p>
<p>None of these issues have been tested empirically.</p>
<h2 id="perceptual-cues-1">Perceptual cues</h2>
<div id="tbl:perceptual_cues">
<table>
<caption>Table 9: Perceptual Cues Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Difficult to understand proof state</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="kadoda_cognitive_2000">[<a href="#ref-kadoda_cognitive_2000" role="doc-biblioref">25</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Difficult to understand proof state</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="hentschel_integrating_2016">[<a href="#ref-hentschel_integrating_2016" role="doc-biblioref">22</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Difficult to understand proof state</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="eastaughffe_support_1998">[<a href="#ref-eastaughffe_support_1998" role="doc-biblioref">14</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>Perceptual cues is how easy it is to understand what is being represented. Understanding proof state is an enormous part of theorem proving. The normal solutions to understanding proof state are to offer more ways of viewing it, and ensuring easy access to these views. As of such, solutions are found in the visibility section.</p>
<h2 id="premature-commitment-1">Premature Commitment</h2>
<table>
<caption>Premature Commitment Problems {#tbl:premature_commitment</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Need to redesign model if proof attempt fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Have to apply tactics before understanding what they do</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
</tbody>
</table>
<p>When an attempt to prove a theorem fails, either one of two things has happened. First, the proof you are attempting to perform is incorrect, or the model itself is in error. The model is often in error, and as of such there is a premature commitment to a model before having a full understanding. Counterexample generators such as Quick Check and nitpick <span class="citation" data-cites="beckert_usability_2015 beckert_interaction_2017">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>, <a href="#ref-beckert_interaction_2017" role="doc-biblioref">9</a>]</span> for Isabelle help prevent the user from trying to prove improvable lemmas by providing the user with a counterexamples to show why their lemmas can’t be true.</p>
<p>Furthermore, tactics often need to be applied to discover what they do. Typing out this tactic is part of the exploration, and represents another premature commitment. A cheaper way to explore tactic applications were trialed with Proof previews in Coq <span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span>. These proof previews allowed the selection of the next tactic by menu, and hovering over a tactic previewed it’s application in a separate window. This was found to be helpful with users.</p>
<h2 id="progressive-evaluation-1">Progressive Evaluation</h2>
<div id="tbl:progressive_evaluation">
<table>
<caption>Table 10: Progressive Evaluation Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Hard to understand why proof state fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="hentschel_interactive_2016">[<a href="#ref-hentschel_interactive_2016" role="doc-biblioref">23</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Hard to understand why proof state fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_interaction_2017 beckert_interactive_2015 beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>, <a href="#ref-beckert_interaction_2017" role="doc-biblioref">9</a>, <a href="#ref-beckert_interactive_2015" role="doc-biblioref">11</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Dafny</td>
<td style="text-align: left;">Hard to understand why proof state fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="grebing_seamless_2020">[<a href="#ref-grebing_seamless_2020" role="doc-biblioref">16</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Hard to understand why proof state fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="lin_understanding_2016">[<a href="#ref-lin_understanding_2016" role="doc-biblioref">30</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Hard to understand automated tactics</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="mitsch_keymaera_2017">[<a href="#ref-mitsch_keymaera_2017" role="doc-biblioref">31</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">e General</td>
<td style="text-align: left;">Not enough feedback hinders learning</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="mitsch_keymaera_2017">[<a href="#ref-mitsch_keymaera_2017" role="doc-biblioref">31</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Lack of background automation</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Lack of background automation</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="hunter_agent-based_2005">[<a href="#ref-hunter_agent-based_2005" role="doc-biblioref">24</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Bad feedback hinders learning</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">[<a href="#ref-beckert_evaluating_2012" role="doc-biblioref">10</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Don’t know whether an automated tactic would prove a goal</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Non reactive interfaces</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hard to understand errors from bad inferences of types</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Performance of automatic strategy</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle,KeY</td>
<td style="text-align: left;">Difficult to understand automated strategy</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>Progressive evaluation is the dimension of getting appropriate feedback from the system.</p>
<p>Not understanding why proof attempts fails in a widely cited example of this. This becomes especially true when automation is added to the mix. Insight to the operation of automated tactics is missing in many ITPs. This has been suggested to be one of the largest issues with the usability of ITPs in Focus Groups <span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span>. Although there is little empirical evidence of this issue, the fact that it is so widely cited indicates importance. Solutions to this issue often resolve around providing better visibility, and are covered there.</p>
<p>Other issues include that systems with low feedback make it difficult to teach using ITPs, and that ITPs do not effectively use background processing to provide the user with feedback. One way of improving feedback is using a cache of proof state <span class="citation" data-cites="berman_development_2014 bourke_challenges_2012">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>, <a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span>. Another more novel way is to provide an agent based interaction model <span class="citation" data-cites="hunter_agent-based_2005">[<a href="#ref-hunter_agent-based_2005" role="doc-biblioref">24</a>]</span>, where the user interfaces have a "Personal assistant", who then negotiates with proof agents to help solve a particular proof. This makes best use of background processing while the user is trying to solve a problem. Neither of these have been tested with users.</p>
<p>Finally, it was mentioned in a survey of Coq users that it would be nice to know in advance whether an automated tactic could prove a goal. This would prevent further unnecessary work.</p>
<h2 id="secondary-notation-1">Secondary Notation</h2>
<p>Secondary notation is the realm of comments, documentation, and even use of visual placement to convey meaning. Problems due to lack of secondary notation are usually simply because of missing features, and are therefore more naturally discussed as solutions.</p>
<div id="tbl:secondary_notation">
<table>
<caption>Table 11: Secondary Notation Solutions</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Intervention</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Allow notes in tree contexts</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_interactive_1998">[<a href="#ref-aitken_interactive_1998" role="doc-biblioref">1</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle,HOL</td>
<td style="text-align: left;">Allow adding notes to proof context</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">[<a href="#ref-beckert_evaluating_2012" role="doc-biblioref">10</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Add document orientated features</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="wenzel_isabelle_2011">[<a href="#ref-wenzel_isabelle_2011" role="doc-biblioref">40</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Gravity for automated lemma placement</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Deprecation tags</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Doc comments</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">HOL/CardiZ</td>
<td style="text-align: left;">Colour and low secondary notation</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="kadoda_cognitive_2000">[<a href="#ref-kadoda_cognitive_2000" role="doc-biblioref">25</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Lack of good tutorials and documentation</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Poor documentation</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">[<a href="#ref-beckert_evaluating_2012" role="doc-biblioref">10</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Better libraries and documentation</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>One improvement on secondary notations is the ability to note and label parts of proof context. Usually, proof context is boxed off and cannot be documented other than basic comments. Interestingly, although this feature is cited multiple times. It remains, to the best of my knowledge, unimplemented, and as with the rest of the solutions in this category, untested.</p>
<p>Document oriented proof organization tries to make each theory readable both to a human and to a computer, and involves allowing linking to external theories, websites, diagrams and other features all in the prover editor. This is commonly done with web interfaces controlled by ITP code. This method has not been investigated as being beneficial, but Matita itself was built to support this style of interaction.</p>
<p>Features such as deprecation tags, doc comments and automatic naming of lemmas frequently showed up. These indicate that it is important for the user to break out and write hints to help themselves and others navigate their code. These have been implemented in some provers, but again, have not been tested.</p>
<p>Finally, a very common issue with ITPs is the lack of tutorials and documentation, particularly around library functionality. This is remarkably important, regardless of what the prover is.</p>
<h2 id="viscosity-1">Viscosity</h2>
<div id="tbl:viscosity">
<table>
<caption>Table 12: Viscosity Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Messy Downwards compatibility</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">No support for proof refactoring</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Direct Manipulation</td>
<td style="text-align: left;">Tedious Interactions</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="grebing_usability_2020 beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>, <a href="#ref-grebing_usability_2020" role="doc-biblioref">17</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Hard to make effective use of large library</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="asperti_considerations_2010 tassi_interactive_2008">[<a href="#ref-asperti_considerations_2010" role="doc-biblioref">4</a>, <a href="#ref-tassi_interactive_2008" role="doc-biblioref">38</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Tacticals difficult to write</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="becker_lassie_2021">[<a href="#ref-becker_lassie_2021" role="doc-biblioref">7</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Have to update proofs once definition changes</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="ringer_replica_2020">[<a href="#ref-ringer_replica_2020" role="doc-biblioref">34</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Proof renaming and refactoring is tedious</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="ringer_replica_2020">[<a href="#ref-ringer_replica_2020" role="doc-biblioref">34</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Large proof scripts require too long to recompile</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="barras_asynchronous_2015">[<a href="#ref-barras_asynchronous_2015" role="doc-biblioref">6</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Large proof scripts require too long to recompile</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="wenzel_asynchronous_2014">[<a href="#ref-wenzel_asynchronous_2014" role="doc-biblioref">39</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Difficult to select terms</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Unnecessary re-running of proofs</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Slow for large proofs</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="roe_coqpie_2016">[<a href="#ref-roe_coqpie_2016" role="doc-biblioref">35</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Change in lemma requires change in proof</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="roe_coqpie_2016">[<a href="#ref-roe_coqpie_2016" role="doc-biblioref">35</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Bad change management</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">[<a href="#ref-beckert_evaluating_2012" role="doc-biblioref">10</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Bad Automated proof performance</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">[<a href="#ref-beckert_evaluating_2012" role="doc-biblioref">10</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Hard to decompose proof</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_interactive_2015">[<a href="#ref-beckert_interactive_2015" role="doc-biblioref">11</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>Viscosity is the cognitive dimension of the ease of changing the state of the programs.</p>
<p>One source of viscosity is simply performance. As automatic strategies get more complicated, their performance becomes important for them to be useful to the user. This has been suggested by focus groups and in surveys. This becomes a particularly difficult problem especially for larger systems. Attempts to improve performance have been done by asynchronously loading only required parts of the proof in Coq <span class="citation" data-cites="barras_asynchronous_2015">[<a href="#ref-barras_asynchronous_2015" role="doc-biblioref">6</a>]</span> and Isabelle <span class="citation" data-cites="wenzel_asynchronous_2014">[<a href="#ref-wenzel_asynchronous_2014" role="doc-biblioref">39</a>]</span>. Improvements to performance of automatic strategies will always be an improvement <span class="citation" data-cites="bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>]</span>, including making better use of the library <span class="citation" data-cites="tassi_interactive_2008 asperti_considerations_2010">[<a href="#ref-asperti_considerations_2010" role="doc-biblioref">4</a>, <a href="#ref-tassi_interactive_2008" role="doc-biblioref">38</a>]</span>.</p>
<p>A second source is the need to make trivial interactions when making small changes. For instance, the renaming of a lemma might mean you need to go through several files to find where to change the identifier. Messy downwards compatibility, changing definitions, and lack of refactoring are all examples of this. These are usually addressed by refactoring tools that have been suggested as necessary <span class="citation" data-cites="ringer_replica_2020 bourke_challenges_2012">[<a href="#ref-bourke_challenges_2012" role="doc-biblioref">13</a>, <a href="#ref-ringer_replica_2020" role="doc-biblioref">34</a>]</span> and implemented in some IDEs such as CoqPIE <span class="citation" data-cites="roe_coqpie_2016">[<a href="#ref-roe_coqpie_2016" role="doc-biblioref">35</a>]</span>. These solutions have not been tested with users.</p>
<p>The third is simply interactions that are tedious and error prone. This is more common in direct manipulation theorem provers such as KeY. No solutions have been suggested for this problem.</p>
<p>Finally, the fourth source of viscosity is clunky syntax, such as the need to explain selections to the theorem prover. Selections are a common issue where you need to describe the part of the goal that you want to rewrite. This part might be complicated, but has to be represented textually. This has served as a challenge for ITP designers. Selections using patterns has been implemented in Matita <span class="citation" data-cites="zacchiroli_user_2007 asperti_user_2007">[<a href="#ref-asperti_user_2007" role="doc-biblioref">3</a>, <a href="#ref-zacchiroli_user_2007" role="doc-biblioref">42</a>]</span> to address this pain point.</p>
<h2 id="visibility">Visibility</h2>
<div id="tbl:visibility">
<table>
<caption>Table 13: Visibility Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Proof tree too detailed</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">[<a href="#ref-beckert_usability_2015" role="doc-biblioref">8</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Textual</td>
<td style="text-align: left;">Limited insight to automated tactics</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="grebing_usability_2020">[<a href="#ref-grebing_usability_2020" role="doc-biblioref">17</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Hard to understand proof tree</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_interactive_1998">[<a href="#ref-aitken_interactive_1998" role="doc-biblioref">1</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Allow showing and hiding of proof contexts</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_interactive_1998">[<a href="#ref-aitken_interactive_1998" role="doc-biblioref">1</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot see intermediate proof states</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="zacchiroli_user_2007">[<a href="#ref-zacchiroli_user_2007" role="doc-biblioref">42</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Difficult to see structure of proof tree</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot see the relation between subgoals</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot quickly see type or simplification of term</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Bad presentation of incomplete proofs</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">[<a href="#ref-beckert_evaluating_2012" role="doc-biblioref">10</a>]</span></td>
</tr>
</tbody>
</table>
</div>
<p>Visibility was a commonly cited issue with interactive theorem provers.</p>
<p>The cognitive dimension of visibility has to do with being able to how information can be identified and accessible to the user. For the case of interactive theorem provers, there were cases where theorem provers show too much or too little information.</p>
<p>Direct manipulation theorem provers such as KeY were found to show too much information in the proof tree, which overwhelms the user trying to work out why a proof attempt has failed. The simplest solution to this is to only show information needed <span class="citation" data-cites="eastaughffe_support_1998">[<a href="#ref-eastaughffe_support_1998" role="doc-biblioref">14</a>]</span> and allow the opening and closing of views <span class="citation" data-cites="aitken_interactive_1998">[<a href="#ref-aitken_interactive_1998" role="doc-biblioref">1</a>]</span>. However, some IDEs (such as CoqIDE) come without a proof tree. These have been considered helpful <span class="citation" data-cites="berman_development_2014 aitken_interactive_1998">[<a href="#ref-aitken_interactive_1998" role="doc-biblioref">1</a>, <a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span> and have been implemented with Traf <span class="citation" data-cites="kawabata_traf_2018">[<a href="#ref-kawabata_traf_2018" role="doc-biblioref">27</a>]</span></p>
<p>In contrast, it’s also been claimed that there is a lack of visibility of the proof state, particularly intermediate proof states within textual theorem provers. The lack of visibility is often to do with intermediate proof states. An intermediate proof state is the state that a proof is in before the full completion of a tactic, and can be used to determine how a tactic got to a particular proof state. Understanding these intermediate proof states is important in understanding the process of automatic theorem provers and the current state. Viewing intermediate proof states is not possible with Isabelle/HOL or Coq. In fact, it is not even possible to investigate the inside of tacticals making it even more difficult to understand intuitively a proof. The tactical problem has been resolved by only using a subset of tacticals with Matita’s Tinycals <span class="citation" data-cites="asperti_user_2007 zacchiroli_user_2007">[<a href="#ref-asperti_user_2007" role="doc-biblioref">3</a>, <a href="#ref-zacchiroli_user_2007" role="doc-biblioref">42</a>]</span>. KeYmaera X also offers traceability with automatic tactics, allowing insight to the operations they performed <span class="citation" data-cites="mitsch_keymaera_2017">[<a href="#ref-mitsch_keymaera_2017" role="doc-biblioref">31</a>]</span>.</p>
<p>In one of the only empirical tests of two different user interfaces, an interface akin to a symbolic debugger is compared against the standard interface of KeY <span class="citation" data-cites="hentschel_integrating_2016 hentschel_empirical_2016 hentschel_interactive_2016">[<a href="#ref-hentschel_empirical_2016" role="doc-biblioref">21</a>–<a href="#ref-hentschel_interactive_2016" role="doc-biblioref">23</a>]</span>. The symbol debugger was found to be easier to use. The interfaces are very different, and it could be for a variety of reasons. One such reason is that the interface of a symbolic debugger maps better onto the context of source code, and offers visibility of that connection. Offering different ways of viewing and interacting with proof state has been suggested as a way forward in the usability of ITPs <span class="citation" data-cites="eastaughffe_support_1998 grebing_seamless_2020">[<a href="#ref-eastaughffe_support_1998" role="doc-biblioref">14</a>, <a href="#ref-grebing_seamless_2020" role="doc-biblioref">16</a>]</span>.</p>
<p>Diagrammatic representations of proof is an alternative way of proving theorems, as demonstrated with iCon <span class="citation" data-cites="shams_accessible_2018">[<a href="#ref-shams_accessible_2018" role="doc-biblioref">36</a>]</span> and Proof Transitions in CoqEdit <span class="citation" data-cites="berman_development_2014">[<a href="#ref-berman_development_2014" role="doc-biblioref">12</a>]</span>. This has not been tested empirically against other ITPs</p>
<h2 id="final-analysis">Final Analysis</h2>
<p>Many problems were identified. A summary of the problem is tabulated in fig. <a href="#fig:usability_issues">1</a>.</p>
<figure>
<img src="./Images/MyProblem.png" id="fig:usability_issues" alt="Figure 1: Identified Usability Issues" /><figcaption aria-hidden="true">Figure 1: Identified Usability Issues</figcaption>
</figure>
<p>This analysis answers Research Question 1.</p>
<h1 id="results">Results</h1>
<p>The result of the living review was the following tool:</p>
<div id="itps">

</div>
<h1 id="discussion">Discussion</h1>
<p>This living literature review offers a lot to the field of ITPs.</p>
<p>It tracks progress on different ITPs, allowing people new to the field to get familiar with different ITPs and the differences between them. This lowers the bar for entry into ITP research and usage, hopefully encouraging more usage</p>
<p>It further helps those who want to contribute, either in projects or packages, to the theorem provers. It helps them identify whether their task has already been completed, or what gaps exist that they could fill in ITP support.</p>
<p>It also offers an honest summary of the field for people interested in starting using ITPs in their own projects and verify their own software.</p>
<h1 class="unnumbered" id="bibliography">Bibliography</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-aitken_interactive_1998" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">Aitken, J.S. et al. 1998. Interactive <span>Theorem</span> <span>Proving</span>: <span>An</span> <span>Empirical</span> <span>Study</span> of <span>User</span> <span>Activity</span>. <em>Journal of Symbolic Computation</em>. 25, 2 (1998), 263–284. DOI:https://doi.org/<a href="https://doi.org/10.1006/jsco.1997.0175">https://doi.org/10.1006/jsco.1997.0175</a>.</div>
</div>
<div id="ref-aitken_analysis_2000" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">Aitken, S. and Melham, T. 2000. An analysis of errors in interactive proof attempts. <em>Interacting with Computers</em>. 12, 6 (2000), 565–586. DOI:https://doi.org/<a href="https://doi.org/10.1016/S0953-5438(99)00023-5">10.1016/S0953-5438(99)00023-5</a>.</div>
</div>
<div id="ref-asperti_user_2007" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">Asperti, A. et al. 2007. User <span>Interaction</span> with the <span>Matita</span> <span>Proof</span> <span>Assistant</span>. <em>Journal of Automated Reasoning</em>. 39, 2 (Aug. 2007), 109–139. DOI:https://doi.org/<a href="https://doi.org/10.1007/s10817-007-9070-5">10.1007/s10817-007-9070-5</a>.</div>
</div>
<div id="ref-asperti_considerations_2010" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">Asperti, A. and Coen, C.S. 2010. Some <span>Considerations</span> on the <span>Usability</span> of <span>Interactive</span> <span>Provers</span>. <em>Proceedings of the 10th <span>ASIC</span> and 9th <span>MKM</span> <span>International</span> <span>Conference</span>, and 17th <span>Calculemus</span> <span>Conference</span> on <span>Intelligent</span> <span>Computer</span> <span>Mathematics</span></em> (Berlin, Heidelberg, 2010), 147–156.</div>
</div>
<div id="ref-aspinall_towards_2016" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">Aspinall, D. and Kaliszyk, C. 2016. Towards <span>Formal</span> <span>Proof</span> <span>Metrics</span>. <em>Fundamental <span>Approaches</span> to <span>Software</span> <span>Engineering</span></em> (Berlin, Heidelberg, 2016), 325–341.</div>
</div>
<div id="ref-barras_asynchronous_2015" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">Barras, B. et al. 2015. Asynchronous <span>Processing</span> of <span>Coq</span> <span>Documents</span>: <span>From</span> the <span>Kernel</span> up to the <span>User</span> <span>Interface</span>. <em>Interactive <span>Theorem</span> <span>Proving</span></em> (Cham, 2015), 51–66.</div>
</div>
<div id="ref-becker_lassie_2021" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">Becker, H. et al. 2021. Lassie: <span>HOL4</span> <span>Tactics</span> by <span>Example</span>. <em>Proceedings of the 10th <span>ACM</span> <span>SIGPLAN</span> <span>International</span> <span>Conference</span> on <span>Certified</span> <span>Programs</span> and <span>Proofs</span></em> (New York, NY, USA, 2021), 212–223.</div>
</div>
<div id="ref-beckert_usability_2015" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">Beckert, B. et al. 2015. A <span>Usability</span> <span>Evaluation</span> of <span>Interactive</span> <span>Theorem</span> <span>Provers</span> <span>Using</span> <span>Focus</span> <span>Groups</span>. <em>Software <span>Engineering</span> and <span>Formal</span> <span>Methods</span></em> (Cham, 2015), 3–19.</div>
</div>
<div id="ref-beckert_interaction_2017" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">Beckert, B. et al. 2017. An <span>Interaction</span> <span>Concept</span> for <span>Program</span> <span>Verification</span> <span>Systems</span> with <span>Explicit</span> <span>Proof</span> <span>Object</span>. <em>Hardware and <span>Software</span>: <span>Verification</span> and <span>Testing</span></em> (Cham, 2017), 163–178.</div>
</div>
<div id="ref-beckert_evaluating_2012" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">Beckert, B. and Grebing, S. 2012. Evaluating the <span>Usability</span> of <span>Interactive</span> <span>Verification</span> <span>Systems</span>. <em><span>COMPARE</span></em> (2012).</div>
</div>
<div id="ref-beckert_interactive_2015" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">Beckert, B. and Grebing, S. 2015. Interactive <span>Theorem</span> <span>Proving</span> - <span>Modelling</span> the <span>User</span> in the <span>Proof</span> <span>Process</span>. <em>Bridging@<span>CADE</span></em> (2015).</div>
</div>
<div id="ref-berman_development_2014" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">Berman, B.A. 2014. <em>Development and user testing of new user interfaces for mathematics and programming tools</em>. University of Iowa.</div>
</div>
<div id="ref-bourke_challenges_2012" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">Bourke, T. et al. 2012. Challenges and <span>Experiences</span> in <span>Managing</span> <span>Large</span>-<span>Scale</span> <span>Proofs</span>. <em>Intelligent <span>Computer</span> <span>Mathematics</span></em> (Berlin, Heidelberg, 2012), 32–48.</div>
</div>
<div id="ref-eastaughffe_support_1998" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">Eastaughffe, K. 1998. Support for <span>Interactive</span> <span>Theorem</span> <span>Proving</span>: <span>Some</span> <span>Design</span> <span>Principles</span> and <span>Their</span> <span>Application</span>. (1998).</div>
</div>
<div id="ref-four_colour_2008" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">Gonthier, G. 2008. Formal proof — the four-color theorem. <em>Notices American Mathematical Society</em>. (2008), 1382--1393.</div>
</div>
<div id="ref-grebing_seamless_2020" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[16] </div><div class="csl-right-inline">Grebing, S. et al. 2020. Seamless <span>Interactive</span> <span>Program</span> <span>Verification</span>. <em>Verified <span>Software</span>. <span>Theories</span>, <span>Tools</span>, and <span>Experiments</span></em> (Cham, 2020), 68–86.</div>
</div>
<div id="ref-grebing_usability_2020" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[17] </div><div class="csl-right-inline">Grebing, S. and Ulbrich, M. 2020. Usability <span>Recommendations</span> for <span>User</span> <span>Guidance</span> in <span>Deductive</span> <span>Program</span> <span>Verification</span>. <em>Deductive <span>Software</span> <span>Verification</span>: <span>Future</span> <span>Perspectives</span>: <span>Reflections</span> on the <span>Occasion</span> of 20 <span>Years</span> of <span>KeY</span></em>. W. Ahrendt et al., eds. Springer International Publishing. 261–284.</div>
</div>
<div id="ref-green_usability_1996" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[18] </div><div class="csl-right-inline">Green, T.R.G. and Petre, M. 1996. Usability <span>Analysis</span> of <span>Visual</span> <span>Programming</span> <span>Environments</span>: <span>A</span> <span>‘<span>Cognitive</span> <span>Dimensions</span>’</span> <span>Framework</span>. <em>Journal of Visual Languages &amp; Computing</em>. 7, 2 (1996), 131–174. DOI:https://doi.org/<a href="https://doi.org/10.1006/jvlc.1996.0009">https://doi.org/10.1006/jvlc.1996.0009</a>.</div>
</div>
<div id="ref-grov_tinker_2018" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[19] </div><div class="csl-right-inline">Grov, G. and Lin, Y. 2018. The <span>Tinker</span> tool for graphical tactic development. <em>International Journal on Software Tools for Technology Transfer</em>. 20, 2 (Apr. 2018), 139–155. DOI:https://doi.org/<a href="https://doi.org/10.1007/s10009-017-0452-7">10.1007/s10009-017-0452-7</a>.</div>
</div>
<div id="ref-hahnle_deductive_2019" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[20] </div><div class="csl-right-inline">Hähnle, R. and Huisman, M. 2019. Deductive <span>Software</span> <span>Verification</span>: <span>From</span> <span>Pen</span>-and-<span>Paper</span> <span>Proofs</span> to <span>Industrial</span> <span>Tools</span>. <em>Computing and <span>Software</span> <span>Science</span>: <span>State</span> of the <span>Art</span> and <span>Perspectives</span></em>. B. Steffen and G. Woeginger, eds. Springer International Publishing. 345–373.</div>
</div>
<div id="ref-hentschel_empirical_2016" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[21] </div><div class="csl-right-inline">Hentschel, M. et al. 2016. An <span>Empirical</span> <span>Evaluation</span> of <span>Two</span> <span>User</span> <span>Interfaces</span> of an <span>Interactive</span> <span>Program</span> <span>Verifier</span>. <em>Proceedings of the 31st <span>IEEE</span>/<span>ACM</span> <span>International</span> <span>Conference</span> on <span>Automated</span> <span>Software</span> <span>Engineering</span></em> (New York, NY, USA, 2016), 403–413.</div>
</div>
<div id="ref-hentschel_integrating_2016" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[22] </div><div class="csl-right-inline">Hentschel, M. 2016. <em>Integrating <span>Symbolic</span> <span>Execution</span>, <span>Debugging</span> and <span>Verification</span></em>. Technische Universität Darmstadt.</div>
</div>
<div id="ref-hentschel_interactive_2016" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[23] </div><div class="csl-right-inline">Hentschel, M. et al. 2016. The <span>Interactive</span> <span>Verification</span> <span>Debugger</span>: <span>Effective</span> <span>Understanding</span> of <span>Interactive</span> <span>Proof</span> <span>Attempts</span>. <em>Proceedings of the 31st <span>IEEE</span>/<span>ACM</span> <span>International</span> <span>Conference</span> on <span>Automated</span> <span>Software</span> <span>Engineering</span></em> (New York, NY, USA, 2016), 846–851.</div>
</div>
<div id="ref-hunter_agent-based_2005" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[24] </div><div class="csl-right-inline">Hunter, C. et al. 2005. Agent-<span>Based</span> <span>Distributed</span> <span>Software</span> <span>Verification</span>. <em>Proceedings of the <span>Twenty</span>-<span>Eighth</span> <span>Australasian</span> <span>Conference</span> on <span>Computer</span> <span>Science</span> - <span>Volume</span> 38</em> (AUS, 2005), 159–164.</div>
</div>
<div id="ref-kadoda_cognitive_2000" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[25] </div><div class="csl-right-inline">Kadoda, G. 2000. <em>A <span>Cognitive</span> <span>Dimensions</span> view of the differences between designers and users of theorem proving assistants</em>.</div>
</div>
<div id="ref-kadoda_desirable_1999" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[26] </div><div class="csl-right-inline">Kadoda, G.F. et al. 1999. Desirable features of educational theorem provers - a cognitive dimensions viewpoint. <em><span>PPIG</span></em> (1999).</div>
</div>
<div id="ref-kawabata_traf_2018" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[27] </div><div class="csl-right-inline">Kawabata, H. et al. 2018. Traf: <span>A</span> <span>Graphical</span> <span>Proof</span> <span>Tree</span> <span>Viewer</span> <span>Cooperating</span> with <span>Coq</span> <span>Through</span> <span>Proof</span> <span>General</span>. <em>Programming <span>Languages</span> and <span>Systems</span></em> (Cham, 2018), 157–165.</div>
</div>
<div id="ref-klein_sel4_2009" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[28] </div><div class="csl-right-inline">Klein, G. et al. 2009. <span>SeL4</span>: <span>Formal</span> <span>Verification</span> of an <span>OS</span> <span>Kernel</span>. <em>Proceedings of the <span>ACM</span> <span>SIGOPS</span> 22nd <span>Symposium</span> on <span>Operating</span> <span>Systems</span> <span>Principles</span></em> (New York, NY, USA, 2009), 207–220.</div>
</div>
<div id="ref-leroy_formal_2009" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[29] </div><div class="csl-right-inline">Leroy, X. 2009. Formal verification of a realistic compiler. <em>Communications of the ACM</em>. 52, 7 (2009), 107–115.</div>
</div>
<div id="ref-lin_understanding_2016" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[30] </div><div class="csl-right-inline">Lin, Y. et al. 2016. Understanding and maintaining tactics graphically <span>OR</span> how we are learning that a diagram can be worth more than <span>10K</span> <span>LoC</span>. <em>Journal of Formalized Reasoning</em>. 9, 2 (Dec. 2016), 69–130. DOI:https://doi.org/<a href="https://doi.org/10.6092/issn.1972-5787/6298">10.6092/issn.1972-5787/6298</a>.</div>
</div>
<div id="ref-mitsch_keymaera_2017" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[31] </div><div class="csl-right-inline">Mitsch, S. and Platzer, A. 2017. The <span>KeYmaera</span> <span>X</span> <span>Proof</span> <span>IDE</span> - <span>Concepts</span> on <span>Usability</span> in <span>Hybrid</span> <span>Systems</span> <span>Theorem</span> <span>Proving</span>. <em>Electronic Proceedings in Theoretical Computer Science</em>. 240, (Jan. 2017), 67–81. DOI:https://doi.org/<a href="https://doi.org/10.4204/eptcs.240.5">10.4204/eptcs.240.5</a>.</div>
</div>
<div id="ref-nagashima_pamper_2018" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[32] </div><div class="csl-right-inline">Nagashima, Y. and He, Y. 2018. <span>PaMpeR</span>: <span>Proof</span> <span>Method</span> <span>Recommendation</span> <span>System</span> for <span>Isabelle</span>/<span>HOL</span>. <em>Proceedings of the 33rd <span>ACM</span>/<span>IEEE</span> <span>International</span> <span>Conference</span> on <span>Automated</span> <span>Software</span> <span>Engineering</span></em> (New York, NY, USA, 2018), 362–372.</div>
</div>
<div id="ref-nawaz_survey_2019" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[33] </div><div class="csl-right-inline">Nawaz, M.S. et al. 2019. A <span>Survey</span> on <span>Theorem</span> <span>Provers</span> in <span>Formal</span> <span>Methods</span>. (2019).</div>
</div>
<div id="ref-ringer_replica_2020" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[34] </div><div class="csl-right-inline">Ringer, T. et al. 2020. <span>REPLica</span>: <span>REPL</span> <span>Instrumentation</span> for <span>Coq</span> <span>Analysis</span>. <em>Proceedings of the 9th <span>ACM</span> <span>SIGPLAN</span> <span>International</span> <span>Conference</span> on <span>Certified</span> <span>Programs</span> and <span>Proofs</span></em> (New York, NY, USA, 2020), 99–113.</div>
</div>
<div id="ref-roe_coqpie_2016" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[35] </div><div class="csl-right-inline">Roe, K. and Smith, S. 2016. <span>CoqPIE</span>: <span>An</span> <span>IDE</span> <span>Aimed</span> at <span>Improving</span> <span>Proof</span> <span>Development</span> <span>Productivity</span>. <em>Interactive <span>Theorem</span> <span>Proving</span></em> (Cham, 2016), 491–499.</div>
</div>
<div id="ref-shams_accessible_2018" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[36] </div><div class="csl-right-inline">Shams, Z. et al. 2018. Accessible <span>Reasoning</span> with <span>Diagrams</span>: <span>From</span> <span>Cognition</span> to <span>Automation</span>. <em>Diagrammatic <span>Representation</span> and <span>Inference</span></em> (Cham, 2018), 247–263.</div>
</div>
<div id="ref-spichkova_human-centred_2017" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[37] </div><div class="csl-right-inline">Spichkova, M. and Simic, M. 2017. Human-centred analysis of the dependencies within sets of proofs. <em>Knowledge-Based and Intelligent Information &amp; Engineering Systems: Proceedings of the 21st International Conference, KES-20176-8 September 2017, Marseille, France</em>. 112, (Jan. 2017), 2290–2298. DOI:https://doi.org/<a href="https://doi.org/10.1016/j.procs.2017.08.256">10.1016/j.procs.2017.08.256</a>.</div>
</div>
<div id="ref-tassi_interactive_2008" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[38] </div><div class="csl-right-inline">Tassi, E. 2008. <em>Interactive theorem provers: Issues faced as a user and tackled as a developer</em>. alma.</div>
</div>
<div id="ref-wenzel_asynchronous_2014" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[39] </div><div class="csl-right-inline">Wenzel, M. 2014. Asynchronous <span>User</span> <span>Interaction</span> and <span>Tool</span> <span>Integration</span> in <span>Isabelle</span>/<span>PIDE</span>. <em>Interactive <span>Theorem</span> <span>Proving</span></em> (Cham, 2014), 515–530.</div>
</div>
<div id="ref-wenzel_isabelle_2011" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[40] </div><div class="csl-right-inline">Wenzel, M. 2011. Isabelle as <span>Document</span>-<span>Oriented</span> <span>Proof</span> <span>Assistant</span>. <em>Intelligent <span>Computer</span> <span>Mathematics</span></em> (Berlin, Heidelberg, 2011), 244–259.</div>
</div>
<div id="ref-wenzel_structured_2006" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[41] </div><div class="csl-right-inline">Wenzel, M. 2006. Structured <span>Induction</span> <span>Proofs</span> in <span>Isabelle</span>/<span>Isar</span>. <em>Mathematical <span>Knowledge</span> <span>Management</span></em> (Berlin, Heidelberg, 2006), 17–30.</div>
</div>
<div id="ref-zacchiroli_user_2007" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[42] </div><div class="csl-right-inline">Zacchiroli, S. 2007. <em>User interaction widgets for interactive theorem proving</em>. alma.</div>
</div>
</div>
</body>
</html>
