<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Sam Nolan" />
  <title>A definitive reference on the usability of Interactive Theorem Provers</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">A definitive reference on the usability of Interactive Theorem Provers</h1>
<p class="author">Sam Nolan</p>
</header>
<div class="titlepage">
<div class="center">
<p><img src="Images/rmit-logo.png" style="width:5cm" /></p>
<p>A thesis submitted in fulfilment of the requirements for the degree of Bachelor of Science.<br />
School of Science.<br />
College of Science, Engineering and Health.<br />
RMIT University.<br />
July 2021<br />
</p>
</div>
</div>
<div>
<p>This thesis is also in <a href="index.pdf">PDF form</a></p>
</div>
<h1 class="unnumbered" id="declaration">Declaration</h1>
<p>I certify that except where due acknowledgement has been made, the work is that of the author alone; the work has not been submitted previously, in whole or in part, to qualify for any other academic award; the content of the thesis is the result of work which has been carried out since the official commencement date of the approved research program; any editorial work, paid or unpaid, carried out by a third party is acknowledged; and, ethics procedures and guidelines have been followed.<br />
Signed: Sam Nolan<br />
Date: 08/08/2020<br />
</p>
<h1 class="unnumbered" id="acknowledgments">Acknowledgments</h1>
<p>I would like to acknowledge my supervisor <a href="https://www.spichkova.com/">Maria Spichkova</a> for her guidance and high expectations for this project. I would also like to thank <a href="https://fsalim.github.io/">Flora Salim</a> for inspiring me to further invest myself into research and never stopping in opening doors for me.</p>
<h1 class="unnumbered" id="abstract">Abstract</h1>
<h1 id="introduction">Introduction</h1>
<p>When building software systems, one of, if not the most important aspect is determining the correctness of the software built. Software is correct if, given some specification, the software implements that specification.</p>
<p>For some systems, being correct is more important than others. Being correct may not be as important in an application managing tasks in comparison to the software running in safety-critical systems such as pacemakers, the internal components of cars or software that runs on space equipment. If these systems fail, it could mean the loss of a substantial amount of money or serious injury or death. As of such, more effort should be put into ensuring that safety-critical systems are correct.</p>
<!-- I would love to add a discussion here about non-safety critical systems. -->
<p>There is a variety of methods that are valuable in ensuring software correctness, and one the most powerful methods of doing so is through the use of <a href="https://en.wikipedia.org/wiki/Formal_methods"><strong>Formal Methods</strong></a>. Formal Methods is using methods from mathematics to prove properties of correctness of software and hardware systems. <!-- Needs discussion of other methods --></p>
<p>Formal Methods can include writing down a specification for your software, and proving by hand that the software that you built (or a section of the software) correctly implements that specification. This type of work is invaluable not only to check the correctness of software, but also help the developer to understand the software that they just built. <!-- I would love an example of this given to the reader as an exercice --></p>
<p>Computers have also been used to prove correctness properties of systems. Two main types of formal methods exist in this category. <strong>Model Checkers</strong> and <strong>Theorem Provers</strong>.</p>
<p><strong>Model Checkers</strong> allow specifying your system as a state machine, and can automatically prove that your code matches this specification. Model Checkers are therefore limited in scope, as a state machine is often not complicated enough to represent arbitrary computer programs. Model checkers are however used in industry to verify properties of software systems, such an ensuring that an asynchronous system will never deadlock. Examples of model checkers include SPIN and Alloy. Model checkers often vary in their scope. <!-- I need more examples of SPIN and Alloy, what they are used for etc --></p>
<p>Theorem provers can be, as the name suggests, help prove theorems about your code in the same way that someone with a pen and paper would. Because computer programs can be represented as logic, (such as Logic of Computable Functions or Calculus of Constructions). There is actually a duality with mathematics and programming that allows theorem provers to not only verify the correctness of computer systems but prove real math theorems, and they have been used with success in both categories. <!-- Examples needed --></p>
<p>Although the distinction is not completely clear cut, theorem provers fall into two large main categories. Those categories are <strong>Automated Theorem Provers</strong>, and <strong>Interactive Theorem Provers</strong>. <!-- Diagram? --></p>
<p>Automatic Theorem Provers attempt to take a specification and a computer program and prove that the program meets the specification without user input. This is fantastic if it works, but sadly verifying software is an undecidable problem, and Automatic Theorem Provers do not always succeed in finding a proof or disproof for whether the code meets its specification.</p>
<p>Interactive Theorem Provers allow the user to interactively prove that a specification is satisfied by a computer program. This is akin to the user writing a proof for correctness on pen and paper, except that the program only allows the user to input a correct proof. With the guidance of humans, Interactive Theorem Provers allow the verification of very large scale projects. Developments in mathematics have been done in theorem provers as well.</p>
<p>Interactive Theorem Provers (ITPs) provide a unique challenge as they require interacting with the user. The user and the ITP have to work together to attempt to verify the software. When a user is involved, usability must be considered.</p>
<p>ITPs offer an opportunity to verify large scale software and hardware systems for correctness, and as software systems only get larger, ITPs could be a solution to ensuring quality and correctness of software that’s produced.</p>
<p>ITPs have already been used to verify crytographic libraries, compilers and microkernels. <!-- Examples? --></p>
<p>However, although ITPs have been used in several large scale projects, use of ITPs is far from commonplace. This thesis is a diagnostic attempt at discovering reasons for the lack of uptake, in order to decipher how we can encourage the usage of ITPs and ensure more correct software in industry.</p>
<p>In this thesis, we investigate the usability of ITPs. Usability is often quite a vague concept, but in this thesis we define it widely. We define usability as: “The ease for which a program can be used for it’s intended purpose,” which therefore can include things like the scope of features currently supported by the theorem prover.</p>
<p>We attempt to answer this question by in a sense “cross polinating” ITP ideas, comparing theroem provers up against each other across many different dimensions in order to decipher promising directions for the improvements of ITPS.</p>
<p>The research questions for this thesis are:</p>
<p>RQ1 <em>What usability issues and solutions have been mentioned in literature regarding ITPs?</em></p>
<p>RQ2 <em>Do these usability issues and solutions still exist in the ITPs?</em></p>
<p>RQ3 <em>Can problems/solutions that have been found in some ITPs be relevant for others?</em></p>
<h2 id="use-of-itps">Use of ITPs</h2>
<p>ITPs are very interesting pieces of software</p>
<p>A full review of ITPs in Formal Methods was conducted by Nawaz <span class="citation" data-cites="nawaz_survey_2019">(Nawaz et al. 2019)</span>.</p>
<p>It should be noted that although ITPs can verify the correctness of software, they also can prove more mainstream mathematical theorems. As of such, there are two communities of users of ITPs. Those interested in using ITPs to study mathematics, and those interested in using ITPs to formally verify software.</p>
<p>ITPs have been used to achieve many ends within mathematics, giving a proof for the Four Colour Theorem with Coq. Flyspeck project,</p>
<p>In terms of computing, a fully verified microkernel was developed in Isabelle/HOL named SeL4, a formalization of the Java Programming Language. A list of Isabelle projects can be found here: https://isabelle.in.tum.de/community/Projects. Coq has also been used to make Compcert, a fully verified C compier.</p>
<p>For hardware, HP used Isabelle/HOL on the HP 9000 line of of server’s Runway Bus.</p>
<h1 id="background">Background</h1>
<h2 id="formal-methods">Formal Methods</h2>
<p>There are several ways one can formally specify and verify the properties of a software system. These methods are called <strong>Formal Methods</strong>. An overview of the hierarchy of formal methods is shown in figure <a href="#fig:formal_methods" data-reference-type="ref" data-reference="fig:formal_methods">[fig:formal_methods]</a>.</p>
<p>First of all, Formal methods can be concerned with specification or verification. Specification is putting requirements of a software system into a formal representation. Specification Languages include Z <span class="citation" data-cites="potter_introduction_1992">(Potter, Sinclair, and Till 1992)</span> or VDM <span class="citation" data-cites="jones_systematic_1990">(Jones 1990)</span>. Specification is an important process and is required for verification. A specification is considered "valid" if it correctly describes the required behaviour of the system. If the specification is not valid, then proving that the code follows that specification will not produce correct software.</p>
<p>Verification is ensuring that the implementation correctly follows the specification. Verification can be done with Model Checkers, Automated Theorem Provers and Interactive Theorem Provers. These three techniques are a trade off in two dimensions: user interaction and scope.</p>
<p>Model Checkers and Automated Theorem Provers generally do not require user interaction and attempt to verify that a specification holds for a system automatically. These two techniques however cannot be used to solve all problems. ITPs can be used to prove that a specification is correctly implemented, but requires user interaction to guide the proof process.</p>
<p>The distinction between ATPs and ITPs is however not clear cut. ATPs can often include minor user interaction in order to correct it’s path and find a proof. ITPs often have automatic features and can even call external ATPs to discharge proof obligations.</p>
<div class="center">

</div>
<h2 id="interactive-theorem-provers">Interactive Theorem Provers</h2>
<p>ITPs all have the goal of helping the user prove mathematical theorems.</p>
<p>There are several types of ITPs <span class="citation" data-cites="aitken_interactive_1998">(J. S. Aitken et al. 1998)</span>, which correspond to different paradigms for proving propositions. "Proof as Programming" refers to writing a script, not unlike a computer program, that when run completes the proof. "Proof as Structure Editing" refers to directly editing proof obligations until you can discharge them, like interacting with a tree.</p>
<p>Although there are many ITPs that acheive proof in different ways, there are general themes among these ITPs that are important to understand before moving forward.</p>
<h2 id="cognitive-dimensions-of-notation">Cognitive Dimensions of Notation</h2>
<p>Cognitive Dimensions of Notation is a framework used to evaluate the effectiveness of notations <span class="citation" data-cites="green_usability_1996">(Green and Petre 1996)</span>, that is, ways of writing down information. The notation was originally proposed by Green as a way of discussing the design tradeoffs of visual programming languages, but has been applied elsewhere for a variety of notations. These dimensions are not an evaluation framework for notations, as often increasing one dimension will also change other dimensions, and different tasks may require different dimensions. For instance, in textual ITPs, dependencies are not shown between theorems, and doing so would increase the Diffuseness of the notation, allowing less to be shown and understood on a single screen. However, debugging why some theorem might fail given a change in other theorems would aid from a more diffuse representation showing the hidden dependencies.</p>
<p>Cognitive Dimensions focus mainly on the way that users understand and work with the meaning of the program. Cognitive Dimensions make an important distinction between difficulties of understanding and working with the notation vs difficulties with the actual problem itself. Because proving theorems is a very cognitively demanding task, that no matter how perfect the notation will always have an inherit difficulties. We can only try and improve the notations rather than making the actual problems easier.</p>
<p>The notation has been adopted as a way of evaluating the usability of ITPs in Kadoda PhD Thesis <span class="citation" data-cites="kadoda_desirable_1999">(G. F. Kadoda, Stone, and Diaper 1999)</span>. The interpretation of Cognitive Dimensions in regards to ITPs has been inspired by their work, but has some notable differences.</p>
<p>The Cognitive Dimensions of Notation are:</p>
<h4 id="abstraction-gradient">Abstraction Gradient</h4>
<p>Does the ITP offer ways of abstracting components? Abstraction here refers to methods, classes and encapsulation. Green classifies notations as either being abstraction-hating, abstraction-tolerant or abstraction-hungry. An abstraction-hating ITP would be one that forces you to work with low level constructs often. An abstraction-tolerant ITP would be one that gives some methods for abstraction, but still nevetheless requires constant low level interaction. An abstraction-hungry ITP would offer many methods of abstraction, that could even in the end obscure what is actually happening behind the scenes.</p>
<h4 id="closeness-of-mapping">Closeness of Mapping</h4>
<p>Closeness of Mapping is how similar the notation is to the problem domain. At some point, a representation of the problem has to be put into notation suitable for the ITP. The easier this is to do the better the closeness of mapping, or how close the proof state is represented vs what the user would expect.</p>
<h4 id="consistency">Consistency</h4>
<p>Once you know the basics of an ITP, how much of the rest can be inferred? A notation that is not consistent would require constant lookup of features in the theorem prover. Consistency is particularly important for learning ITPs. Consistency can become an issue when there are a large amount of abstractions.</p>
<h4 id="error-proneness">Error-Proneness</h4>
<p>Is it easy to make careless mistakes? A common "careless mistake" in theorem provers is trying to apply a tactic in a textual theorem prover that is not valid for the current proof state.</p>
<h4 id="diffuseness">Diffuseness</h4>
<p>How much does it represent a proof relative to the complexity of the proposition proven? This is an easier cognitive dimension to measure, and represents the verbosity of the notation. ITPs with high diffuseness often have lower abstractions and are easier to understand, but more difficult to change.</p>
<h4 id="hard-mental-operations">Hard Mental Operations</h4>
<p>Are there parts of the notation that require getting out a pencil and paper to understand what it means? The domain of ITPs by it’s very nature requires Hard Mental Operations, so it’s important to separate the inherit difficulty vs difficulty created by the notation. Hard Mental Operations may arise out of particularly complicated tactics, especially since tactics can be composed together. An ITP with a consistent set of tactics would reduce Hard Mental Operations.</p>
<h4 id="hidden-dependencies">Hidden Dependencies</h4>
<p>Are there dependencies in the notation that are not presented? In ITPs and programming languages, it’s usually possible to find what a function/lemma references, but is difficult to find what lemmas/functions reference the one we are working in. Furthermore, automation often uses lemmas in the context without indicating at all that it is using them. This makes the issue of hidden dependencies even more difficult. An ITP with low hidden dependencies makes these dependencies between parts of the program explicit</p>
<h4 id="perceptual-cues">Perceptual cues</h4>
<p>Does the notation force the user to make decisions before they have the information they need to make it? Especially for novice users, ITPs need to allow the user to explore different paths for proving a statement. This often represents a premature commitment as the user has to commit to a strategy before evaluating whether that strategy would work. ITPs that offer undo features and allow postponing making decisions require less premature commitment.</p>
<h4 id="premature-commitment">Premature commitment</h4>
<p>Does the notation force the user to make decisions before they have the information they need to make it? Especially for novice users, ITPs need to allow the user to explore different paths for proving a statement. This often represents a premature commitment as the user has to commit to a strategy before evaluating whether that strategy would work. ITPs that offer undo features and allow postponing making decisions require less premature commitment.</p>
<h4 id="progressive-evaluation">Progressive Evaluation</h4>
<p>Does the system give adequate feedback? Error messages, display of current proof state and ability to work with incomplete proofs are all features of progressive evaluation. Getting feedback from the system is absolutely essential for learning the ITPs.</p>
<h4 id="role-expressiveness">Role Expressiveness</h4>
<p>Is it easy to identify what the purpose of a component is? Lack of role expressiveness, particularly within the proofs of textual ITPs, was one of the main motivations of this study. It is often very difficult on retrospect to identify how the components of a proof relate to each other. An ITP with high Role Expressiveness would make it clear how a lemma or component of a proof contributes to the proof.</p>
<h4 id="secondary-notation">Secondary Notation</h4>
<p>Are there avenues for comments, colours and representation of the code that helps with comprehension? A Secondary Notation is a way of representing understanding by not changing the actual meaning of the notation. ITPs that offer comments, colours and whitespace grouping help with representing secondary notation.</p>
<h4 id="viscosity">Viscosity</h4>
<p>Is it easy to make a change in the system? ITPs with low abstraction make it difficult to make changes. Sometimes a small difference to what you are wanting to prove requires a disproportionate change of the proof. ITPs with high viscosity make it difficult to change.</p>
<h4 id="visibility-and-juxtaposability">Visibility and Juxtaposability</h4>
<p>How easy is to get a particular piece of desired information? How easy is it to compare part of your proof with proofs elsewhere? Sometimes critical information is difficult to obtain when creating or understanding a proof state. A common example is being able to inspect intermediate proof steps. When a proof relies heavily on automation, it is sometimes difficult to understand how the automated tactic managed to get in a particular proof state. Having this information helps understand the proof and how to move forward. ITPs with low visibility make it difficult to find such information.</p>
<p>Juxtaposability is showing two parts of the system side by side. This is important as often a proof might only be a refinement of a previous proof, and might need to be understood in context.</p>
<h1 id="itp-literature-review-methodology">ITP Literature Review Methodology</h1>
<p>To answer RQ1, a Systematic Literature review was performed.</p>
<p>A preliminary literature review was done in order to survey what usability problems occured about theorem provers. This preliminary review came from a search for “usability interactive theorem provers" on the ACM digital library and Google Scholar. The review found several papers on the topic. We then attempted to construct a query that would match these papers and also other papers in the field.</p>
<p>Papers were searched for having the title matching the following query: <code>("Interactive" OR "Deductive") AND ("prover" OR "provers" OR "proving" OR "verifier") AND ("usability" OR "user" OR "users")</code></p>
<p>The justification for using quotes around prover, provers and proving is that some search engines will return papers with the text "prove" when looking for "prover". "prove" therefore comes up with many more records that are unrelated to our topic. "Usability" is also quoted to prevent searching for "use", which clearly would bring in papers that are unrelated.</p>
<p>We searched the following databases using this query string:</p>
<ul>
<li>Scopus</li>
<li>DBLP</li>
<li>Springer Link</li>
<li>Science Direct</li>
<li>ACM</li>
<li>IEEE Xplore</li>
</ul>
<p>From the papers discovered in this way, we went through the abstracts and discerned whether the paper was relevant to the research question.</p>
<p>Our inclusion criteria for the papers included in the systematic literature review was the following:</p>
<ul>
<li>A peer review published paper AND</li>
<li>Notes particular usability issues with theorem provers OR</li>
<li>Offers direct recommendations to the improvement of the usability of interactive theorem provers</li>
</ul>
<p>We particularly excluded papers written in languages other than English, workshops, tutorials, extended abstracts, unpublished and non peer reviewed papers.</p>
<p>From the papers that were deemed relevant to the research question, we found papers that cited the papers discovered. That is, we applied forward snowballing. Semantic scholar was used to perform the forward snowballing.</p>
<p>We then tried to discover whether these papers were relevant to the research question, and repeated the process of forward snowballing until there were no more papers discovered.</p>
<p>We then read the paper to discover:</p>
<ul>
<li>A problem and/or solution to usability of interactive theorem provers</li>
<li>Which theorem prover the issue is relevant to</li>
<li>Evidence behind issues and proposed solutions</li>
</ul>
<p>The issues were then categorized by Green’s cognitive dimensions of notations <span class="citation" data-cites="green_usability_1996">(Green and Petre 1996)</span>.</p>
<h1 id="literature-review-results">Literature review results</h1>
<p>The amount of papers found in each section of the review are shown in table <a href="#tab:litresults" data-reference-type="ref" data-reference="tab:litresults">1</a>. This totals to 45 papers found on the topic. However, 1 paper had to be remove due to not being able to access it, making 44.</p>
<p>There was a surprisingly small amount of papers caught by query in comparison to snowballing. This is because many papers that discuss usability issues about ITPs do not tackle the problem directly (28/38 of the papers), but rather showcase a feature that has been coded into an ITP interface. These features do indeed solve a usability problem implicitly, and represent the bulk of the work on improving interfaces for ITPs. However, comparatively little research has been done identifying the issues with ITP interfaces and empirically comparing these user interface modifications for merit (10/38 of the papers).</p>
<div id="tab:litresults">
<table>
<caption>Literature review papers</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Round</th>
<th style="text-align: left;">Found</th>
<th style="text-align: left;">Relevant</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Query</td>
<td style="text-align: left;">45</td>
<td style="text-align: left;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;">Snowball 1</td>
<td style="text-align: left;">121</td>
<td style="text-align: left;">14</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Snowball 2</td>
<td style="text-align: left;">191</td>
<td style="text-align: left;">5</td>
</tr>
<tr class="even">
<td style="text-align: left;">Snowball 3</td>
<td style="text-align: left;">99</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Snowball 4</td>
<td style="text-align: left;">44</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Snowball 5</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
</div>
<p><span id="tab:litresults" label="tab:litresults">[tab:litresults]</span></p>
<p>When going through papers, it was interesting to find a large amount of papers proposing user interface models, but not actually identifying the problems that they solve, nor evaluating their effectiveness. In fact, out of the 28 papers that showcased user interface improvements, only 2 papers evaluated the their interface improvement to without the improvement <span class="citation" data-cites="hentschel_empirical_2016 berman_development_2014">(Hentschel, Hähnle, and Bubel 2016a; Berman 2014)</span>. That there is not enough empirical studies verifying usability issues has been cited as an issue that needs to addressed in the past <span class="citation" data-cites="hahnle_deductive_2019">(Hähnle and Huisman 2019)</span>.</p>
<p>The following sections outline usability issues and solutions to those issues. Tables are included outlining the usability issues mentioned. If the same problem is mentioned in two papers, it is given two rows.</p>
<p>The theorem prover column refers to the theorem prover the usability issue was found in. If the problem is a general comment “General" is written.”Textual" means a theorem prover that uses proof script to solve theorems, such as Isabelle/HOL, Coq, Agda. “Direct Maniuplation" means a theorem prover that uses direct manipulation to solve theorems, such as KeY.</p>
<p>The discovered column indicates the evidence that that problem exists. "Suggested" simply means that problem or solution was simply inferred or has not actually been evaluated as effective. Other values indicate the type of study that the paper used to observe or evaluate this problem or solution.</p>
<h2 id="theorem-provers">Theorem Provers</h2>
<p>First of all, a brief overview of the theorem provers is in order.</p>
<h4 id="key">KeY</h4>
<p>KeY is a Direct Manipulation theorem prover, meaning that unlike Textual theorem provers, does not prove theorems by writing proof scripts, but instead works by modifying a proof object directly until all proof obligations have been solved. KeY works by annotating Java programs with preconditions and postconditions. These conditions are then fed into KeY as proof obligations. KeY can act as a fully automatic prover, but also allows the user to attempt to find a proof if the prover fails. KeY has also formed the basis of KeYmaera and KeYmaera X, which are for proving properties of hybrid systems.</p>
<h4 id="hol">HOL</h4>
<p>HOL is actually a family of theorem provers. Notably HOL4, ProofPower, HOL Light and HOL Zero. HOL is one of the oldest provers in this list, and HOL Light is known to be used as a lightweight prover, with a very easily checkable kernel. HOL provers are textual, and have a simple type system and use tactics to prove propositions.</p>
<h4 id="isabelle">Isabelle</h4>
<p>Isabelle (also known as Isabelle/HOL, but for this paper will remain as Isabelle to prevent confusion) is one of the most popular theorem provers. The prover has been used for the verification of the SeL4 prover, and exists as the state-of-the-art of ITPs. Isabelle like HOL has a simple type system and is based of the Logic for Computable Functions.</p>
<h4 id="coq">Coq</h4>
<p>Coq is another popular ITP that also supports a dependent type system. It’s based on the Calculus of (Co)Inductive Constructions, which was designed specifically for Coq. Coq has been used to prove the four colour theorem, and create the Compcert certified C compiler.</p>
<h4 id="matita">Matita</h4>
<p>Matita is a theorem prover based on Coq’s Calculus of (Co)Inductive Constructions, and was designed to address many of the pain points in working with Coq. Matita is a much simpler prover that aims to present the theorem prover as editing a mathematical library. As of such, Matita’s solutions to problems are often pain points in Coq (mathematical notation, Tinycals etc).</p>
<p>There are a few other provers also in this review, such as iCon, CardiZ and Dafny. These ITPs are often either coded as proofs of concepts (such as iCon), or are no longer maintained (in the case of CardiZ or Dafny). The problems raised by them however, are often relevant for current day ITPs.</p>
<p>This is by no means a complete list of modern ITPs. Such compilations have been done <span class="citation" data-cites="nawaz_survey_2019">(Nawaz et al. 2019)</span>. These are only the ITPs discussed in the papers found in the review. There are notable ITPs that are missing from this list that caught us by surprise, including Agda, Lean and Mizar.</p>
<h2 id="interaction-paradigms">Interaction Paradigms</h2>
<p>Before moving into the actual problems and solutions found in ITPs, it’s worth giving a short history of the interaction paradigms of ITPs, and possible developments.</p>
<p>Direct Manipulation ITPs such as KeY work by editing proof objects until the obligations have been resolved. These provers often have issues with tedious interactions, and work has even been done add textual elements to KeY <span class="citation" data-cites="beckert_interaction_2017">(Beckert, Grebing, and Ulbrich 2017)</span>. The development of interfaces to Direct Manipulation provers often differs from textual ones.</p>
<p>Textual ITPs such as HOL, Isabelle, Coq and Matita work by writing a proof script that attempts to prove a proposition. Interacting with textual ITPs often involves a very simple read-evaluate-print-loop (REPL) for their interfaces. One very stark example of this is HOL-Light, which you interact with by opening up the OCaml REPL (a general purpose ML based functional programming language) and loading the HOL library. All Ocaml is available to you alongside the HOL library. Although this is rather primitive, modern ITP interfaces such as Isabelle/jEdit and CoqIDE usually offer only a small layer of abstraction over a REPL for their own languages.</p>
<p>These interfaces have two main windows, the first has code and the second has proof state. The code can be evaluated up to a certain point, and the output from the REPL in terms of proof state are printed in the second window. The only major difference between this and a standard REPL is that you can rewind to evaluate up to a previous line. This simple style of interface has consequences for usability. In particular, if any error is found either in proof or in syntax, execution stops until that error is resolved. Further, for larger projects, it can take a very long time for systems to recompile. It also means that you can only identify things that have already been identified (it has to be a single pass). This is particularly an issue when automated tactics attempt to use lemmas above them to find solutions to theorems (such as Isabelle). This means that simply changing the order of lemmas in an Isabelle document, even if they never reference lemmas that are below them, could cause a lemma that was proven before to become unproven.</p>
<p>Developments in IDEs to allow asynchronous interfaces, reloading only parts needed and loading proofs out of order have been introduces to fix this problem. They are called "Prover IDEs", with two examples being Isabelle/PIDE <span class="citation" data-cites="wenzel_asynchronous_2014">(Wenzel 2014)</span> and Coq/PIDE <span class="citation" data-cites="barras_asynchronous_2015">(Barras, Tankink, and Tassi 2015)</span>. These hopefully will resolve some of the issues cited above.</p>
<p>Although we have examples of large projects undertaken with ITPs, optimal interaction paradigms are still up for debate, and several novel interaction paradigms have surfaced. Including proving theorems and writing tactics with diagrams <span class="citation" data-cites="grov_tinker_2018 lin_understanding_2016 shams_accessible_2018">(Grov and Lin 2018; Lin, Grov, and Arthan 2016; Shams et al. 2018)</span>, or providing agent based interfaces <span class="citation" data-cites="hunter_agent-based_2005">(Hunter, Robinson, and Strooper 2005)</span>.</p>
<p>We now move into the usability problems and solutions found in ITPs.</p>
<h2 id="abstraction-gradient-1">Abstraction Gradient</h2>
<table>
<caption>Abstraction Gradient Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Interaction with low level logic</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Missing Library</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
</tbody>
</table>
<p>The abstraction gradient dimension concerns itself with the highest and lowest levels of abstraction that are presented. Are they at the appropriate level of abstraction?</p>
<p>Issues in this dimension were uncommon. KeY was found to require interacting on low level logic formulas consistently. Similar issues with tedious interactions with KeY are mentioned in the viscosity’s section. No solutions were found or suggested to this problem, and it has not been empirically tested.</p>
<p>Focus Groups found that Isabelle’s library lacks the appropriate mathematical foundations. Interestingly, this is the only issue of this class and is not mentioned elsewhere, often library issues are more about managing and searching large libraries, which Matita attempts to handle, and correct documentation of libraries. This has not been tested empirically. Other than the implicit solution of providing better library support for theorem provers, no solution has been provided for this problem.</p>
<h2 id="closeness-of-mapping-1">Closeness of Mapping</h2>
<table>
<caption>Closeness of Mapping Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Unintuitive mapping between formula and program</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">CardiZ</td>
<td style="text-align: left;">Cannot sketch out proofs</td>
<td style="text-align: left;">Questionaire</td>
<td style="text-align: left;"><span class="citation" data-cites="kadoda_cognitive_2000">(G. Kadoda 2000)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot use mathematical notation</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot use mathematical notation</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="asperti_user_2007 zacchiroli_user_2007">(Asperti et al. 2007; Zacchiroli 2007)</span></td>
</tr>
</tbody>
</table>
<p>The dimension of closeness of mapping is whether the interface maps well to the problem world. For interactive theorem provers, it has to do with how well the proof state is understood in comparison to the actual problem.</p>
<p>Focus groups found that because KeY attempts to prove properties through annotations and java source code, it can sometimes be difficult to see how this proof state maps to the program <span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span>. This issue is not mentioned in any other source and not tested empirically. No solutions have been suggested for this.</p>
<p>CardiZ, an ITP that can be used to prove properties of Z specifications, found that you could not sketch out proofs before an attempt. This is the only paper on CardiZ, as CardiZ is not a popular prover. No solutions have been suggested for this.</p>
<p>A common issue that came up with Coq was the inability to use mathematical notation. Notational issues are problematic in ITPs. One one hand, thereom provers such as Isabelle and Agda allow using mathematical notation in their theorems. This helps the user understand the theorem in a terse syntax. On the other hand, mathematical notation can often be ambiguous and difficult to type. Isabelle allows using LaTeX style commands such as<br />
rightarrow to render math notation, whereas Agda allows unicode in source files. In order to avoid ambiguity, Coq has no support for math notation, and in response to this, Matita has LaTeX style mathematical notation <span class="citation" data-cites="asperti_user_2007 zacchiroli_user_2007">(Asperti et al. 2007; Zacchiroli 2007)</span>. This issue came up in three different sources.</p>
<h2 id="consistency-1">Consistency</h2>
<table>
<caption>Consistency Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Difficult to know what tactics and lemmas to use</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015 beckert_interaction_2017">(Beckert, Grebing, and Böhl 2015; Beckert, Grebing, and Ulbrich 2017)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Difficult to know what tactic to apply next</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_interactive_1998">(J. S. Aitken et al. 1998)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hard to remember prover specific details</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="nagashima_pamper_2018">(Nagashima and He 2018)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Difficult to know what tactic to apply next</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="mitsch_keymaera_2017">(Mitsch and Platzer 2017)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle,HOL</td>
<td style="text-align: left;">Difficult to remember names of theorems</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_analysis_2000">(S. Aitken and Melham 2000)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Difficult to find relevant lemmas</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Difficult to find arguments for tactics</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="ringer_replica_2020">(Ringer et al. 2020)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Bad Library, inconsistent naming</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
</tbody>
</table>
<p>Consistency is the cognitive dimension of whether, once learning part of the notation, you are able to infer the rest of the notation.</p>
<p>In textual theorem provers, it is often difficult to remember the name of the next tactic, theorems or lemmas should be applied in any situation. This has been bought up in focus groups <span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span>, observational studies <span class="citation" data-cites="aitken_analysis_2000">(S. Aitken and Melham 2000)</span>, surveys <span class="citation" data-cites="berman_development_2014">(Berman 2014)</span> and suggested as a problem from various other sources.</p>
<p>Solutions to this problem often include choosing applicable tactics by menu <span class="citation" data-cites="aitken_analysis_2000 aitken_interactive_1998">(S. Aitken and Melham 2000; J. S. Aitken et al. 1998)</span> Which has been implemented in Coq through Proof Previews <span class="citation" data-cites="berman_development_2014">(Berman 2014)</span> and in KeYmaera X <span class="citation" data-cites="mitsch_keymaera_2017">(Mitsch and Platzer 2017)</span>. Machine learning for choosing appropriate recommendations has been suggested for this problem <span class="citation" data-cites="ringer_replica_2020">(Ringer et al. 2020)</span>, and has also been implemented through the PaMpeR tool in Isabelle <span class="citation" data-cites="nagashima_pamper_2018">(Nagashima and He 2018)</span>. A second way of tackling this problem is to improve library searching, which was suggested <span class="citation" data-cites="aitken_analysis_2000">(S. Aitken and Melham 2000)</span> and is a focus in Matita <span class="citation" data-cites="tassi_interactive_2008">(Tassi 2008)</span>. Improving these tools is a promising area for improving the usability of ITPs</p>
<h2 id="diffuseness-terseness">Diffuseness / terseness</h2>
<table>
<caption>Diffuseness / terseness Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Bloated Formulas</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Large proofs correspond to large effort</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">(Bourke et al. 2012)</span></td>
</tr>
</tbody>
</table>
<p>Diffuseness is the cognitive dimension of the tersity/verbosity of the syntax. Bloated formulas were mentioned in Isabelle in Focus Groups, and projects with more lines of code were strongly correlated with more effort. No solutions have been suggested to reducing the size of code bases or formulas.</p>
<h2 id="error-proneness-1">Error Proneness</h2>
<table>
<caption>Error Proneness Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle,HOL</td>
<td style="text-align: left;">Easy to get errors in Object Level Constructions</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_analysis_2000">(S. Aitken and Melham 2000)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle,HOL</td>
<td style="text-align: left;">Incorrect predictions made about tactics</td>
<td style="text-align: left;">Observational</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_analysis_2000">(S. Aitken and Melham 2000)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Difficult to manage namespace</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">(Bourke et al. 2012)</span></td>
</tr>
</tbody>
</table>
<p>Error proneness is the cognitive dimension of whether a system allows its users to make errors.</p>
<p>Observational studies have found that in Isabelle and HOL it is easy to make errors in syntax. Considering the frequency of syntax errors, this issue came up surprisingly little other sources. This could be because syntax errors are relatively easy to fix and also decrease with usage. It’s been suggested that this problem could be solved my improving feedback in Object Level syntax input <span class="citation" data-cites="aitken_analysis_2000">(S. Aitken and Melham 2000)</span>. A more interesting solution has been implemented for Coq is a structure editor based off keyboard cards <span class="citation" data-cites="berman_development_2014">(Berman 2014)</span>. This uses rolling chords (like <em>vi</em>) keyboard interfaces to interact with the theorem prover. This means that it is only possible to enter syntactically valid statements. This current solution only works on a subset of Coq’s syntax. It was found to be slightly quicker than using dropdown menus.</p>
<p>Sometimes when applying a tactic, an unexpected result would occur, causing the user to back up and try to understand the current state. This issue could be solved by Proof Previews <span class="citation" data-cites="berman_development_2014">(Berman 2014)</span>, which allow you to see a proof state when selecting tactics from a menu without actually applying the tactic. That way the user can cheaply explore tactics to continue in the proof.</p>
<p>Finally, for large verification projects such as SeL4, there is an issue with managing the namespaces of large amounts of theorems and lemmas. No verification of this problem nor solution has been suggested.</p>
<h2 id="hard-mental-operations-1">Hard mental operations</h2>
<table>
<caption>Hard Mental Operations Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Hard to understand proof scripts statically</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="zacchiroli_user_2007">(Zacchiroli 2007)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Difficult to understand tacticals</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="grov_tinker_2018 lin_understanding_2016">(Grov and Lin 2018; Lin, Grov, and Arthan 2016)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Proof scripts can become complicated</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aspinall_towards_2016">(Aspinall and Kaliszyk 2016)</span></td>
</tr>
</tbody>
</table>
<p>The dimension of Hard Mental operations refer to the difficulty in understanding and using the interface on a syntax level. This type of issue is common with ITPs, as the actual domain is complicated, so this is reflected with difficult syntax.</p>
<p>Proofs are hard enough to understand while viewing the dynamic nature of the proof, investigating proof state bit by bit. They are often near impossible to understand statically <span class="citation" data-cites="zacchiroli_user_2007">(Zacchiroli 2007)</span>. This issue has not been investigated empirically, but solutions often involve changing the syntax around proofs. One notable example of this is Isar for Isabelle <span class="citation" data-cites="wenzel_structured_2006">(Wenzel 2006)</span>, which attempts to mirror how a pen and paper proof is structured.</p>
<p>It is often difficult to understand tacticals, and the problem is made even worse when it is not possible to view the state of a tactical mid way through interaction. This problem has been suggested in several sources <span class="citation" data-cites="grov_tinker_2018 lin_understanding_2016 zacchiroli_user_2007">(Grov and Lin 2018; Lin, Grov, and Arthan 2016; Zacchiroli 2007)</span> but never empirically investigated. Solutions to this include representing tacticals as graphs <span class="citation" data-cites="grov_tinker_2018 lin_understanding_2016">(Grov and Lin 2018; Lin, Grov, and Arthan 2016)</span>. This solution has not been tested with users.</p>
<p>Proof scripts can also get very complicated for larger propositions. Keeping track of this complexity has been suggested with proof metrics, which are similar to classic code complexity metrics <span class="citation" data-cites="aspinall_towards_2016">(Aspinall and Kaliszyk 2016)</span>.</p>
<h2 id="hidden-dependencies-1">Hidden dependencies</h2>
<table>
<caption>Hidden Dependencies Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hard to see dependencies between proofs</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="spichkova_human-centred_2017">(Spichkova and Simic 2017)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Difficult to patch proofs that have slightly changed</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">(Beckert and Grebing 2012)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hidden automation dependencies</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">(Bourke et al. 2012)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Difficult to patch proofs when dependencies change</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">(Bourke et al. 2012)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hard to see dependencies between proofs</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aspinall_towards_2016">(Aspinall and Kaliszyk 2016)</span></td>
</tr>
</tbody>
</table>
<p>Hidden dependencies represent dependencies between components that are not shown explicitly. Hidden dependencies are everywhere in theorem provers. Like functions in many programming languages, lemmas can reference the lemmas that they use, but it is difficult to find where a particular lemma has been used. Automation makes this problem even worse, where in Isabelle, an automatic tactic will try lemmas that are above it in the theory. This makes moving lemmas around a theory document difficult. Moving a lemma around a document, even if all the other lemmas it is references are above it, may cause it to fail due to it using a lemma by automation. Monitoring dependencies has been suggested as part of formal proof metrics. It’s been suggested and implemented within CoqPIE to show these dependencies within the IDE <span class="citation" data-cites="roe_coqpie_2016">(Roe and Smith 2016)</span>. Tools have also been built to analyse dependencies between Isabelle proofs <span class="citation" data-cites="spichkova_human-centred_2017">(Spichkova and Simic 2017)</span>. For automated tactics, Isabelle’s sledgehammer offers a unique solution to showing dependencies. The automatic tactic, after execution, simply prints a set of manual tactics that were used to prove the theorem into the document. That way, all the lemmas that were used in the automated tactic are made explicit <span class="citation" data-cites="bourke_challenges_2012">(Bourke et al. 2012)</span>. None of these solutions have been empirically tested for validity.</p>
<p>Furthermore, often changing a definition or proof slightly requires changing the proof in order to match the new definitions. This is a tedious process.</p>
<p>None of these issues have been tested empirically.</p>
<h2 id="perceptual-cues-1">Perceptual cues</h2>
<table>
<caption>Perceptual Cues Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Difficult to understand proof state</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="kadoda_cognitive_2000">(G. Kadoda 2000)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Difficult to understand proof state</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="hentschel_integrating_2016">(Hentschel 2016)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Difficult to understand proof state</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="eastaughffe_support_1998">(Eastaughffe 1998)</span></td>
</tr>
</tbody>
</table>
<p>Perceptual cues is how easy it is to understand what is being represented. Understanding proof state is an enormous part of theorem proving. The normal solutions to understanding proof state are to offer more ways of viewing it, and ensuring easy access to these views. As of such, solutions are found in the visibility section.</p>
<h2 id="premature-commitment-1">Premature Commitment</h2>
<table>
<caption>Premature Commitment Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Need to redesign model if proof attempt fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Have to apply tactics before understanding what they do</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
</tbody>
</table>
<p>When an attempt to prove a theorem fails, either one of two things has happened. First, the proof you are attempting to perform is incorrect, or the model itself is in error. The model is often in error, and as of such there is a premature commitment to a model before having a full understanding. Counterexample generators such as Quickcheck and nitpick <span class="citation" data-cites="beckert_usability_2015 beckert_interaction_2017">(Beckert, Grebing, and Böhl 2015; Beckert, Grebing, and Ulbrich 2017)</span> for Isabelle help prevent the user from trying to prove unprovable lemmas by providing the user with a counterexamples to show why their lemmas can’t be true.</p>
<p>Furthermore, tactics often need to be applied to discover what they do. Typing out this tactic is part of the exploration, and represents another premature commitment. A cheaper way to explore tactic applications were trialed with Proof previews in Coq <span class="citation" data-cites="berman_development_2014">(Berman 2014)</span>. These proof previews allowed the selection of the next tactic by menu, and hovering over a tactic previewed it’s application in a separate window. This was found to be helpful with users.</p>
<h2 id="progressive-evaluation-1">Progressive Evaluation</h2>
<table>
<caption>Progressive Evaluation Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Hard to understand why proof state fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="hentschel_interactive_2016">(Hentschel, Hähnle, and Bubel 2016b)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Hard to understand why proof state fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_interaction_2017 beckert_interactive_2015 beckert_usability_2015">(Beckert, Grebing, and Ulbrich 2017; Beckert and Grebing 2015; Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Dafny</td>
<td style="text-align: left;">Hard to understand why proof state fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="grebing_seamless_2020">(Grebing, Klamroth, and Ulbrich 2020)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Hard to understand why proof state fails</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="lin_understanding_2016">(Lin, Grov, and Arthan 2016)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Hard to understand automated tactics</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="mitsch_keymaera_2017">(Mitsch and Platzer 2017)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">e General</td>
<td style="text-align: left;">Not enough feedback hinders learning</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="mitsch_keymaera_2017">(Mitsch and Platzer 2017)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Lack of background automation</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Lack of background automation</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="hunter_agent-based_2005">(Hunter, Robinson, and Strooper 2005)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Bad feedback hinders learning</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">(Beckert and Grebing 2012)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Don’t know whether an automated tactic would prove a goal</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Non reactive interfaces</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Hard to understand errors from bad inferences of types</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Performance of automatic strategy</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle,KeY</td>
<td style="text-align: left;">Difficult to understand automated strategy</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
</tbody>
</table>
<p>Progressive evaluation is the dimension of getting appropriate feedback from the system.</p>
<p>Not understanding why proof attempts fails in a widely cited example of this. This becomes especially true when automation is added to the mix. Insight to the operation of automated tactics is missing in many ITPs. This has been suggested to be one of the largest issues with the usability of ITPs in Focus Groups <span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span>. Although there is little empirical evidence of this issue, the fact that it is so widely cited indicates importance. Solutions to this issue often resolve around providing better visibility, and are covered there.</p>
<p>Other issues include that systems with low feedback make it difficult to teach using ITPs, and that ITPs do not effectively use background processing to provide the user with feedback. One way of improving feedback is using a cache of proof state <span class="citation" data-cites="berman_development_2014 bourke_challenges_2012">(Berman 2014; Bourke et al. 2012)</span>. Another more novel way is to provide an agent based interaction model <span class="citation" data-cites="hunter_agent-based_2005">(Hunter, Robinson, and Strooper 2005)</span>, where the user interfaces have a "Personal assistant", who then negotiates with proof agents to help solve a particular proof. This makes best use of background processing while the user is trying to solve a problem. Neither of these have been tested with users.</p>
<p>Finally, it was mentioned in a survey of Coq users that it would be nice to know in advance whether an automated tactic could prove a goal. This would prevent further unnecessary work.</p>
<h2 id="secondary-notation-1">Secondary Notation</h2>
<p>Secondary notation is the realm of comments, documentation, and even use of visual placement to convey meaning. Problems due to lack of secondary notation are usually simply because of missing features, and are therefore more naturally discussed as solutions.</p>
<table>
<caption>Secondary Notation Solutions</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Intervention</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Allow notes in tree contexts</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_interactive_1998">(J. S. Aitken et al. 1998)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle,HOL</td>
<td style="text-align: left;">Allow adding notes to proof context</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">(Beckert and Grebing 2012)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Add document orientated features</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="wenzel_isabelle_2011">(Wenzel 2011)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Gravity for automated lemma placement</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">(Bourke et al. 2012)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Deprecation tags</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="bourke_challenges_2012">(Bourke et al. 2012)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Doc comments</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">HOL/CardiZ</td>
<td style="text-align: left;">Colour and low secondary notation</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="kadoda_cognitive_2000">(G. Kadoda 2000)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Lack of good tutorials and documentation</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Poor documentation</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">(Beckert and Grebing 2012)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Better libraries and documentation</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
</tbody>
</table>
<p>One improvement on secondary notations is the ability to note and label parts of proof context. Usually, proof context is boxed off and cannot be documented other than basic comments. Interestingly, although this feature is cited multiple times. It remains, to the best of my knowledge, unimplemented, and as with the rest of the solutions in this category, untested.</p>
<p>Document oriented proof organization tries to make each theory readable both to a human and to a computer, and involves allowing linking to external theories, websites, diagrams and other features all in the prover editor. This is commonly done with web interfaces controlled by ITP code. This method has not been investigated as being beneficial, but Matita itself was built to support this style of interaction.</p>
<p>Features such as deprecation tags, doc comments and automatic naming of lemmas frequently showed up. These indicate that it is important for the user to break out and write hints to help themselves and others navigate their code. These have been implemented in some provers, but again, have not been tested.</p>
<p>Finally, a very common issue with ITPs is the lack of tutorials and documentation, particularly around library functionality. This is remarkably important, regardless of what the prover is.</p>
<h2 id="viscosity-1">Viscosity</h2>
<table>
<caption>Viscosity Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Messy Downwards compatibility</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">No support for proof refactoring</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Direct Manipulation</td>
<td style="text-align: left;">Tedious Interactions</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="grebing_usability_2020 beckert_usability_2015">(Grebing and Ulbrich 2020; Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">General</td>
<td style="text-align: left;">Hard to make effective use of large library</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="asperti_considerations_2010 tassi_interactive_2008">(Asperti and Coen 2010; Tassi 2008)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Tacticals difficult to write</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="becker_lassie_2021">(Becker et al. 2021)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Have to update proofs once definition changes</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="ringer_replica_2020">(Ringer et al. 2020)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Proof renaming and refactoring is tedious</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="ringer_replica_2020">(Ringer et al. 2020)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Large proof scripts require too long to recompile</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="barras_asynchronous_2015">(Barras, Tankink, and Tassi 2015)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Isabelle</td>
<td style="text-align: left;">Large proof scripts require too long to recompile</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="wenzel_asynchronous_2014">(Wenzel 2014)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Difficult to select terms</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Unnecessary re-running of proofs</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Slow for large proofs</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="roe_coqpie_2016">(Roe and Smith 2016)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Change in lemma requires change in proof</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="roe_coqpie_2016">(Roe and Smith 2016)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Bad change management</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">(Beckert and Grebing 2012)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Bad Automated proof performance</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">(Beckert and Grebing 2012)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Hard to decompose proof</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_interactive_2015">(Beckert and Grebing 2015)</span></td>
</tr>
</tbody>
</table>
<p>Viscosity is the cognitive dimension of the ease of changing the state of the programs.</p>
<p>One source of viscosity is simply performance. As automatic strategies get more complicated, their performance becomes important for them to be useful to the user. This has been suggested by focus groups and in surveys. This becomes a particularly difficult problem especially for larger systems. Attempts to improve performance have been done by asynchronously loading only required parts of the proof in Coq <span class="citation" data-cites="barras_asynchronous_2015">(Barras, Tankink, and Tassi 2015)</span> and Isabelle <span class="citation" data-cites="wenzel_asynchronous_2014">(Wenzel 2014)</span>. Improvements to performance of automatic strategies will always be an improvement <span class="citation" data-cites="bourke_challenges_2012">(Bourke et al. 2012)</span>, including making better use of the library <span class="citation" data-cites="tassi_interactive_2008 asperti_considerations_2010">(Tassi 2008; Asperti and Coen 2010)</span>.</p>
<p>A second source is the need to make trivial interactions when making small changes. For instance, the renaming of a lemma might mean you need to go through several files to find where to change the identifier. Messy downwards compatibility, changing definitions, and lack of refactoring are all examples of this. These are usually addressed by refactoring tools that have been suggested as necessary <span class="citation" data-cites="ringer_replica_2020 bourke_challenges_2012">(Ringer et al. 2020; Bourke et al. 2012)</span> and implemented in some IDEs such as CoqPIE <span class="citation" data-cites="roe_coqpie_2016">(Roe and Smith 2016)</span>. These solutions have not been tested with users.</p>
<p>The third is simply interactions that are tedious and error prone. This is more common in direct manipulation theorem provers such as KeY. No solutions have been suggested for this problem.</p>
<p>Finally, the fourth source of viscosity is clunky syntax, such as the need to explain selections to the theorem prover. Selections are a common issue where you need to describe the part of the goal that you want to rewrite. This part might be complicated, but has to be represented textually. This has served as a challenge for ITP designers. Selections using patterns has been implemented in Matita <span class="citation" data-cites="zacchiroli_user_2007 asperti_user_2007">(Zacchiroli 2007; Asperti et al. 2007)</span> to address this pain point.</p>
<h2 id="visibility">Visibility</h2>
<table>
<caption>Visibility Problems</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Theorem prover</th>
<th style="text-align: left;">Problems</th>
<th style="text-align: left;">Discovered</th>
<th style="text-align: left;">citation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Proof tree too detailed</td>
<td style="text-align: left;">Focus Groups</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Textual</td>
<td style="text-align: left;">Limited insight to automated tactics</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="grebing_usability_2020">(Grebing and Ulbrich 2020)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Hard to understand proof tree</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_interactive_1998">(J. S. Aitken et al. 1998)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">HOL</td>
<td style="text-align: left;">Allow showing and hiding of proof contexts</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="aitken_interactive_1998">(J. S. Aitken et al. 1998)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot see intermediate proof states</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="zacchiroli_user_2007">(Zacchiroli 2007)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Difficult to see structure of proof tree</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot see the relation between subgoals</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Coq</td>
<td style="text-align: left;">Cannot quickly see type or simplification of term</td>
<td style="text-align: left;">Survey</td>
<td style="text-align: left;"><span class="citation" data-cites="berman_development_2014">(Berman 2014)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">KeY</td>
<td style="text-align: left;">Bad presentation of incomplete proofs</td>
<td style="text-align: left;">Suggested</td>
<td style="text-align: left;"><span class="citation" data-cites="beckert_evaluating_2012">(Beckert and Grebing 2012)</span></td>
</tr>
</tbody>
</table>
<p>Visibility was a commonly cited issue with interactive theorem provers.</p>
<p>The cognitive dimension of visibility has to do with being able to how information can be identified and accessible to the user. For the case of interactive theorem provers, there were cases where theorem provers show too much or too little information.</p>
<p>Direct manipulation theorem provers such as KeY were found to show too much information in the proof tree, which overwhelms the user trying to work out why a proof attempt has failed. The simplest solution to this is to only show information needed <span class="citation" data-cites="eastaughffe_support_1998">(Eastaughffe 1998)</span> and allow the opening and closing of views <span class="citation" data-cites="aitken_interactive_1998">(J. S. Aitken et al. 1998)</span>. However, some IDEs (such as CoqIDE) come without a proof tree. These have been considered helpful <span class="citation" data-cites="berman_development_2014 aitken_interactive_1998">(Berman 2014; J. S. Aitken et al. 1998)</span> and have been implemented with Traf <span class="citation" data-cites="kawabata_traf_2018">(Kawabata et al. 2018)</span></p>
<p>In contrast, it’s also been claimed that there is a lack of visibility of the proof state, particularly intermediate proof states within textual theorem provers. The lack of visibility is often to do with intermediate proof states. An intermediate proof state is the state that a proof is in before the full completion of a tactic, and can be used to determine how a tactic got to a particular proof state. Understanding these intermediate proof states is important in understanding the process of automatic theorem provers and the current state. Viewing intermediate proof states is not possible with Isabelle/HOL or Coq. In fact, it is not even possible to investigate the inside of tacticals making it even more difficult to understand intuitively a proof. The tactical problem has been resolved by only using a subset of tacticals with Matita’s Tinycals <span class="citation" data-cites="asperti_user_2007 zacchiroli_user_2007">(Asperti et al. 2007; Zacchiroli 2007)</span>. KeYmaera X also offers tracability with automatic tactics, allowing insight to the operations they performed <span class="citation" data-cites="mitsch_keymaera_2017">(Mitsch and Platzer 2017)</span>.</p>
<p>In one of the only empirical tests of two different user interfaces, an interface akin to a symbolic debugger is compared against the standard interface of KeY <span class="citation" data-cites="hentschel_integrating_2016 hentschel_empirical_2016 hentschel_interactive_2016">(Hentschel 2016; Hentschel, Hähnle, and Bubel 2016a, 2016b)</span>. The symbol debugger was found to be easier to use. The interfaces are very different, and it could be for a variety of reasons. One such reason is that the interface of a symbolic debugger maps better onto the context of source code, and offers visibility of that connection. Offering different ways of viewing and interacting with proof state has been suggested as a way forward in the usability of ITPs <span class="citation" data-cites="eastaughffe_support_1998 grebing_seamless_2020">(Eastaughffe 1998; Grebing, Klamroth, and Ulbrich 2020)</span>.</p>
<p>Diagramic representations of proof is an alternative way of proving theorems, as demonstrated with iCon <span class="citation" data-cites="shams_accessible_2018">(Shams et al. 2018)</span> and Proof Transitions in CoqEdit <span class="citation" data-cites="berman_development_2014">(Berman 2014)</span>. This has not been tested empirically against other ITPs</p>
<h2 id="final-analysis">Final Analysis</h2>
<p>There are surprisingly little papers offering empirical evidence for problems and solutions in ITPs. Table <a href="#tab:evidence" data-reference-type="ref" data-reference="tab:evidence">[tab:evidence]</a> shows all the main problems identified, and the evidence that they exist in different ITPs. This shows an enormous gap in empirical usability research. The aim of this thesis is to at least fill this table up with a simple observational study. Offering light and focus on the big issues in an otherwise very dimly lit field.</p>
<figure>
<img src="Images/MyProblem.png" alt="image" /><figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="scope-of-library">Scope of Library</h2>
<p>In a focus group, it was identified that Isabelle was missing important mathematical foundations from its library <span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span>.</p>
<p>ITPs, being very close to the language of mathematics, often make use of mathematical theory in order to prove propositions. This is especially the case when it’s use is within the field of mathematics itself in contrast to proving the correctness of software systems.</p>
<p>When using an ITP to prove theorems from mathematics, the scope of the library to work with is important. For instance, if you wished to prove a property within topology, then having topological foundations in your library available would be beneficial. However, it becomes less necessary when proving that code meets its specification. Some theorem provers such as KeY, due to it being a direct manipulation theorem prover, does not have a standard library, but still can be used to prove that software meets its specification.</p>
<p>Textual ITP come equipped with libraries that allow using concepts from these libraries. To investigate how much of an issue this was in each of the ITPs, scopes of libraries were compared. Library modules were sorted into different fields according to broad areas of mathematics. To the best of our knowledge, the comparison of scopes of ITPs libraries in this way has not been done.</p>
<p>Before diving in to the current scope of ITP libraries, we should noted that there are some different approaches to managing standard libraries that mean that the analysis could be skewed. Standard libraries of ITPs can be compared to standard libraries of programming languages, and serve similar functions. The libraries contain elements that are likely to be re-used over several programs, and as of such are compiled together for reuse. If the concept of a standard library is extended into the realm of interactive theorem provers, then a question has to be made of how many proofs and mathematical theories should be present within the library.</p>
<p>Coq takes an approach that minimizes the amount of pure mathematical theory inside the standard library. The library contains mostly common concepts such as rationals, integers, naturals, sets, structures, Peano’s axioms etc. If you are interested in a particular part of mathematics, such as probability or analysis, then Coq also offers a collection of community maintained packages that can form as a basis for your work or theory.</p>
<p>Isabelle and HOL Light, on the other hand, do not have a package management system. Isabelle in particular therefore has a lot of resources in it’s standard library that cover large sweeps of mathematics of many varieties. Because of this, if comparing standard libraries directly, it could be said that Isabelle has features in analysis, but Coq does not. This however is not a particularly fair comparison, because even if Coq had the opportunity to include analysis within it’s standard library, it would probably prefer not to and include it as a package. As of such, this comparison also includes the current state of the art in terms of packages covering the different fields of mathematics for Coq, as well as it’s standard library.</p>
<p>One particular package of note is Coq-CoRN ("Constructive Coq Repository at Nijmegen"). This package contains many formalisms not present in the standard library, including analysis, and is commonly used in the Coq community.</p>
<p>It should be noted that although Isabelle doesn’t have a convential package management system, it does have an archive of formal proofs. The archive of formal proofs allows community members to submit Isabelle theories covering a particular topic. Isabelle’s archive of formal proofs is slightly different to a package ecosystem because it includes “finished products,” that is proofs that are interesting but not likely to be used in further development of proofs.</p>
<p>HOL Light also doesn’t have a package manager, however HOL Light, like Isabelle, has parts of mathematics within its standard library. HOL Light is not as popular a theorem prover as the other two, and as of such does not have as large a scope.</p>
<p>It was found that although Isabelle was claimed to be missing mathematical foundations, in comparison to other theorem provers, it seemed to have the standard library with the largest scope. Coq does not have foundations in many of the areas of mathematics, but usually offers support for the areas through its package ecosystem. HOL Light on the other hand, sometimes contains support for some areas of math but not others.</p>
<p>In the end, the scope of the standard library and package ecosystems for both Coq and Isabelle should be strong enough for most mathematical purposes. We were unable to identify any foundations that were explicitly missing in either system. HOL Light on the other hand, does not contain some mathematical foundations, and is probably not the state of the art for proving mathematical theorems and mathematical libraries.</p>
<p>It should also be noted that KeY does not have a standard library, and as a direct manipulation theorem prover, is an extremely bad choice for proving mathematical theorems.</p>
<p>In figure <a href="#fig:library_scope" data-reference-type="ref" data-reference="fig:library_scope">1</a>, a summary of which topics are covered by each prover is shown. We will detail each of these categories in the following sections.</p>
<div id="tab:litresults">
<table>
<caption>Literature review papers</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Area</th>
<th style="text-align: left;">Sub-Field</th>
<th style="text-align: left;">Provers</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Algebra</td>
<td style="text-align: left;">Abstract</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="even">
<td style="text-align: left;">Algebra</td>
<td style="text-align: left;">Linear</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Algebra</td>
<td style="text-align: left;">Universal</td>
<td style="text-align: left;">Coq, Isabelle</td>
</tr>
<tr class="even">
<td style="text-align: left;">Foundations</td>
<td style="text-align: left;">Model Theory</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Foundations</td>
<td style="text-align: left;">Sets</td>
<td style="text-align: left;">Coq, Isabelle</td>
</tr>
<tr class="even">
<td style="text-align: left;">Foundations</td>
<td style="text-align: left;">Proof</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Number Theory</td>
<td style="text-align: left;">Analytic</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Number Theory</td>
<td style="text-align: left;">Algebraic</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Number Theory</td>
<td style="text-align: left;">Diophantine</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Analysis</td>
<td style="text-align: left;">Real Analysis</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Analysis</td>
<td style="text-align: left;">Functional Analysis</td>
<td style="text-align: left;">Isabelle</td>
</tr>
<tr class="even">
<td style="text-align: left;">Analysis</td>
<td style="text-align: left;">Complex Analysis</td>
<td style="text-align: left;">Isabelle</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Analysis</td>
<td style="text-align: left;">Harmonic Analysis</td>
<td style="text-align: left;">Isabelle</td>
</tr>
<tr class="even">
<td style="text-align: left;">Analysis</td>
<td style="text-align: left;">Measure Theory</td>
<td style="text-align: left;">Isabelle</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Topology</td>
<td style="text-align: left;">General</td>
<td style="text-align: left;">Isabelle, Coq, HOL Light</td>
</tr>
<tr class="even">
<td style="text-align: left;">Topology</td>
<td style="text-align: left;">Algebraic</td>
<td style="text-align: left;">Isabelle, Coq</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Topology</td>
<td style="text-align: left;">Differential</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Combinatorics</td>
<td style="text-align: left;">Enumerative</td>
<td style="text-align: left;">Coq, Isabelle*, HOL Light</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Combinatorics</td>
<td style="text-align: left;">Extremal</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Combinatorics</td>
<td style="text-align: left;">Graph Theory</td>
<td style="text-align: left;">Coq, Isabelle*, HOL Light</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Geometry</td>
<td style="text-align: left;">Convex</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="even">
<td style="text-align: left;">Geometry</td>
<td style="text-align: left;">Discrete</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Geometry</td>
<td style="text-align: left;">Differential</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="even">
<td style="text-align: left;">Geometry</td>
<td style="text-align: left;">Algebraic</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Geometry</td>
<td style="text-align: left;">Arithmetic</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="even">
<td style="text-align: left;">Geometry</td>
<td style="text-align: left;">Diophantine</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Computer Science</td>
<td style="text-align: left;">Numerical Analysis</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="even">
<td style="text-align: left;">Computer Science</td>
<td style="text-align: left;">Computer Algebra</td>
<td style="text-align: left;">Coq, Isabelle, HOL Light</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Computer Science</td>
<td style="text-align: left;">Complexity Theory</td>
<td style="text-align: left;">Coq, Isabelle</td>
</tr>
<tr class="even">
<td style="text-align: left;">Probability</td>
<td style="text-align: left;">Probability Theory</td>
<td style="text-align: left;">Coq, Isabelle</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Probability</td>
<td style="text-align: left;">Statistics</td>
<td style="text-align: left;">Coq, Isabelle</td>
</tr>
</tbody>
</table>
</div>
<figure>
<img src="Images/Problems/Quality%20of%20Library/out.png" id="fig:library_scope" alt="Caterogies of Mathematics covered by ITP" /><figcaption aria-hidden="true">Caterogies of Mathematics covered by ITP</figcaption>
</figure>
<h3 id="algebra">Algebra</h3>
<p>Algebra is a broad area of math dedicated to the study of mathematical objects, and how to manipulate these mathematical objects. We split this into three sub-areas, abstract algebra, linear algebra and universal algebra.</p>
<p>Abstract Algebra is the study of mathematical objects such as groups, rings, fields, modules and lattices. These objects are defined as sets which have operations defined over them that confine to cerain axioms.</p>
<p>In terms of abstract structures, Coq includes the concept of a ring and a field. It however does not include groups within its library, nor lattices in order theory. Order theory, lattices and groups are however found in coq-CoRN. Coq therefore, with the help of its packages, covers the fundamentals of abstract algebra.</p>
<p>Isabelle contains packages for fields, modules, groups, rings, order theory and lattices. It furthermore has definitions for conditionally complete lattices, semirings and Archemidian fields. Foundations of abstract algebra are relatively complete in the standard library.</p>
<p>HOL Light has groups and rings, but no lattices or order theory. It has less support for abstract algebra than Coq and Isabelle.</p>
<p>Linear Algebra is the study of linear equations, and their applications through vector spaces and matrices.</p>
<p>Coq does not have support for linear algebra in its main library, but contains support within its package system (coq-lin-alg).</p>
<p>Isabelle contains formalizations required for linear algebra within its standard library, including matrices (HOL-Matrix_LP.Matrix), vector spaces (HOL.Vector_Spaces) and linear programming (HOL-Matrix_LP).</p>
<p>HOL Light has some basics for Linear Algebra as required by its Multivariate Calculus library, including Matrices (Multivariate/determinants).</p>
<p>Finally, Universal Algebra is the study of Algebraic structures themselves, rather than the study of particular examples of Algebras as in Abstract Algebra.</p>
<p>Coq has some libraries tagged with universal algebra on its package management system, such as coq-math-classes.</p>
<p>Isabelle has fundemental theorems from universal algebra inside, HOL-Algebra such as the first and second isomorphism theorems.</p>
<p>HOL Light does not have support for Universal Algebra.</p>
<p>So in terms of Algebra, Coq and Isabelle contain foundations for most of algebra within its library and packages. However, HOL Light’s support could be improved, particularly in universal and abstract algebra.</p>
<h3 id="foundations">Foundations</h3>
<p>Foundations include proof theory, set theory and model theory. These are often included in theorem prover libraries as they are required as a foundation for proofs.</p>
<p>ITPs themselves are implementations of different logics within proof theory, so its a bit unusual to ask whether an ITP supports proof theory. This investigation attempts to look into the support for different foundational ideas within proof theory.</p>
<p>In Coq’s package management system, Coq contains support for proof theory (coc-propcal). Including Natural deduction calculus, hilbert calculus and sequent calculus.</p>
<p>Isabelle contains support for different logics, such as natural deduction (FOL) and sequent calculus (Sequent)</p>
<p>HOL Light also includes natural deduction and sequent calculus. <!-- Not sureabout this one --></p>
<p>Set Theory is the study of sets, often in terms of foundations of mathematics.</p>
<p>Coq includes Classical and Constructive Logic in proof theory. The most common being Zermelo–Fraenkel set theory.</p>
<p>Coq has packages for Zermelo-Fraenkel Set theory (coq-zf)</p>
<p>Isabelle has a section of its library for Zermelo-Fraenkel (ZF).</p>
<p>HOL Light does not have formalizations for Zermelo-Fraenkel.</p>
<p>Finally, Model Theory is the study of the semantic relationships between different formal theories.</p>
<!-- Not sure how to do Model theory -->
<p>Therefore, Coq and Isabelle have strong support for Foundational Mathematics, but it is missing from within HOL Light</p>
<h3 id="number-theory">Number Theory</h3>
<p>Number Theory includes the study of numbers (usually integers) and how they relate to each other. We split it up into three sections, Analytic Number Theory, Algebraic Number Theory and Diophantine Number Theory.</p>
<p>Analytic Number Theory is the use of methods from mathematical analysis to solve problems related to integers. Results we looked for to determine whether a library supported this were things like Dirichlet L-functions and an analytic proof to the prime number theorem.</p>
<p>Coq does not have findings or tools from Analytic Number theory within its package ecosystem or standard library.</p>
<p>Isabelle does not have tools from Analytic Number theory within its library, but does have results in its archive of formal proofs. Particularly, <a href="https://www.isa-afp.org/entries/Dirichlet_L.html">Drichlet L Functions</a>.</p>
<p>HOL Light does not have any findings.</p>
<p>Algebraic Number Theory uses the study of abstract algebra to study integers and rationals and their generalizations. To determine whether this was covered, we looked for formalizations talking about unique prime factorizations over different algebraic structures and prime ideals.</p>
<p>Coq does not have any findings from Algebraic Number Theory.</p>
<p>Isabelle has findings from Algebraic Number Theory in (HOL-Algebra). <!-- Not sure about this one --></p>
<p>HOL Light does not have findings from algebraic number theory.</p>
<p>Finally, Diophantine Geometry is the study of the amount of solutions Diophantine equation have. To determine whether a library has basics covered for this areas, we looked into definitions for Diophantine Geometry.</p>
<p>Coq does not have findings for Diophantine Geometry in its library or package management system. It however has a formalization for Hilbert’s 10th problem which is to do with diophantine Geometry. <!-- Needs to be cited --></p>
<p>Isabelle also contains a formalization for Hilbert’s 10th problem.</p>
<p>HOL Light does not have findings in this area of mathematics.</p>
<p>Therefore, Isabelle seems to lead the other provers in terms of findings from number theory, with Coq coming next and HOL Light not containing any proofs.</p>
<h3 id="analysis">Analysis</h3>
<p>Analysis is the study of limits, differentiation, integration, infinite series, and other related topics. We split it into four different subfields, Real Analysis, Complex Analysis, Functional Analysis and Measure Theory.</p>
<p>Real Analysis is the study of differention and rates of change over over the real numbers.</p>
<p>Coq contains packages for real analysis such as coq-coqtail and coq-coquelicot.</p>
<p>Isabelle has support for Real Analysis in HOL-Analysis.</p>
<p>HOL Light has support for analysis in its multivariate library.</p>
<p>Complex Analysis is the study of rates of change and integrals over a the complex numbers.</p>
<p>Coq contains formalizms for complex analysis within coq-coqtail.</p>
<p>Isabelle contains formalizms for Complex Analysis in HOL-ComplexAnalysis.</p>
<p>HOL Light has support for complex analysis in its multivariate library.</p>
<p>Functional Analysis in analysis as applied to functions, often looking into integration and differentiation as it applies to infinite dimensional spaces.</p>
<p>Coq does not contain formalizations for functional analysis. Although it has been formalized by some researchers. <!-- Please cite --></p>
<p>Isabelle contains some formalizations for functional analysis in its library, particularly The Hahn-Banach theorem, which is one of the fundemental theorems of functional analysis.</p>
<p>HOL Light does not contain formalizations of functional analysis.</p>
<p>Measure theory is the study of measures. That is, ways of assigning cardinality to subsets of a set.</p>
<p>Coq contains a formalization of measure theory for its use in the formalization of probability within coq-random. But other than that, does not contain any other formalizations.</p>
<p>standard library, but does include definitions within Coq-CoRN.</p>
<p>Isabelle has the most tools for analysis, including modules for Complex Analysis, Nonstandard Analysis, Asymptopic analysis, Multivariate Analysis and Functional Analysis.</p>
<p>HOL Light has definitions for differentiation and multivariate analysis.</p>
<p>All three theorem provers in this case have definitions for analysis. However, Isabelle has a clear margin with support for different areas of analysis.</p>
<h3 id="topology">Topology</h3>
<p>Topology is the study of properties that are preserved through the deformation of objects. This is used to study properties of spaces required for other fields of mathematics. For instance, analysis is often founded on metric spaces from topology.</p>
<p>Coq’s standard library does not contain any formalizations for topology, however there are libraries for general topology in the coq-topology package. It includes metric spaces, topological filters and nets.</p>
<p>Isabelle has formalizations for Topology within its standard library. Including formalizations for Hausforff spaces and separation properties and topological filters.</p>
<p>HOL Light does contain some formalizations for topology, mainly for the purpose of it’s real analysis library.</p>
<p>All provers therefore contain formalizations for topology. We could not identify any missing library components.</p>
<h3 id="combinatorics">Combinatorics</h3>
<p>Combinatorics is the study of methods used for counting. It’s subfields include Enumerative, Extremal and Graph Theory.</p>
<p>Coq also has formalizations for enumerative combinatorics, graph theory in its package ecosytem, but doesn’t have any formalizations for extremal combinatorics.</p>
<p>Isabelle has proofs from enumerative combinatorics and graph theory in its archive of formal proofs. However, there does not seem to be any proofs from extremal combinatorics.</p>
<p>HOL Light has formalizations for enumaritev combinatorics and graph theory, but again, not extremal combinatorics.</p>
<p>All theorem prover provers are lacking extremal combinarics, but have enumaritive combinatorics and graph theory.</p>
<h2 id="geometry">Geometry</h2>
<p>Geometry is the study of the properties of space to do with distance.</p>
<p>Coq, Isabelle and HOL Light all have formalizations for geometry.</p>
<h3 id="probability">Probability</h3>
<p>Probability is the study of the likelihood that certain events will occur, or the likelihood that a proposition is true, depending on your interpretation.</p>
<p>Coq does not contain any formalizations for probability in it’s standard library. It however has several formalizations of probability in its package ecosystem, such as coq-alea.</p>
<p>Isabelle has a rather complete formalization of probability within it’s standard library. This formalization includes the defintion of distributions, expected value and conditional expectation.</p>
<p>HOL Light does not have a formalization for probability in it’s library.</p>
<p>Isabelle currently therefore has the widest coverage of probability in it’s library. HOL Light could be improved by including a probability module.</p>
<h3 id="computer-science">Computer Science</h3>
<p>Computer Science is the study of topics related to computers including binary arithmetic and runtime complexity.</p>
<p>Coq contains formalizations for binary integers and floating point arithmetic. It also has formalizations for complexity in its package ecosystem, such as coq-cecoa.</p>
<p>Isabelle contains formalizations for floating point numbers and complexity theory within it’s standard library. Including formalizations for IEEE floats and Big-O notation</p>
<p>HOL Light has a formalization for IEEE floats but not complexity theory.</p>
<p>Therefore, Coq and Isabelle again contain formalizations for basic computer science, however HOL Light could be improved in its support</p>
<h2 id="repetitive-trivial-interactions">Repetitive Trivial Interactions</h2>
<p>In Focus Groups, KeY was mentioned to require that the user to do many trivial interactions.</p>
<p>Because KeY is a Direct Manipulation Prover, proving propositions manually requires pointing and clicking at the parts of the proof that you want to edit. Other provers on the other hand, have a textual interface for proving theorems, and therefore allow for finer detailed interactions with the prover.</p>
<p>The classic way of preventing trivial interactions is to improve the level of abstraction that the user works on. In this case, there are very little ways to improve the abstraction level that KeY works on. The main hope is that KeY can solve the goal automatically, or with the help of strategy macros. So this issue still exists.</p>
<p>Improving this would be difficult without turning KeY into a textual prover.</p>
<p><span class="citation" data-cites="beckert_usability_2015">(Beckert, Grebing, and Böhl 2015)</span>.</p>
<p>It’s claimed that KeY often requires tedious interaction with low level logic formulas. interacting</p>
<p>Issues with abstraction is difficult to determine without looking at experimental evidence. As different levels of abstraction simplicity offer tradeoffs that are non trivial. The mechanisms discussed here include ability to use typeclasses, modules and type theory.</p>
<p>Isabelle, Coq and HOL Light all have these features. However, KeY is a direct manipulation therom</p>
<pre class="coq"><code>Class Show A: Type :=
  {
    show : A -&gt; string
  }.</code></pre>
<pre class="coq"><code>Module Mod.
    Definition T:=nat.
    Check T.
End Mod.</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Show =</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  fixes show::a =&gt; <span class="dt">string</span></span></code></pre></div>
<p>Coq, Isabelle and are all based off ML style languages, and as of such all contain abstraction mechanisms common in such ML/Functional programming languages, such as modules (and typeclasses for Coq and Isabelle).</p>
<p>In Isabelle, theories, locales and classes are available. A theory represents the largest level of abstraction, and is represented by the file which contains Isabelle source code. Locale’s are like modules, except these modules can be extended and paramaterized. This is in a sense similar to C++ templates, except they can occur over any scope and can accept arbitrary inputs, such as other functions. Finally, classes are similar to Haskell’s type classes.</p>
<p>An example of an Isabelle locale, borrowed from the locales tutorial in isabelle is below</p>
<pre class="isabelle"><code>locale partial_order = 
  fixes le :: &quot;’a =&gt; ’a =&gt; bool&quot; (infixl &quot;v&quot; 50)
  assumes refl [intro, simp]: &quot;x v x&quot; 
    and anti_sym [intro]: &quot;[[x v y; y v x]] =&gt; x = y&quot;
    and trans [trans]: &quot;[[x v y; y v z]] =&gt; x v z&quot;</code></pre>
<p>This declares a locale named "partial_order". It requires a function le (less than or equal to) and that certain properties are true about le. That is, reflexivity, anti symmetry and transitivity.</p>
<p>Locales are often used to represent abstract properties around types. For instance, partial order is a property that could exist to different types of numbers, such as naturals, integers and rationals. But could also apply to different things for different operations, such as sets if you define le in terms of size or some other property.</p>
<p>Using locales for these properties allows users to prove generic properties around sets with partial order. This allows for proof re use and forms a very strong form of abstraction.</p>
<p>An implementation (called an interpretation in isabelle) of partial_ order for the int type looks like the following:</p>
<pre class="isabelle"><code>interpretation int: partial_order &quot;(&lt;=) :: int =&gt; int =&gt; bool&quot;
 by unfold_locales auto</code></pre>
<p>In this case, the int type’s partial order was realized for the &lt;= operator. The fact that reflexivity, anti symmetry and transitivity holds was automatically dispatched by Isabelle’s automatic prover without additional user interaction.</p>
<p>Isabelle also supports Haskell style type classes. These are in the end implemented through the use of locales, as locales are the more general concept.</p>
<p>Coq supports a similar system with modules and module types</p>
<pre class="coq"><code>Module Type HasLe (Import T:Typ).
  Parameter Inline(40) le : t -&gt; t -&gt; Prop.
End HasLe.</code></pre>
<p>This is similar to a locale. This requires the module that instantiates this module type to have a less than or equal property.</p>
<p>These can be extended and combined with different properties, and eventually implemented for a certain type. For instance, the PaenoNat module is defined as implementing a type with total order, being a full ordered type, being a decidable type and other axioms in NAxiomsSig. Each of these represent</p>
<pre class="coq"><code>Module Nat
 &lt;: NAxiomsSig
 &lt;: UsualDecidableTypeFull
 &lt;: OrderedTypeFull
 &lt;: TotalOrder.
 
 .... (implementations) ....
End Nat.</code></pre>
<p>This serves a similar purpose to locale’s in Isabelle. Haskell style type classes are also availabe for Coq.</p>
<p>HOL Light has its interface in OCaml, and because Coq’s module type system is inspired by OCaml’s module type system, it has a very similar abstraction mechanism. To take an example from the OCaml tutorials</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> Hello_type = <span class="kw">sig</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">val</span> hello : <span class="dt">unit</span> -&gt; <span class="dt">unit</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Hello : Hello_type = <span class="kw">struct</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  ... (implementations) ...</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>These can be used to organize programs within the ITPs. In my experience and opinion, these abstraction mechanisms are often more than enough to organize large systems.</p>
<p>KeY is a direct manipulation prover, and currently does have minor abstraction mechanisms through the use of macros. These however are not at the level of sophistication of other theorem provers. This was identified as an issue in focus groups, but would be difficult to solve without implementing some form of textual interface to KeY.</p>
<h2 id="math-notation">Math Notation</h2>
<p>One of the pain points that Matita addresses is Coq’s lack of mathematical notation. Matita represent statements using LaTeX. However, Coq can use mathematical notation through the use of Unicode.</p>
<p>Coq has support for Unicode, and therefore technically allows writing math notation. CoqIDE allows you to input math characters with Shift+Space. Unicode is however, little used within libraries and everyday Coq code. This could be improved by improving the Unicode section of the standard library to include common mathematical notation.</p>
<p>Coq’s entire library of Unicode support (as of 14th of July 2021) is shown in figure <a href="#fig:coqunicode" data-reference-type="ref" data-reference="fig:coqunicode">3</a>.</p>
<p><img src="Images/Problems/Notation/Utf8Coq.png" title="fig:" id="fig:coqunicode" alt="Coq’s entire support of Unicode math notation" /> <img src="Images/Problems/Notation/Utf8Coq2.png" title="fig:" id="fig:coqunicode" alt="Coq’s entire support of Unicode math notation" /></p>
<p>This could be improved by increasing the amount of unicode support in libraries. However, the difference in interpretability and usability due to this support of notation has yet to have been observed.</p>
<p>Isabelle has support for mathematical notation through LaTeX. It encourages use of this mathematical notation. It is often used as an example as to why other languages should use math notation.</p>
<p>It has a window at the bottom of it’s interface to allows for the easy input of these symbols. This window is shown in figure <a href="#fig:isabellenotation" data-reference-type="ref" data-reference="fig:isabellenotation">4</a>.</p>
<figure>
<img src="Images/Problems/Notation/IsabelleNotation.png" id="fig:isabellenotation" alt="Isabelle Notation window" /><figcaption aria-hidden="true">Isabelle Notation window</figcaption>
</figure>
<p>This type of interface could be implemented in Coq to improve notational support, but only after it has support within the library.</p>
<p>KeY does not have support for mathematical notation. Neither does HOL Light.</p>
<h2 id="mapping-to-program">Mapping to Program</h2>
<p>KeY was mentioned to have a bad mapping to programs during focus groups. This is particular to the KeY prover, because all other provers don’t have a mapping between programs in other languages to properties that need to be proven. Although it’s been mentioned in a Focus Group, the empirical verification of this problem would be difficult to do without a study.</p>
<p>One such study could time how long people think about the mapping to program in a session of KeY. Or measure the amount of misunderstandings made of the mapping to program within KeY. This could be compared with Aitken’s study <span class="citation" data-cites="aitken_analysis_2000">(S. Aitken and Melham 2000)</span> and determined whether it is more important.</p>
<h2 id="selecting-tactics">Selecting Tactics</h2>
<p>Both Isabelle and HOL have been found to be difficult to find appropriate lemmas and tactics for situations in observational studies.</p>
<p>CoqIDE provides a drop down menu for selecting tactics at the top bar. This drop down menu however does not refine itself to only tactics that can be applied. This therefore makes the menu of questionable utility. The feature of refining what tactics are available in menus was created in CoqEdit. This could be implemented in other IDEs such as CoqIDE to improve usability</p>
<p>Isabelle is known to be difficult to find tactics and theorems that are relevant. Pamper <span class="citation" data-cites="nagashima_pamper_2018">(Nagashima and He 2018)</span> is a tool that creates recommendations in a more intelligent fashion, and could be implemented in other theorem provers as well as Isabelle</p>
<p>Key is easy to find tactics (or taclets, as they call them), as it is a direct manipulation prover. To find a tactic, you right click on the part of the proof that you want to manipulate and click on the tactic that you want to apply. This type of solution could be (and has been) implemented in other theorem provers.</p>
<p>Finding tactics in HOL requires looking through the source code. This is again because it doesn’t really have an interface.</p>
<h2 id="bloated-representation">Bloated Representation</h2>
<p>Isabelle has been suggested to have bloated representations of formulas in Focus Groups. As well as large proofs being found to correspond with a larger amount of effort. This has not been suggested in any other theorem prover and would be difficult to comment on without a study in this area.</p>
<h2 id="difficult-namespaces">Difficult Namespaces</h2>
<p>The Difficulty an managing namespaces was suggested to be an issue with managing large scale Isabelle projects. Solutions have not been proposed nor has the problem been properly studied. This type of issue is difficult to discuss without a proper study</p>
<h2 id="difficult-syntax">Difficult Syntax</h2>
<p>Difficult syntax, particularly object level syntax, was observed by Aitken for Isabelle/HOL.</p>
<p>Coq’s syntax is difficult to learn due to the large amounts of concepts it borrows from a very large amount of languages, and it’s support for dependent type theory. Novel feature such as typeclasses, Module types and Module Functors are in few other languages, and may have to be learnt. The existence of these issues in Coq has not been shown by study. It would be difficult to investigate these issues in Coq or KeY without a proper study.</p>
<p>Isabelle has a simpler syntax based of ML and simple type theory. The syntax is not as much of an issue unless you are entering complicated object level formulas.</p>
<p>HOL’s syntax is about as complicated as OCaml, which is complicated but not terrible for those who know ML style languages.</p>
<h2 id="unexpected-results-from-tactics">Unexpected results from tactics</h2>
<p>Incorrect predictions made about tactics was observed by Aitken for Isabelle/HOL.</p>
<h2 id="hard-to-understand-proof-scripts">Hard to understand proof scripts</h2>
<h2 id="cannot-see-dependencies">Cannot see dependencies</h2>
<h2 id="difficult-to-patch-proofs">Difficult to patch proofs</h2>
<h2 id="difficult-to-move-lemmas">Difficult to move lemmas</h2>
<h2 id="difficult-to-understand-proof-state">Difficult to understand proof state</h2>
<h2 id="counterexamples">Counterexamples</h2>
<p>Counterexample generation is not supported in Coq, due to issues with dependent type theory. There are packages that support this feature in Coq such as nanchaku, but counterexample generation is still an open problem when it come to dependent types.</p>
<p>Isabelle does have counter examples like quickpick and nitpick. They are particularly useful in development.</p>
<p>KeY does not have counter example generators, and it has been recorded that it would be nice if it did</p>
<p>HOL does not have support for counterexample generators. Again, due to pretty much not having an interface.</p>
<h2 id="constant-redesign">Constant Redesign</h2>
<h2 id="error-messages">Error Messages</h2>
<h2 id="difficult-reason-as-for-proof-failure">Difficult reason as for proof failure</h2>
<h2 id="proof-refactoring">Proof Refactoring</h2>
<h2 id="performance">Performance</h2>
<p>Coq’s performance is ok until you come to larger proof documents. The same can be said for Isabelle. These issues can be fixed with asynchronous proof loading, which is above. Automated strategies and sledgehammers take a while to execute.</p>
<p>KeY’s performance on the automated strategies takes a while to complete and could be improved.</p>
<p>HOL’s performance is just really good, due to it’s simplicity.</p>
<h2 id="too-much-detail">Too much detail</h2>
<h2 id="missing-required-information">Missing required information</h2>
<h2 id="insight-into-automated-tactics">Insight into automated tactics</h2>
<h1 class="unnumbered" id="bibliography">Bibliography</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-aitken_interactive_1998" class="csl-entry" role="doc-biblioentry">
Aitken, J. S., P. Gray, T. Melham, and M. Thomas. 1998. <span>“Interactive <span>Theorem</span> <span>Proving</span>: <span>An</span> <span>Empirical</span> <span>Study</span> of <span>User</span> <span>Activity</span>.”</span> <em>Journal of Symbolic Computation</em> 25 (2): 263–84. https://doi.org/<a href="https://doi.org/10.1006/jsco.1997.0175">https://doi.org/10.1006/jsco.1997.0175</a>.
</div>
<div id="ref-aitken_analysis_2000" class="csl-entry" role="doc-biblioentry">
Aitken, S., and T. Melham. 2000. <span>“An Analysis of Errors in Interactive Proof Attempts.”</span> <em>Interacting with Computers</em> 12 (6): 565–86. <a href="https://doi.org/10.1016/S0953-5438(99)00023-5">https://doi.org/10.1016/S0953-5438(99)00023-5</a>.
</div>
<div id="ref-asperti_considerations_2010" class="csl-entry" role="doc-biblioentry">
Asperti, Andrea, and Claudio Sacerdoti Coen. 2010. <span>“Some <span>Considerations</span> on the <span>Usability</span> of <span>Interactive</span> <span>Provers</span>.”</span> In <em>Proceedings of the 10th <span>ASIC</span> and 9th <span>MKM</span> <span>International</span> <span>Conference</span>, and 17th <span>Calculemus</span> <span>Conference</span> on <span>Intelligent</span> <span>Computer</span> <span>Mathematics</span></em>, 147–56. <span>AISC</span>’10/<span>MKM</span>’10/<span>Calculemus</span>’10. Berlin, Heidelberg: Springer-Verlag.
</div>
<div id="ref-asperti_user_2007" class="csl-entry" role="doc-biblioentry">
Asperti, Andrea, Claudio Sacerdoti Coen, Enrico Tassi, and Stefano Zacchiroli. 2007. <span>“User <span>Interaction</span> with the <span>Matita</span> <span>Proof</span> <span>Assistant</span>.”</span> <em>Journal of Automated Reasoning</em> 39 (2): 109–39. <a href="https://doi.org/10.1007/s10817-007-9070-5">https://doi.org/10.1007/s10817-007-9070-5</a>.
</div>
<div id="ref-aspinall_towards_2016" class="csl-entry" role="doc-biblioentry">
Aspinall, David, and Cezary Kaliszyk. 2016. <span>“Towards <span>Formal</span> <span>Proof</span> <span>Metrics</span>.”</span> In <em>Fundamental <span>Approaches</span> to <span>Software</span> <span>Engineering</span></em>, edited by Perdita Stevens and Andrzej Wasowski, 325–41. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-barras_asynchronous_2015" class="csl-entry" role="doc-biblioentry">
Barras, Bruno, Carst Tankink, and Enrico Tassi. 2015. <span>“Asynchronous <span>Processing</span> of <span>Coq</span> <span>Documents</span>: <span>From</span> the <span>Kernel</span> up to the <span>User</span> <span>Interface</span>.”</span> In <em>Interactive <span>Theorem</span> <span>Proving</span></em>, edited by Christian Urban and Xingyuan Zhang, 51–66. Cham: Springer International Publishing.
</div>
<div id="ref-becker_lassie_2021" class="csl-entry" role="doc-biblioentry">
Becker, Heiko, Nathaniel Bos, Ivan Gavran, Eva Darulova, and Rupak Majumdar. 2021. <span>“Lassie: <span>Hol4</span> <span>Tactics</span> by <span>Example</span>.”</span> In <em>Proceedings of the 10th <span>ACM</span> <span>SIGPLAN</span> <span>International</span> <span>Conference</span> on <span>Certified</span> <span>Programs</span> and <span>Proofs</span></em>, 212–23. <span>CPP</span> 2021. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/3437992.3439925">https://doi.org/10.1145/3437992.3439925</a>.
</div>
<div id="ref-beckert_evaluating_2012" class="csl-entry" role="doc-biblioentry">
Beckert, Bernhard, and S. Grebing. 2012. <span>“Evaluating the <span>Usability</span> of <span>Interactive</span> <span>Verification</span> <span>Systems</span>.”</span> In <em><span>COMPARE</span></em>.
</div>
<div id="ref-beckert_interactive_2015" class="csl-entry" role="doc-biblioentry">
———. 2015. <span>“Interactive <span>Theorem</span> <span>Proving</span> - <span>Modelling</span> the <span>User</span> in the <span>Proof</span> <span>Process</span>.”</span> In <em>Bridging@<span>CADE</span></em>.
</div>
<div id="ref-beckert_usability_2015" class="csl-entry" role="doc-biblioentry">
Beckert, Bernhard, Sarah Grebing, and Florian Böhl. 2015. <span>“A <span>Usability</span> <span>Evaluation</span> of <span>Interactive</span> <span>Theorem</span> <span>Provers</span> <span>Using</span> <span>Focus</span> <span>Groups</span>.”</span> In <em>Software <span>Engineering</span> and <span>Formal</span> <span>Methods</span></em>, edited by Carlos Canal and Akram Idani, 3–19. Cham: Springer International Publishing.
</div>
<div id="ref-beckert_interaction_2017" class="csl-entry" role="doc-biblioentry">
Beckert, Bernhard, Sarah Grebing, and Mattias Ulbrich. 2017. <span>“An <span>Interaction</span> <span>Concept</span> for <span>Program</span> <span>Verification</span> <span>Systems</span> with <span>Explicit</span> <span>Proof</span> <span>Object</span>.”</span> In <em>Hardware and <span>Software</span>: <span>Verification</span> and <span>Testing</span></em>, edited by Ofer Strichman and Rachel Tzoref-Brill, 163–78. Cham: Springer International Publishing.
</div>
<div id="ref-berman_development_2014" class="csl-entry" role="doc-biblioentry">
Berman, Benjamin Alexander. 2014. <em>Development and User Testing of New User Interfaces for Mathematics and Programming Tools</em>. University of Iowa.
</div>
<div id="ref-bourke_challenges_2012" class="csl-entry" role="doc-biblioentry">
Bourke, Timothy, Matthias Daum, Gerwin Klein, and Rafal Kolanski. 2012. <span>“Challenges and <span>Experiences</span> in <span>Managing</span> <span>Large</span>-<span>Scale</span> <span>Proofs</span>.”</span> In <em>Intelligent <span>Computer</span> <span>Mathematics</span></em>, edited by Johan Jeuring, John A. Campbell, Jacques Carette, Gabriel Dos Reis, Petr Sojka, Makarius Wenzel, and Volker Sorge, 32–48. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-eastaughffe_support_1998" class="csl-entry" role="doc-biblioentry">
Eastaughffe, Katherine. 1998. <span>“Support for <span>Interactive</span> <span>Theorem</span> <span>Proving</span>: <span>Some</span> <span>Design</span> <span>Principles</span> and <span>Their</span> <span>Application</span>.”</span>
</div>
<div id="ref-grebing_seamless_2020" class="csl-entry" role="doc-biblioentry">
Grebing, Sarah, Jonas Klamroth, and Mattias Ulbrich. 2020. <span>“Seamless <span>Interactive</span> <span>Program</span> <span>Verification</span>.”</span> In <em>Verified <span>Software</span>. <span>Theories</span>, <span>Tools</span>, and <span>Experiments</span></em>, edited by Supratik Chakraborty and Jorge A. Navas, 68–86. Cham: Springer International Publishing.
</div>
<div id="ref-grebing_usability_2020" class="csl-entry" role="doc-biblioentry">
Grebing, Sarah, and Mattias Ulbrich. 2020. <span>“Usability <span>Recommendations</span> for <span>User</span> <span>Guidance</span> in <span>Deductive</span> <span>Program</span> <span>Verification</span>.”</span> In <em>Deductive <span>Software</span> <span>Verification</span>: <span>Future</span> <span>Perspectives</span>: <span>Reflections</span> on the <span>Occasion</span> of 20 <span>Years</span> of <span>KeY</span></em>, edited by Wolfgang Ahrendt, Bernhard Beckert, Richard Bubel, Reiner Hähnle, and Mattias Ulbrich, 261–84. Cham: Springer International Publishing. <a href="https://doi.org/10.1007/978-3-030-64354-6_11">https://doi.org/10.1007/978-3-030-64354-6_11</a>.
</div>
<div id="ref-green_usability_1996" class="csl-entry" role="doc-biblioentry">
Green, T. R. G., and M. Petre. 1996. <span>“Usability <span>Analysis</span> of <span>Visual</span> <span>Programming</span> <span>Environments</span>: <span>A</span> <span>‘<span>Cognitive</span> <span>Dimensions</span>’</span> <span>Framework</span>.”</span> <em>Journal of Visual Languages &amp; Computing</em> 7 (2): 131–74. https://doi.org/<a href="https://doi.org/10.1006/jvlc.1996.0009">https://doi.org/10.1006/jvlc.1996.0009</a>.
</div>
<div id="ref-grov_tinker_2018" class="csl-entry" role="doc-biblioentry">
Grov, Gudmund, and Yuhui Lin. 2018. <span>“The <span>Tinker</span> Tool for Graphical Tactic Development.”</span> <em>International Journal on Software Tools for Technology Transfer</em> 20 (2): 139–55. <a href="https://doi.org/10.1007/s10009-017-0452-7">https://doi.org/10.1007/s10009-017-0452-7</a>.
</div>
<div id="ref-hahnle_deductive_2019" class="csl-entry" role="doc-biblioentry">
Hähnle, Reiner, and Marieke Huisman. 2019. <span>“Deductive <span>Software</span> <span>Verification</span>: <span>From</span> <span>Pen</span>-and-<span>Paper</span> <span>Proofs</span> to <span>Industrial</span> <span>Tools</span>.”</span> In <em>Computing and <span>Software</span> <span>Science</span>: <span>State</span> of the <span>Art</span> and <span>Perspectives</span></em>, edited by Bernhard Steffen and Gerhard Woeginger, 345–73. Cham: Springer International Publishing. <a href="https://doi.org/10.1007/978-3-319-91908-9_18">https://doi.org/10.1007/978-3-319-91908-9_18</a>.
</div>
<div id="ref-hentschel_integrating_2016" class="csl-entry" role="doc-biblioentry">
Hentschel, Martin. 2016. <span>“Integrating <span>Symbolic</span> <span>Execution</span>, <span>Debugging</span> and <span>Verification</span>.”</span> {PhD} {Thesis}, Technische Universität Darmstadt. <a href="http://tuprints.ulb.tu-darmstadt.de/5399/">http://tuprints.ulb.tu-darmstadt.de/5399/</a>.
</div>
<div id="ref-hentschel_empirical_2016" class="csl-entry" role="doc-biblioentry">
Hentschel, Martin, Reiner Hähnle, and Richard Bubel. 2016a. <span>“An <span>Empirical</span> <span>Evaluation</span> of <span>Two</span> <span>User</span> <span>Interfaces</span> of an <span>Interactive</span> <span>Program</span> <span>Verifier</span>.”</span> In <em>Proceedings of the 31st <span>IEEE</span>/<span>ACM</span> <span>International</span> <span>Conference</span> on <span>Automated</span> <span>Software</span> <span>Engineering</span></em>, 403–13. <span>ASE</span> 2016. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/2970276.2970303">https://doi.org/10.1145/2970276.2970303</a>.
</div>
<div id="ref-hentschel_interactive_2016" class="csl-entry" role="doc-biblioentry">
———. 2016b. <span>“The <span>Interactive</span> <span>Verification</span> <span>Debugger</span>: <span>Effective</span> <span>Understanding</span> of <span>Interactive</span> <span>Proof</span> <span>Attempts</span>.”</span> In <em>Proceedings of the 31st <span>IEEE</span>/<span>ACM</span> <span>International</span> <span>Conference</span> on <span>Automated</span> <span>Software</span> <span>Engineering</span></em>, 846–51. <span>ASE</span> 2016. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/2970276.2970292">https://doi.org/10.1145/2970276.2970292</a>.
</div>
<div id="ref-hunter_agent-based_2005" class="csl-entry" role="doc-biblioentry">
Hunter, Chris, Peter Robinson, and Paul Strooper. 2005. <span>“Agent-<span>Based</span> <span>Distributed</span> <span>Software</span> <span>Verification</span>.”</span> In <em>Proceedings of the <span>Twenty</span>-<span>Eighth</span> <span>Australasian</span> <span>Conference</span> on <span>Computer</span> <span>Science</span> - <span>Volume</span> 38</em>, 159–64. <span>ACSC</span> ’05. AUS: Australian Computer Society, Inc.
</div>
<div id="ref-jones_systematic_1990" class="csl-entry" role="doc-biblioentry">
Jones, Cliff B. 1990. <em>Systematic <span>Software</span> <span>Development</span> <span>Using</span> <span>VDM</span> (2nd <span>Ed</span>.)</em>. USA: Prentice-Hall, Inc.
</div>
<div id="ref-kadoda_cognitive_2000" class="csl-entry" role="doc-biblioentry">
Kadoda, Gada. 2000. <em>A <span>Cognitive</span> <span>Dimensions</span> View of the Differences Between Designers and Users of Theorem Proving Assistants</em>.
</div>
<div id="ref-kadoda_desirable_1999" class="csl-entry" role="doc-biblioentry">
Kadoda, Gada F., R. Stone, and D. Diaper. 1999. <span>“Desirable Features of Educational Theorem Provers - a Cognitive Dimensions Viewpoint.”</span> In <em><span>PPIG</span></em>.
</div>
<div id="ref-kawabata_traf_2018" class="csl-entry" role="doc-biblioentry">
Kawabata, Hideyuki, Yuta Tanaka, Mai Kimura, and Tetsuo Hironaka. 2018. <span>“Traf: <span>A</span> <span>Graphical</span> <span>Proof</span> <span>Tree</span> <span>Viewer</span> <span>Cooperating</span> with <span>Coq</span> <span>Through</span> <span>Proof</span> <span>General</span>.”</span> In <em>Programming <span>Languages</span> and <span>Systems</span></em>, edited by Sukyoung Ryu, 157–65. Cham: Springer International Publishing.
</div>
<div id="ref-lin_understanding_2016" class="csl-entry" role="doc-biblioentry">
Lin, YuHui, Gudmund Grov, and Rob Arthan. 2016. <span>“Understanding and Maintaining Tactics Graphically <span>OR</span> How We Are Learning That a Diagram Can Be Worth More Than <span>10k</span> <span>LoC</span>.”</span> <em>Journal of Formalized Reasoning</em> 9 (2): 69–130. <a href="https://doi.org/10.6092/issn.1972-5787/6298">https://doi.org/10.6092/issn.1972-5787/6298</a>.
</div>
<div id="ref-mitsch_keymaera_2017" class="csl-entry" role="doc-biblioentry">
Mitsch, Stefan, and André Platzer. 2017. <span>“The <span>KeYmaera</span> <span>X</span> <span>Proof</span> <span>IDE</span> - <span>Concepts</span> on <span>Usability</span> in <span>Hybrid</span> <span>Systems</span> <span>Theorem</span> <span>Proving</span>.”</span> <em>Electronic Proceedings in Theoretical Computer Science</em> 240 (January): 67–81. <a href="https://doi.org/10.4204/eptcs.240.5">https://doi.org/10.4204/eptcs.240.5</a>.
</div>
<div id="ref-nagashima_pamper_2018" class="csl-entry" role="doc-biblioentry">
Nagashima, Yutaka, and Yilun He. 2018. <span>“<span>PaMpeR</span>: <span>Proof</span> <span>Method</span> <span>Recommendation</span> <span>System</span> for <span>Isabelle</span>/<span>HOL</span>.”</span> In <em>Proceedings of the 33rd <span>ACM</span>/<span>IEEE</span> <span>International</span> <span>Conference</span> on <span>Automated</span> <span>Software</span> <span>Engineering</span></em>, 362–72. <span>ASE</span> 2018. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/3238147.3238210">https://doi.org/10.1145/3238147.3238210</a>.
</div>
<div id="ref-nawaz_survey_2019" class="csl-entry" role="doc-biblioentry">
Nawaz, M. Saqib, Moin Malik, Yi Li, Meng Sun, and M. Ikram Ullah Lali. 2019. <em>A <span>Survey</span> on <span>Theorem</span> <span>Provers</span> in <span>Formal</span> <span>Methods</span></em>.
</div>
<div id="ref-potter_introduction_1992" class="csl-entry" role="doc-biblioentry">
Potter, Ben, Jane Sinclair, and David Till. 1992. <em>An <span>Introduction</span> to <span>Formal</span> <span>Specification</span> and <span>Z</span></em>. USA: Prentice-Hall, Inc.
</div>
<div id="ref-ringer_replica_2020" class="csl-entry" role="doc-biblioentry">
Ringer, Talia, Alex Sanchez-Stern, Dan Grossman, and Sorin Lerner. 2020. <span>“<span>REPLica</span>: <span>REPL</span> <span>Instrumentation</span> for <span>Coq</span> <span>Analysis</span>.”</span> In <em>Proceedings of the 9th <span>ACM</span> <span>SIGPLAN</span> <span>International</span> <span>Conference</span> on <span>Certified</span> <span>Programs</span> and <span>Proofs</span></em>, 99–113. <span>CPP</span> 2020. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/3372885.3373823">https://doi.org/10.1145/3372885.3373823</a>.
</div>
<div id="ref-roe_coqpie_2016" class="csl-entry" role="doc-biblioentry">
Roe, Kenneth, and Scott Smith. 2016. <span>“<span>CoqPIE</span>: <span>An</span> <span>IDE</span> <span>Aimed</span> at <span>Improving</span> <span>Proof</span> <span>Development</span> <span>Productivity</span>.”</span> In <em>Interactive <span>Theorem</span> <span>Proving</span></em>, edited by Jasmin Christian Blanchette and Stephan Merz, 491–99. Cham: Springer International Publishing.
</div>
<div id="ref-shams_accessible_2018" class="csl-entry" role="doc-biblioentry">
Shams, Zohreh, Yuri Sato, Mateja Jamnik, and Gem Stapleton. 2018. <span>“Accessible <span>Reasoning</span> with <span>Diagrams</span>: <span>From</span> <span>Cognition</span> to <span>Automation</span>.”</span> In <em>Diagrammatic <span>Representation</span> and <span>Inference</span></em>, edited by Peter Chapman, Gem Stapleton, Amirouche Moktefi, Sarah Perez-Kriz, and Francesco Bellucci, 247–63. Cham: Springer International Publishing.
</div>
<div id="ref-spichkova_human-centred_2017" class="csl-entry" role="doc-biblioentry">
Spichkova, Maria, and Milan Simic. 2017. <span>“Human-Centred Analysis of the Dependencies Within Sets of Proofs.”</span> <em>Knowledge-Based and Intelligent Information &amp; Engineering Systems: Proceedings of the 21st International Conference, KES-20176-8 September 2017, Marseille, France</em> 112 (January): 2290–98. <a href="https://doi.org/10.1016/j.procs.2017.08.256">https://doi.org/10.1016/j.procs.2017.08.256</a>.
</div>
<div id="ref-tassi_interactive_2008" class="csl-entry" role="doc-biblioentry">
Tassi, Enrico. 2008. <span>“Interactive Theorem Provers: Issues Faced as a User and Tackled as a Developer.”</span> {PhD} {Thesis}, alma. <a href="http://amsdottorato.unibo.it/917/">http://amsdottorato.unibo.it/917/</a>.
</div>
<div id="ref-wenzel_structured_2006" class="csl-entry" role="doc-biblioentry">
Wenzel, Makarius. 2006. <span>“Structured <span>Induction</span> <span>Proofs</span> in <span>Isabelle</span>/<span>Isar</span>.”</span> In <em>Mathematical <span>Knowledge</span> <span>Management</span></em>, edited by Jonathan M. Borwein and William M. Farmer, 17–30. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-wenzel_isabelle_2011" class="csl-entry" role="doc-biblioentry">
———. 2011. <span>“Isabelle as <span>Document</span>-<span>Oriented</span> <span>Proof</span> <span>Assistant</span>.”</span> In <em>Intelligent <span>Computer</span> <span>Mathematics</span></em>, edited by James H. Davenport, William M. Farmer, Josef Urban, and Florian Rabe, 244–59. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-wenzel_asynchronous_2014" class="csl-entry" role="doc-biblioentry">
———. 2014. <span>“Asynchronous <span>User</span> <span>Interaction</span> and <span>Tool</span> <span>Integration</span> in <span>Isabelle</span>/<span>PIDE</span>.”</span> In <em>Interactive <span>Theorem</span> <span>Proving</span></em>, edited by Gerwin Klein and Ruben Gamboa, 515–30. Cham: Springer International Publishing.
</div>
<div id="ref-zacchiroli_user_2007" class="csl-entry" role="doc-biblioentry">
Zacchiroli, Stefano. 2007. <span>“User Interaction Widgets for Interactive Theorem Proving.”</span> {PhD} {Thesis}, alma. <a href="http://amsdottorato.unibo.it/616/">http://amsdottorato.unibo.it/616/</a>.
</div>
</div>
</body>
</html>
