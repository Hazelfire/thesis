package,url,description,authors,msc,verified
coq-aac-tactics,https://github.com/coq-community/aac-tactics,"This Coq plugin provides tactics for rewriting universally quantified equations, modulo associativity and commutativity of some operator. The tactics can be applied for custom operators by registering the operators and their properties as type class instances. Many common operator instances, such as for Z binary arithmetic and booleans, are provided with the plugin.","Thomas Braibant, Damien Pous, Fabian Kunze",68V15,True
coq-abp,https://github.com/coq-contribs/abp,A verification of the alternating bit protocol expressed in CBS,Eduardo Giménez,68M12,True
coq-addition-chains,https://github.com/coq-community/hydra-battles,"Addition chains are algorithms for computations of the p-th power of some x,  with the least number of multiplication as possible. We present a few implementations of addition chains, with proofs of their correctness","Pierre Castéran, Yves Bertot",33B10,True
coq-additions,https://github.com/coq-contribs/additions,Note: this package has been superseded by coq-addition-chains.,Pierre Castéran,Exclude-Depr,True
coq-ails,https://github.com/coq-contribs/ails,An aircraft trajectory modeling and analysis using the AILS algorithm (Airborne Information for Lateral Spacing) to warn against possible collisions.,Olivier Desmettre,70-XX,True
coq-albert,https://gitlab.com/nomadic-labs/albert/,"Albert is an intermediate smart contract programming language targeting Michelson, the language for the Tezos blockchain. Albert is an imperative language with variables and records, abstracting the Michelson stack. The intent of Albert is to serve as a compilation target for high-level smart contract programming languages. The linear type system of Albert ensures that an Albert program, compiled to the stack-based Michelson language, properly consumes all stack values.  This package contains the ott specification of the language, the Albert compiler targeting Michelson written in Coq and extracted to OCaml.","Raphaël Cauderlier, Bruno Bernardo, Julien Tesson, Arvid Jakobsson, Basile Pesin",68N15,True
coq-alea,https://github.com/coq-community/alea,"ALEA is a library for reasoning on randomized algorithms in Coq, based on interpreting programs inside a monad as probability distributions.","Christine Paulin-Mohring, David Baelde, Pierre Courtieu",68W20,True
coq-algebra,https://github.com/coq-contribs/algebra,Basics notions of algebra,Loïc Pottier [http://www-sop.inria.fr/croap/personnel/Loic.Pottier/home.html],08-xx,True
coq-algorand,https://github.com/runtimeverification/algorand-verification,"The Algorand consensus protocol provides the foundation for a decentralized digital currency and transactions platform. This project provides a model of the protocol in Coq, expressed as a transition system over global states in a message-passing distributed system. Included is a formal proof of safety for the transition system.","Musab A. Alturki, Jing Chen, Victor Luchangco, Brandon Moore, Karl Palmskog, Lucas Peña, Grigore Roșu",68M12,True
coq-almost-full,https://github.com/coq-community/almost-full,"Coq development of almost-full relations, including the Ramsey Theorem, useful for proving termination.","Dimitrios Vytiniotis, Thierry Coquand, David Wahlstedt",05D10,False
coq-amm11262,http://www.cs.ru.nl/~milad/AMM11262,"Formalisation of Tonny Hurkens' proof of the problem 11262 of The American Mathematical Monthly 113(10), Dec. 2006 (see the README files)","Milad Niqui (Coq files), Tonny Hurkens (paper proof)",00A08,True
coq-angles,https://github.com/coq-contribs/angles,"The basis of the contribution is a formalization of the theory of oriented angles of non-zero vectors. Then, we prove some classical plane geometry theorems: the theorem which gives a necessary and sufficient condition so that four points are cocyclic, the one which shows that the reflected points with respect to the sides of a triangle orthocenter are on its circumscribed circle, the Simson's theorem and the Napoleon's theorem. The reader can refer to the associated research report (http://www-sop.inria.fr/lemme/FGRR.ps) and the README file of the contribution.",Frédérique Guilhot,51Axx,True
coq-antivalence,https://github.com/ivanbakel/coq-antivalence,"Antivalence generates universally-quantified type inequality axioms, letting   you treat the set of inductive definitions in your program as a closed   inductive definition itself.",Isaac van Bakel,03F65,True
coq-approx-models,https://gitlab.inria.fr/amahboub/approx-models,"This is a Coq library to verify rigorous approximations of univariate functions on real numbers. Based on interval arithmetic, this library also implements a technique of validation a posteriori based on the Banach fixed-point theorem. We moreover provide an implementation of verified Chebyshev approximations.","Florent Bréhard, Assia Mahboubi, Damien Pous",03F65,True
coq-area-method,https://github.com/coq-contribs/area-method,"This contribution is the implementation of the Chou, Gao and Zhang's area method decision procedure for euclidean plane geometry. This development contains a partial formalization of the book ""Machine Proofs in Geometry, Automated Production of Readable Proofs for Geometry Theorems"" by Chou, Gao and Zhang. The examples shown automatically (there are more than 100 examples) includes the Ceva, Desargues, Menelaus, Pascal, Centroïd, Pappus, Gauss line, Euler line, Napoleon theorems. Changelog 2.1 : remove some not needed assumptions in some elimination lemmas (2010) 2.0 : extension implementation to Euclidean geometry (2009-2010) 1.0 : first implementation for affine geometry (2004)",Julien Narboux,51M04,True
coq-async-test,https://github.com/liyishuai/coq-async-test,From interaction trees to asynchronous tests.,Yishuai Li,68N19,True
coq-atbr,https://github.com/coq-community/atbr,"This library provides algebraic tools for working with binary relations. The main tactic provided is a reflexive tactic for solving (in)equations in an arbitrary Kleene algebra. The decision procedure goes through standard finite automata constructions.  Note that the initial authors consider this library to be superseded by the Relation Algebra library, which is based on derivatives rather than automata: https://github.com/damien-pous/relation-algebra","Thomas Braibant, Damien Pous",03G15,True
coq-automata,https://github.com/coq-contribs/automata,"This library formalises the beginning of formal language theory: finite automata and rational languages, context-free grammars and push-down automata.","Judicaël Courant, Jean-Christophe Filliâtre",03D05,True
coq-autosubst,https://github.com/coq-community/autosubst,"Autosubst is a library for the Coq proof assistant which provides automation for formalizing syntactic theories with variable binders. Given an inductive definition of syntactic objects in de Bruijn representation augmented with binding annotations, Autosubst synthesizes the parallel substitution operation and automatically proves the basic lemmas about substitutions.","Steven Schäfer, Tobias Tebbi",68N18,False
coq-axiomatic-abp,https://github.com/coq-contribs/axiomatic-abp,The Alternating Bit Protocol is expressed in an axiomatized calculi of process. Correctness is proven.,Jan Friso Groote,68M12,True
coq-bbv,https://github.com/mit-plv/bbv,An implementation of bitvectors in Coq.,"Tej Chajed, Haogang Chen, Adam Chlipala, Joonwon Choi, Andres Erbsen, Jason Gross, Samuel Gruetter, Frans Kaashoek, Alex Konradi, Gregory Malecha, Duckki Oe, Murali Vijayaraghavan, Nickolai Zeldovich, Daniel Ziegler",68W27,True
coq-bdds,https://github.com/coq-contribs/bdds,"Provides BDD algorithms running under Coq. (BDD are Binary Decision Diagrams.) Allows one to do classical validity checking by reflection in Coq using BDDs, can also be used to get certified BDD algorithms by extraction. First step towards actual symbolic model-checkers in Coq. See file README for operation.",Kumar Neeraj Verma,68Wxx,False
coq-bedrock2,https://github.com/mit-plv/bedrock2,A work-in-progress language and compiler for verified low-level programming,"Massachusetts Institute of Technology, Kevix, SiFive",None,False
coq-bellantonicook,https://github.com/davidnowak/bellantonicook,Deep embedding of Bellantoni and Cook's syntactic characterization of polytime functions,"Sylvain Heraud, David Nowak",68Q15,False
coq-bertrand,https://github.com/coq-community/bertrand,"A proof of correctness of the algorithm for computing prime numbers as described in ""The Art of Computer Programming: Fundamental Algorithms"" by Knuth, pp. 147-149, and an application using Bertrand's postulate.",Laurent Théry,11-xx,False
coq-bignums,https://github.com/coq/bignums,"Provides BigN, BigZ, BigQ that used to be part of Coq standard library < 8.6","Laurent Théry, Benjamin Grégoire, Arnaud Spiwack, Evgeny Makarov, Pierre Letouzey",NA,False
coq-bits,https://github.com/coq-community/bits,A formalization of bitset operations in Coq and the corresponding axiomatization and extraction to OCaml native integers,"Andrew Kennedy, Arthur Blot, Pierre-Évariste Dagand",68Q65,False
coq-buchberger,https://github.com/coq-community/buchberger,"A verified implementation of Buchberger's algorithm in Coq, which computes the Gröbner basis associated with a polynomial ideal. Also includes a constructive proof of Dickson's lemma.","Laurent Théry, Henrik Persson",06-xx,False
coq-bytestring,https://gitlab.com/bedrockpublic/coq-bytestring,A simple string library built around byte.,Gregory Malecha,68-04,True
coq-canon-bdds,https://github.com/coq-contribs/canon-bdds,A proof of unicity and canonicity of Binary Decision Trees and Binary Decision Dags. This contrib contains also a development on finite sets.,Emmanuel Ledinot,68Wxx,False
coq-cantor,https://github.com/coq-contribs/cantor,"Note: this package has been superseded by coq-hydra-battles.  This contribution contains data structures for ordinals less than Gamma0 under Cantor and Veblen normal forms. Well-foundedness is established thanks to RPO with status for generic terms. This contribution also includes termination proofs of Hydra battles and Goodstein sequences as well as a computation of the length of the Goodstein sequence starting from 4 in base 2.  This work is supported by INRIA-Futurs (Logical project-team), CNRS and the French ANR via the A3PAT project (http://www3.iie.cnam.fr/~urbain/a3pat/).","Pierre Castéran, Évelyne Contejean",03-xx,False
coq-cats-in-zfc,https://github.com/coq-contribs/cats-in-zfc,"In a ZFC-like environment augmented by reference to the ambient type theory, we develop some basic set theory, ordinals, cardinals and transfinite induction, and category theory including functors, natural transformations, limits and colimits, functor categories, and the theorem that functor_cat a b has (co)limits if b does.",Carlos Simpson,03Exx,False
coq-ccs,https://github.com/coq-contribs/ccs,We give the specification of three different notions of equivalence classically defined on labelled transitions systems underlying the theories of process algebra (and particularly CCS). The fundamentals properties of these equivalence notions are proven.,Solange Coupet-Grimal,68Q85,False
coq-cecoa,https://github.com/davidnowak/cecoa,Implicit-complexity Coq library to prove that some programs are computable in polynomial time,"Hugo Férée, Samuel Hym, Micaela Mayero, Jean-Yves Moyen, David Nowak",68Q15,False
coq-ceramist,https://github.com/certichain/ceramist,"Ceramist extends coq-infotheo to support reasoning about probabilistic algorithms,   and includes a collection of lemmas on random oracle based hash functions.    Provides an example implementation of a bloom filter and uses the library to prove   the probability of a false positive.","Kiran Gopinathan, Ilya Sergey",68Q65,False
coq-ceres,https://github.com/Lysxia/coq-ceres,Library for serialization to S-expressions,,None,False
coq-cfgv,http://www.nuprl.org/html/CFGVLFMTP2014/,Please read the following paper,"Abhishek, Vincent Rahli",68N18,False
coq-cfml,https://gitlab.inria.fr/charguer/cfml,A tool for proving OCaml programs in Separation Logic,,None,False
coq-chapar,https://github.com/coq-community/chapar,A framework for modular verification of causal consistency for replicated key-value store implementations and their client programs in Coq. Includes proofs of the causal consistency of two key-value store implementations and a simple automatic model checker for the correctness of client programs.,"Mohsen Lesani, Christian J. Bell, Adam Chlipala",68Q85,False
coq-charge-core,https://github.com/jesper-bengtson/ChargeCore,logics. Also includes definitions for separation algebras.,"Jesper Bengtson, Gregory Malecha",None,False
coq-checker,https://github.com/coq-contribs/checker,The Mutilated Checkerboard,Gérard Huet,00A08,True
coq-cheerios,https://github.com/uwplse/cheerios,A formally verified serialization library for Coq which defines a typeclass for serializable types and instances for many standard library types.,"Justin Adsuara, Karl Palmskog, Keith Simmons, James R. Wilcox, Doug Woos",68Q65,False
coq-chick-blog,https://github.com/clarus/coq-chick-blog,A blog engine written and proven in Coq,Guillaume Claret,None,False
coq-chinese,https://github.com/coq-contribs/chinese,OBSOLETE. See rather Zchinese-lemma that uses Z of Zarith.,Valérie Ménissier-Morain,11-xx,False
coq-circuits,https://github.com/coq-contribs/circuits,"definition and proof of a combinatorial adder, a sequential multiplier, a memory block instruction",Laurent Arditi,94Cxx,False
coq-classical-realizability,https://github.com/coq-contribs/classical-realizability,The aim of this Coq library is to provide a framework for checking proofs in Krivine's classical realizability for second-order Peano arithmetic.  It is designed to be as extensible as the original theory by Krivine and to support on-the-fly extensions by new instructions with their evaluation rules.,Lionel Rieg,03-xx,False
coq-coalgebras,https://github.com/coq-contribs/coalgebras,"This contribution contains a formalisation of coalgebras, bisimulation on coalgebras, weakly final coalgebras, lambda-coiteration definition scheme (including primitive corecursion) and a version of lambda-bisimulation. The formalisation is modular. The implementation of the module types for streams and potentially infinite Peano numbers are provided using the coinductive types.",Milad Niqui,18-xx,False
coq-coinduction,https://github.com/damien-pous/coinduction,"Coinductive predicates are greatest fixpoints of monotone functions. The `companion' makes it possible to enhance the associated coinduction scheme. This library provides a formalisation on enhancements based on the companion, as well as tactics in making it straightforward to perform proofs by enhanced coinduction.",Damien Pous,None,False
coq-coinductive-examples,https://github.com/coq-contribs/coinductive-examples,"This directory containts some simple examples about the use of co-inductive types in Coq. Directory ARITH is about non-standard arithmetic. Directory STREAMS contains examples about schemes, including an application of the translation method presented in Eduardo Giménez's article ``Codifying guarded definitions with recursive schemes'' (LNCS no. 996).",Eduardo Giménez,NA,False
coq-coinductive-reals,http://www.cs.ru.nl/~milad/ETrees/coinductive-field/,See the README file,Milad Niqui,03D78,False
coq-color,http://color.inria.fr/,A library on rewriting theory and termination,"Frédéric Blanqui, Adam Koprowski, Sébastien Hinderer, Pierre-Yves Strub, Sidi Ould Biha, Solange Coupet-Grimal, William Delobel, Hans Zantema, Stéphane Leroux, Léo Ducas, Johannes Waldmann, Qiand Wang, Lianyi Zhang, Sorin Stratulat",68wxx,False
coq-comp-dec-modal,https://github.com/coq-community/comp-dec-modal,"This project presents machine-checked constructive proofs of soundness, completeness, decidability, and the small-model property for the logics K, K*, CTL, and PDL (with and without converse).  For all considered logics, we prove soundness and completeness of their respective Hilbert-style axiomatization. For K, K*, and CTL, we also prove soundness and completeness for Gentzen systems (i.e., sequent calculi).  For each logic, the central construction is a pruning-based algorithm computing for a given formula either a satisfying model of bounded size or a proof of its negation. The completeness and decidability results then follow with soundness from the existence of said algorithm.",Christian Doczkal,03B45,False
coq-compcert,http://compcert.inria.fr/,The CompCert C compiler (64 bit),,68N20,False
coq-compcert-32,http://compcert.inria.fr/,"This package installs the 32 bit version of CompCert. For coexistence with the 64 bit version, the files are installed in: %{prefix}%/variants/compcert32/bin  (ccomp and clightgen binaries) %{prefix}%/variants/compcert32/lib/compcert  (C library) %{lib}%/coq-variant/compcert32/compcert (Coq library) Please note that the coq module path is compcert and not compcert32, so the files cannot be directly Required as compcert32. Instead -Q or -R options must be used to bind the compcert32 folder to the module path compcert. This is more convenient if one development supports both 32 and 64 bit versions. Otherwise all files would have to be duplicated with module paths compcert and compcert32. Please also note that the binary folder is usually not in the path.",,68N20,False
coq-compcert-64,http://compcert.inria.fr/,"This package installs the 64 bit version of CompCert. For coexistence with the 32 bit version, the files are installed in: %{prefix}%/variants/compcert64/bin  (ccomp and clightgen binaries) %{prefix}%/variants/compcert64/lib/compcert  (C library) %{lib}%/coq/user-contrib/compcert64  (Coq library) Please note that the coq module path is compcert and not compcert64, so the files cannot be directly Required as compcert64. Instead -Q or -R options must be used to bind the compcert64 folder to the module path compcert. This is more convenient if one development uses both 32 and 64 bit versions. Otherwise all files would have to be duplicated with module paths compcert and compcert64. Please also note that the binary folder is usually not in the path.",,68N20,False
coq-concat,http://logical.inria.fr/~saibi/docCatV6.ps,Constructive Category Theory,Amokrane Saïbi,18-xx,False
coq-concurrency-pluto,https://github.com/coq-concurrency/pluto,A web server written in Coq,Guillaume Claret,None,False
coq-concurrency-proxy,https://github.com/coq-concurrency/proxy,A proxy to interface concurrent Coq programs with the operating system,Guillaume Claret,None,False
coq-concurrency-system,https://github.com/coq-concurrency/system,Experimental library to write concurrent applications in Coq,Guillaume Claret,None,False
coq-constructive-geometry,https://github.com/coq-contribs/constructive-geometry,Constructive Geometry following Jan von Plato.,Gilles Kahn,51-xx,False
coq-constructors,https://github.com/mattam82/Constructors,"An example Coq plugin, defining a tactic to get the constructors of an inductive type in a list",,None,False
coq-containers,https://github.com/coq-contribs/containers,"This is a reimplementation of the FSets/FMaps library from the standard library, using typeclasses. See tests files for usage. A new vernacular command is provided by Generate.v and the plugin to automatically generate ordered types for user-defined inductive types.",Stéphane Lescuyer,68Q65,False
coq-continuations,https://github.com/coq-contribs/continuations,"We show a way of developing correct functionnal programs raising exceptions. This is made possible using a Continuation Passing Style translation, see the contribution ""exceptions"" from P. Casteran at Bordeaux. Things are made easier and more modular using some general definitions.",Jean-François Monin,68Q55,False
coq-coq-in-coq,https://github.com/coq-contribs/coq-in-coq,A formalisation of the Calculus of Construction,Bruno Barras,03B38,False
coq-coq2html,https://github.com/xavierleroy/coq2html,Generates HTML documentation from Coq source files.  Alternative to coqdoc,,68V35,True
coq-coqeal,https://github.com/CoqEAL/coqeal,"This libary contains a subset of the work that was developed in the context of the ForMath european project (2009-2013). It has two parts: - theory (module CoqEAL_theory), which contains formal developments in algebra and optimized algorithms on mathcomp data structures. - refinements (module CoqEAL_refinements), which is a framework to ease change of data representation during a proof.","Guillaume Cano, Cyril Cohen, Maxime Dénès, Anders Mörtberg, Damien Rouhling, Vincent Siles",68Wxx,False
coq-coqeal-refinements,http://www.maximedenes.fr/content/coqeal-coq-effective-algebra-library,A refinement framework (for algebra),,None,False
coq-coqeal-theory,http://www.maximedenes.fr/content/coqeal-coq-effective-algebra-library,The theory needed by the refinement framework library,,None,False
coq-coqffi,https://github.com/coq-community/coqffi,"`coqffi` generates the necessary Coq boilerplate to use OCaml functions in a Coq development, and configures the Coq extraction mechanism accordingly.","Thomas Letan, Li-yao Xia, Yann Régis-Gianas, Yannick Zakowski",NA,False
coq-coqoban,https://github.com/coq-community/coqoban,"A Coq implementation of Sokoban, the Japanese warehouse keepers' game.","Jasper Stein, Hugo Herbelin",00A08,True
coq-coqprime,https://github.com/thery/coqprime,Certifying prime numbers in Coq,Laurent Théry,None,False
coq-coqrel,https://github.com/CertiKOS/coqrel,Binary logical relations library for the Coq proof assistant,Jérémie Koenig,03B38,False
coq-coqtail,https://github.com/coq-community/coqtail-math,Coqtail is a library of mathematical theorems and tools proved inside the Coq proof assistant. Results range mostly from arithmetic to real and complex analysis.,"Guillaume Allais, Sylvain Dailler, Hugo Férée, Jean-Marie Madiot, Pierre-Marie Pédrot, Amaury Pouly",14Pxx,False
coq-coquelicot,http://coquelicot.saclay.inria.fr/,A Coq formalization of real analysis compatible with the standard library,"Sylvie Boldo, Catherine Lelay, Guillaume Melquiond",14Pxx,False
coq-coqutil,https://github.com/mit-plv/coqutil,"### coqutil -- Various Coq Utilities  Contents: * [Datatypes](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Datatypes): Some utilities for existing datatypes, and new datatypes. * [Decidable](https://github.com/mit-plv/coqutil/blob/master/src/coqutil/Decidable.v): `BoolSpec`-based decidability typeclasses. Allows one to write `if MyType_eqb a b then ... else ...` where `MyType_eqb a b` returns a `bool`, instead of writing `if MyType_eq_dec a b then ... else ...` where `MyType_eq_dec a b` returns a `sumbool`, while still getting `a = b` and `a <> b` as hypotheses (as opposed to `MyType_eqb a b = true` and `MyType_eqb a b = false`) after destructing the `if` (need to use [`destr`](https://github.com/mit-plv/coqutil/blob/master/src/coqutil/Tactics/destr.v) instead of `destruct`). So one gets the benefits of `Sumbool` without getting its disadvantage of having to carry around proof terms, which can cause a blow-up under reduction if one is not careful. * [Map](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Map): A typeclass based map library allowing one to abstract over the concrete implementation of maps. The implementations have to be extensional, which excludes certain efficient implementations, but simplifies proofs, because one can `replace mapA with mapB` if one can prove that `mapA` and `mapB` have the same contents. Comes with a [solver](https://github.com/mit-plv/coqutil/blob/master/src/coqutil/Map/Solver.v) which works reasonably fast on most map goals we have encountered so far. * [Tactics](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Tactics): A collection of useful general-purpose tactics. * [Word](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Word): Fixed width words for any width, in the same typeclass based style as the map library. Designed for the case where all words have the same (potentially abstract) bit width. Therefore, it does not provide functions to concatenate and split words, which is better addressed by [bbv](https://github.com/mit-plv/bbv/). * [Z](https://github.com/mit-plv/coqutil/tree/master/src/coqutil/Z): Utilities to work with the `Z` type from Coq's standard library, including a tactic to prove `Z` equalities by splitting the equality into equalities on bit index ranges, a tactic to make `lia` capable of reasoning about goals with division and modulo, and a tactic to simplify expressions containing nested occurrences of `mod`, and more misc utilities. * Various macros, notations, and desirable default settings.  Each feature is intended to be as minimal and as independent of the other features as possible, so that users can pick just what they need.",Massachusetts Institute of Technology,None,False
coq-corn,https://github.com/coq-community/corn,"CoRN includes the following parts:  - Algebraic Hierarchy    An axiomatic formalization of the most common algebraic   structures, including setoids, monoids, groups, rings,   fields, ordered fields, rings of polynomials, real and   complex numbers  - Model of the Real Numbers    Construction of a concrete real number structure   satisfying the previously defined axioms  - Fundamental Theorem of Algebra    A proof that every non-constant polynomial on the complex   plane has at least one root  - Real Calculus    A collection of elementary results on real analysis,   including continuity, differentiability, integration,   Taylor's theorem and the Fundamental Theorem of Calculus  - Exact Real Computation    Fast verified computation inside Coq. This includes: real numbers, functions,   integrals, graphs of functions, differential equations.","Evgeny Makarov, Robbert Krebbers, Eelis van der Weegen, Bas Spitters, Jelle Herold, Russell O'Connor, Cezary Kaliszyk, Dan Synek, Luís Cruz-Filipe, Milad Niqui, Iris Loeb, Herman Geuvers, Randy Pollack, Freek Wiedijk, Jan Zwanenburg, Dimitri Hendriks, Henk Barendregt, Mariusz Giero, Rik van Ginneken, Dimitri Hendriks, Sébastien Hinderer, Bart Kirkels, Pierre Letouzey, Lionel Mamane, Nickolay Shmyrev, Vincent Semeria",06-xx,False
coq-counting,https://github.com/coq-contribs/counting,This plugin keeps the count of the size of definitions and proofs in the current Coq session.,Stéphane Lescuyer,NA,False
coq-cours-de-coq,https://github.com/coq-contribs/cours-de-coq,Various simple examples of Coq proofs,"Frédéric Prost, Gilles Kahn",NA,False
coq-ctltctl,https://github.com/coq-contribs/ctltctl,This library formalises two logics for reasoning about reactive systems (CTL) and real time systems (TCTL) represents using timed automatas (timed graphs) with discrete time. http://www.fing.edu.uy/~cluna,Carlos Daniel Luna,03B45,False
coq-cunit,https://github.com/clarus/coq-cunit,Convenience functions for unit testing in Coq,Guillaume Claret,None,False
coq-cybele,https://github.com/clarus/cybele,A Coq plugin for simpler proofs by reflection or OCaml certificates,Guillaume Claret,None,False
coq-dblib,https://github.com/coq-contribs/dblib,http://gallium.inria.fr/~fpottier/dblib/README  The dblib library offers facilities for working with de Bruijn indices.,Francois Pottier,68N18,False
coq-demos,https://github.com/coq-contribs/demos,Example of sorting algorithms defined using the Cases (pattern-matching) construction. Demo of the decision tactic Tauto for intuitionistic propositional calculus. Demo of the AutoRewrite tactic. Demo of the Prolog tactic applied to the compilation of miniML programs.,Coq group,NA,False
coq-dep-map,https://github.com/coq-contribs/dep-map,A rudimentary library for dependent maps that contain their domain in the type.,Lionel Rieg,68Q65,False
coq-deriving,https://github.com/arthuraa/deriving,"Deriving provides generic instances of MathComp classes for inductive data types.  It includes native support for eqType, choiceType, countType and finType instances, and it allows users to define their own instances for other classes.",Arthur Azevedo de Amorim,68Q65,False
coq-descente-infinie,https://github.com/coq-contribs/descente-infinie,This is a tactic plugin for coq. The tactic helps to prove inductive lemmas by fixpoint functions. A manual for the tactic can be found on its homepage listed above.,"Razvan Voicu, Li Mengran",NA,False
coq-dictionaries,https://github.com/coq-contribs/dictionaries,"This file contains a specification for dictionaries, and an implementation using binary search trees. Coq's module system, with module types and functors, is heavily used. It can be considered as a certified version of an example proposed by Paulson in Standard ML. A detailed description (in French) can be found in the chapter 11 of The Coq'Art, the book written by Yves Bertot and Pierre Castéran (please follow the link http://coq.inria.fr/doc-eng.html)",Pierre Castéran,68Q65,False
coq-dijkstra,https://github.com/fetburner/coq-dijkstra,A Verified Implementation of Dijkstra's Algorithm,Masayuki Mizuno,05Cxx	,False
coq-disel,https://github.com/DistributedComponents/disel,"Disel is a framework for implementation and compositional verification of distributed systems and their clients in Coq. In Disel, users implement distributed systems using a domain specific language shallowly embedded in Coq which provides both high-level programming constructs as well as low-level communication primitives. Components of composite systems are specified in Disel as protocols, which capture system-specific logic and disentangle system definitions from implementation details.","Ilya Sergey, James R. Wilcox",68Q85,False
coq-disel-examples,https://github.com/DistributedComponents/disel,"Example systems for Disel, a separation-style logic for compositional verification of distributed systems in Coq","Ilya Sergey, James R. Wilcox",68Q85,False
coq-distributed-reference-counting,https://github.com/coq-contribs/distributed-reference-counting,This library contains the constructive proof of correctness of several variants of a distributed reference counting algorithm.,"Luc Moreau, Jean Duprat",68N20,False
coq-domain-theory,https://github.com/coq-contribs/domain-theory,Domain theory as devised by Scott and Plotkin and following Kahn and Plotkin paper on Concrete Domains,Gilles Kahn,68N18,False
coq-dpdgraph,https://github.com/karmaki/coq-dpdgraph,"Compute dependencies between Coq objects (definitions, theorems) and produce graphs","Anne Pacalet, Yves Bertot",None,False
coq-elpi,https://github.com/LPCIC/coq-elpi,"Coq-elpi provides a Coq plugin that embeds ELPI. It also provides a way to embed Coq's terms into λProlog using the Higher-Order Abstract Syntax approach and a way to read terms back.  In addition to that it exports to ELPI a set of Coq's primitives, e.g. printing a message, accessing the environment of theorems and data types, defining a new constant and so on. For convenience it also provides a quotation and anti-quotation for Coq's syntax in λProlog.  E.g. `{{nat}}` is expanded to the type name of natural numbers, or `{{A -> B}}` to the representation of a product by unfolding  the `->` notation. Finally it provides a way to define new vernacular commands and new tactics.",Enrico Tassi,None,False
coq-engine-bench,https://github.com/mit-plv/engine-bench,Collection of benchmarks for the proof engine,"Jason Gross, Andres Erbsen, Massachusetts Institute of Technology",None,False
coq-engine-bench-lite,https://github.com/mit-plv/engine-bench,Collection of benchmarks for the proof engine (lite version),"Jason Gross, Andres Erbsen, Massachusetts Institute of Technology",None,False
coq-equations,https://mattam82.github.io/Coq-Equations,"Equations is a function definition plugin for Coq, that allows the definition of functions by dependent pattern-matching and well-founded, mutual or nested structural recursion and compiles them into core terms. It automatically derives the clauses equations, the graph of the function and its associated elimination principle.","Matthieu Sozeau, Cyprien Mangin",NA,False
coq-ergo,https://github.com/coq-contribs/ergo,This library provides a tactic that performs SMT solving (SAT + congruence closure + arithmetic).,Stéphane Lescuyer,68Wxx,False
coq-error-handlers,https://github.com/clarus/coq-error-handlers,Simple and robust error handling functions,Guillaume Claret,None,False
coq-euclidean-geometry,https://github.com/coq-contribs/euclidean-geometry,"This is a more recent version of the basis of Euclid's plane geometry, the previous version was the contribution intitled RulerCompassGeometry. The plane geometry is defined as a set of points, with two predicates : Clokwise for the orientation and Equidistant for the metric and three constructors, Ruler for the lines, Compass for the circles and Intersection for the points. For using it, we suggest to compile the files the name of which begin by a capital letter and a number from A1 to N7 in the lexicographic order and to keep modifiable the files of tacics (from Tactic1 to Tactic4) and the files of examples (Hilbert and Bolyai).",Jean Duprat,51M05,True
coq-euler-formula,https://github.com/coq-contribs/euler-formula,This library formalizes the combinatorial hypermaps and their properties in a constructive way. It gives the proofs of the Genus Theorem and of the Euler Formula for the polyhedra.,Jean-François Dufourd,52-xx,False
coq-exact-real-arithmetic,https://github.com/coq-contribs/exact-real-arithmetic,This contribution contains a proof of correctness of some exact real arithmetic algorithms from the PhD thesis of Valérie Ménissier-Morain,Jérôme Creci,03D78,False
coq-exceptions,https://github.com/coq-contribs/exceptions,"Pro[gramm,v]ing with continuations:A development in Coq",Pierre Castéran,68Q55,False
coq-ext-lib,https://github.com/coq-community/coq-ext-lib,A collection of theories and plugins that may be useful in other Coq developments.,Gregory Malecha,None,False
coq-extensible-records,https://github.com/gmalecha/coq-extensible-records,Definitional (canonical) extensible records in Coq with string keys and arbitrary (non-dependent) types,Gregory Malecha,None,False
coq-extructures,https://github.com/arthuraa/extructures,"Finite sets, maps, and other data structures with extensional reasoning",Arthur Azevedo de Amorim,68Q65,False
coq-fairisle,http://www.dil.univ-mrs.fr/~jakubiec/fairisle.tar.gz,This library contains the development of general definitions dedicated to the verification of sequential synchronous devices (based on Moore and Mealy automata) and the formal verification of the Fairisle 4x4 Switch Element.,"Solange Coupet-Grimal, Line Jakubiec-Jamet",94Cxx,False
coq-fcsl-pcm,http://software.imdea.org/fcsl/,"The PCM library provides a formalisation of Partial Commutative Monoids (PCMs), a common algebraic structure used in separation logic for verification of pointer-manipulating sequential and concurrent programs. The library provides lemmas for mechanised and automated reasoning about PCMs in the abstract, but also supports concrete common PCM instances, such as heaps, histories and mutexes.  This library relies on extensionality axioms: propositional and functional extentionality.",Aleksandar Nanevski,68Q65,False
coq-fermat4,https://github.com/coq-contribs/fermat4,"This contribution presents the formalization of Fermat's proofs of Diophantus' 20th Problem and Fermat's Last Theorem for n = 4. The proofs are completed using Fermat's ""wonderful"" method of infinite descent.","David Delahaye, Micaela Mayero",11-xx,False
coq-fiat-core,http://plv.csail.mit.edu/fiat/,Coq library for synthesizing efficient correct-by-construction programs from declarative specifications.,"Adam Chlipala, Benjamin Delaware, Clément Pit-Claudel, Jason Gross",None,False
coq-fiat-crypto,https://github.com/mit-plv/fiat-crypto,Cryptographic Primitive Code Generation by Fiat.,"Andres Erbsen, Google Inc., Jade Philipoom, Massachusetts Institute of Technology, Zoe Paraskevopoulou",None,False
coq-fiat-crypto-legacy,https://github.com/mit-plv/fiat-crypto,Cryptographic Primitive Code Generation in Fiat (legacy pipeline).,"Andres Erbsen, Google Inc., Jade Philipoom, Massachusetts Institute of Technology",None,False
coq-fiat-crypto-legacy-extra,https://github.com/mit-plv/fiat-crypto,Cryptographic Primitive Code Generation in Fiat (legacy pipeline + many large examples).,"Andres Erbsen, Google Inc., Jade Philipoom, Massachusetts Institute of Technology",None,False
coq-fiat-parsers,http://plv.csail.mit.edu/fiat/,Mostly automated synthesis of correct-by-construction programs.,"Adam Chlipala, Benjamin Delaware, Clément Pit-Claudel, Jason Gross",None,False
coq-finger-tree,http://mattam.org/research/russell/fingertrees.en.html,A verified generic implementation of Finger Trees,Matthieu Sozeau,68Q65,False
coq-firing-squad,https://github.com/coq-contribs/firing-squad,This contribution is a formal verification of a solution of the firing squad synchronization problem.,Jean Duprat,68Q80,True
coq-float,https://github.com/coq-contribs/float,A library for floating-point numbers.,"Laurent Théry, Sylvie Boldo",68Q65,False
coq-flocq,https://flocq.gitlabpages.inria.fr/,A formalization of floating-point arithmetic for the Coq system,"Sylvie Boldo, Guillaume Melquiond",None,False
coq-flocq-quickchick,https://github.com/digamma-ai/flocq-quickchick,Flocq binary_float generators for QuickChick testing framework,,None,False
coq-formal-topology,https://github.com/bmsherman/topology,A programming language for topology and probability in Coq.,Ben Sherman,None,False
coq-founify,https://github.com/coq-contribs/founify,"A notion of terms based on symbols without fixed arities is defined and an extended unification problem is proved solvable on these terms. An algorithm, close from Robinson algorithm, can be extracted from the proof.",Jocelyne Rouyer,68Wxx,False
coq-fourcolor,https://math-comp.github.io,"Proof of the Four Color Theorem  This library contains a formalized proof of the Four Color Theorem, along with the theories needed to support stating and then proving the Theorem.   This includes an axiomatization of the setoid of classical real numbers, basic plane topology definitions, and a theory of combinatorial hypermaps.",Georges Gonthier,None,False
coq-fpmods,http://perso.crans.org/cohen/work/fpmods/,A short constructive formalization of finitely presented modules,,None,False
coq-free-groups,https://github.com/coq-contribs/free-groups,"This small contribution is a formalization of van der Waerden's proof of the construction of a free group on a set of generators, as the reduced words where a letter is a generator or its formal inverse.",Daniel Schepler,06-xx,False
coq-freespec-core,https://github.com/lthms/FreeSpec,"FreeSpec is a framework for the Coq proof assistant which allows to implement and specify impure computations. This is the core of the framework: it provides the foundation of the formalism, based on the freer monad, the reasoning theory and tactics to automate the reasoning.","Thomas Letan, Yann Régis-Gianas",18-xx,False
coq-freespec-exec,https://github.com/lthms/FreeSpec,"FreeSpec is a framework for the Coq proof assistant which allows to implement and specify impure computations. This is the “exec” plugin, which allows from executing impure computations from with Coq thanks to a dedicated vernacular command.","Thomas Letan, Yann Régis-Gianas",NA,False
coq-freespec-ffi,https://github.com/lthms/FreeSpec,FreeSpec is a framework for the Coq proof assistant which allows to implement and specify impure computations. It can be used with coqffi to write certified software.,"Thomas Letan, Yann Régis-Gianas",NA,False
coq-fsets,https://github.com/coq-contribs/fsets,"This contribution contains several implementations of finite sets over arbitrary ordered types using functors. Currently, there are 3 implementations: sorted lists, red-black trees and AVLs.","Pierre Letouzey, Jean-Christophe Filliâtre",68Q65,False
coq-fssec-model,https://github.com/coq-contribs/fssec-model,"Formal verification of an extension of a UNIX compatible, secure filesystem",Maximiliano Cristiá,68N25,False
coq-function-ninjas,https://github.com/clarus/coq-function-ninjas,Simple functional combinators,Guillaume Claret,None,False
coq-functional-algebra,https://github.com/llee454/functional-algebra,"a functional programming style. The modules contained within the  package span monoids, groups, rings, and fields and provides both  axiom definitions for these structures and proofs of foundational  results. The current package contains over 800 definitions and  proofs.  This module is unique in that it eschews the tactic-oriented style of traditional Coq developments. As pointed out by others, programs written in that style are brittle, hard to read, and generally inefficient.  While tactic driven development is useful for sketching out proofs, these disadvantages should dissuade us from publising proofs in this form.  In this library, I provide a worked example of using Gallina directly and demonstrate both the feasibility of this approach and its advantages in terms of clarity, maintainability, and compile-time efficiency.  In addition, this module includes two expression simplifiers. The first, defined in monoid_expr.v simplifies monoid expressions. The second, defined in group_expr.v simplifies group expressions.  These functions allow us to automate many of the steps involved in proving algebraic theorems directly in Gallina, and represent an alternative to relying on tactics such as auto, omega, etc.  For more information about this package, please read its Readme file, which can be found here:  https://github.com/llee454/functional-algebra.",Larry D. Lee Jr.,NA,False
coq-functions-in-zfc,https://github.com/coq-contribs/functions-in-zfc,"This mostly repeats Guillaume Alexandre's contribution `zf', but in classical logic and with a different proof style. We start with a simple axiomatization of some flavor of ZFC (for example Werner's implementation of ZFC should provide a model). We develop some very basic things like pairs, functions, and a little bit about natural numbers, following the standard classical path.",Carlos Simpson,03Exx,False
coq-fundamental-arithmetics,http://perso.ens-lyon.fr/sebastien.briais/tools/Arith_080201.tar.gz,Fundamental theorems of arithmetic,Sébastien Briais,11-xx,False
coq-gaia,https://github.com/coq-community/gaia,"Implementation of books from N. Bourbaki's Elements of Mathematics in Coq using the Mathematical Components library, including set theory and number theory.","José Grimm, Alban Quadrat, Carlos Simpson",03Exx,False
coq-gaia-hydras,https://github.com/coq-community/hydra-battles,The Gaia and Hydra battles projects develop different notions of ordinals. This development bridges the different notions.,Pierre Castéran,03-xx,False
coq-games,,A library for algorithmic game theory in Ssreflect/Coq,"Alexander Bagnall, Samuel Merten, Gordon Stewart",05-xx,False
coq-gappa,https://gappa.gitlabpages.inria.fr/,A Coq tactic for discharging goals about floating-point arithmetic and round-off errors using the Gappa prover,Guillaume Melquiond,68Wxx,False
coq-gc,https://github.com/coq-contribs/gc,"We specify an incremental garbage collection algorithm and we give a formal proof of its correctness. The algorithm is represented as an infinite transition system and we establish safety and liveness properties. This work relies on an axiomatization of LTL and is based on a co-inductive representation of programs executions. Although motivated by integrating the dynamic memory management to the Java Card platform, this study applies more generally to real-time embedded systems and to devices with virtually infinite memory.",Solange Coupet-Grimal and Catherine Nouvet,68N20,False
coq-generic-environments,https://github.com/coq-community/generic-environments,"Generic Environments is a library which provides an abstract data type of environments, as a functor parameterized by a module defining variables, and a function which builds environments for such variables with any Type of type. Usual operations over environments are defined, along with an extensive set of basic and more advanced properties. Moreover, an implementation using lists satisfying and all the required properties is provided.",Emmanuel Polonowski,03B38,False
coq-geocoq,http://geocoq.github.io/GeoCoq/,This package depends on all subpackages.,"Michael Beeson, Gabriel Braun, Pierre Boutry, Cyril Cohen, Charly Gries, Julien Narboux, Pascal Schreck, Freek Wiedijk",51-xx,False
coq-geocoq-axioms,http://geocoq.github.io/GeoCoq/,This subpackage contains the axioms.,"Michael Beeson, Gabriel Braun, Pierre Boutry, Charly Gries, Julien Narboux, Pascal Schreck",51-xx,False
coq-geocoq-coinc,http://geocoq.github.io/GeoCoq/,This subpackage contains some tactics to deal with incidence properties.,"Pierre Boutry, Julien Narboux, Pascal Schreck",51-xx,False
coq-geocoq-elements,http://geocoq.github.io/GeoCoq/,This subpackage contains a formalization of Euclid's proofs from Book I of the Elements.,"Michael Beeson, Julien Narboux, Freek Wiedijk",51-xx,False
coq-geocoq-main,http://geocoq.github.io/GeoCoq/,This subpackage contains the main developments from Hilbert's and Tarski's axiom systems.,"Gabriel Braun, Pierre Boutry, Charly Gries, Julien Narboux, Pascal Schreck",51-xx,False
coq-geocoq-pof,http://geocoq.github.io/GeoCoq/,This subpackage contains a model of Tarski's axioms.,"Pierre Boutry, Cyril Cohen",51-xx,False
coq-geometric-algebra,https://github.com/thery/GeometricAlgebra,Grassman Cayley and Clifford formalisations,,None,False
coq-giskard,https://github.com/runtimeverification/giskard-verification,"The Giskard consensus protocol is used to validate transactions and computations in the PlatON network. This project provides a model of Giskard in Coq, and formally proves several key safety properties of the protocol.","Elaine Li, Karl Palmskog, Mircea Sebe",68Q85,False
coq-goedel,https://github.com/coq-community/goedel,"A proof in Coq of the Gödel-Rosser 1st incompleteness theorem, which says that any first order theory extending NN (which is PA without induction) that is complete is inconsistent.",Russell O'Connor,03F40,True
coq-graph-basics,https://github.com/coq-contribs/graph-basics,"This library offers inductive definitions of basics in graph theory. The goal is to offer the possibility to write proofs and programs on graphs in the same formalism : the Coq language. It now contains : vertices, arcs, edges, degrees, graphs, directed graphs, paths, acyclic graphs, connected graphs and tree.",Jean Duprat,05-xx,False
coq-graph-theory,https://github.com/coq-community/graph-theory,"A library of formalized graph theory results, including various standard results from the literature (e.g., Menger’s Theorem, Hall’s Marriage Theorem, and the excluded minor characterization of treewidth-two graphs) as well as some more recent results arising from the study of relation algebra within the ERC CoVeCe project (e.g., soundness and completeness of an axiomatization of graph isomorphism).","Christian Doczkal, Damien Pous",05Cxx	,False
coq-graphs,https://github.com/coq-contribs/graphs,*******************************************************************,Jean Goubault,68Wxx,False
coq-group-theory,https://github.com/coq-contribs/group-theory,"Group Theory following the book ""Group Theory"" from W.R. Scott.",Gilles Kahn,06-xx,False
coq-groups,https://github.com/coq-contribs/groups,An exercise on groups,Pierre Castéran,NA,False
coq-hammer,https://github.com/lukaszcz/coqhammer,A general-purpose automated reasoning hammer tool for Coq that combines learning from previous proofs with the translation of problems to the logics of automated systems and the reconstruction of successfully found proofs.,"Lukasz Czajka, Cezary Kaliszyk",68V15,True
coq-hammer-tactics,https://github.com/lukaszcz/coqhammer,"Collection of tactics that are used by the hammer for Coq to reconstruct proofs found by automated theorem provers. When the hammer has been successfully applied to a project, only this package needs to be installed; the hammer plugin is not required.",Lukasz Czajka,68V15,True
coq-hardware,https://github.com/coq-contribs/hardware,"Verification and synthesis of hardware linear arithmetic structures. Example of a left-to-right comparator. Three approaches are tackled : - the usual verification of a circuit, consisting in proving that the description satisfies the specification, - the synthesis of a circuit from its specification using the Coq extractor, - the same approach as above but using the Program tactic.",Solange Coupet-Grimal & Line Jakubiec,94Cxx,False
coq-hedges,https://github.com/coq-contribs/hedges,"These properties are in section 6.1 of the paper    ""On Bisimulations for the Spi-Calculus"" by J. Borgström    and U. Nestmann.    However, we consider here an extended message language.",Sébastien Briais,68Q85,False
coq-hierarchy-builder,https://github.com/math-comp/hierarchy-builder,"Hierarchy Builder is a high level language to build hierarchies of algebraic structures and make these hierarchies evolve without breaking user code. The key concepts are the ones of factory, builder and abbreviation that let the hierarchy developer describe an actual interface for their library. Behind that interface the developer can provide appropriate code to ensure retro compatibility.","Cyril Cohen, Kazuhiko Sakaguchi, Enrico Tassi",None,False
coq-hierarchy-builder-shim,https://github.com/math-comp/hierarchy-builder,This package provide the support constants one can use to compile files generated by HB.,"Cyril Cohen, Kazuhiko Sakaguchi, Enrico Tassi",None,False
coq-high-school-geometry,https://github.com/coq-community/HighSchoolGeometry,This Coq library is dedicated to high-shool geometry teaching. The axiomatisation for affine Euclidean space is in a non analytic setting. Includes a proof of Ptolemy's theorem.,"Frédérique Guilhot, Tuan-Minh Pham",51-xx,False
coq-higman-cf,https://github.com/coq-contribs/higman-cf,This development formalizes in Coq the Coquand-Friedlender proof of Higman's lemma for a two-letter alphabet. An efficient program can be extracted from the proof.,Stefan Berghofer,05-xx,False
coq-higman-nw,https://github.com/coq-contribs/higman-nw,The file Higman.v formalizes an A-translated version of Nash-Williams impredicative and classical proof of Higman's lemma for a two-letter alphabet. A constructive and impredicative program can be extracted from the proof.,Hugo Herbelin,03-xx,False
coq-higman-s,https://github.com/coq-contribs/higman-s,"This proof is more or less the proof given by Monika Seisenberger in ""An Inductive Version of Nash-Williams' Minimal-Bad-Sequence Argument for Higman's Lemma"".",William Delobel,05-xx,False
coq-historical-examples,https://github.com/coq-contribs/historical-examples,"This is a collection of historical examples developed in system CoC that implemented Coquand's Calculus of Constructions. Newman.v and Tarski.v originate in version 1.10, Manna.v and Format.v are from version 4.3. Their evolution to the Calculus of Inductive Constructions (up to Coq V6.3) are in MannaCIC.v and FormatCIC.v. (Collection by Hugo Herbelin.)","Gérard Huet, Christine Paulin",NA,False
coq-hoare-tut,https://github.com/coq-community/hoare-tut,"Hoare logics are ""program logics"" suitable for reasoning about imperative programs. This work is both an introduction to Hoare logic and a demo illustrating Coq nice features. It formalizes the generation of PO (proof obligations) in a Hoare logic for a very basic imperative programming language. It proves the soundness and the completeness of the PO generation both in partial and total correctness. At last, it examplifies on a very simple example (a GCD computation) how the PO generation can simplify concrete proofs. Coq is indeed able to compute PO on concrete programs: we say here that the generation of proof obligations is reflected in Coq. Technically, the PO generation is here performed through Dijkstra's weakest-precondition calculus.",Sylvain Boulmé,68N15,True
coq-hott,http://homotopytypetheory.org/,"To use the HoTT library, the following flags must be passed to coqc:    -noinit -indices-matter To use the HoTT library in a project, add the following to _CoqProject:    -arg -noinit    -arg -indices-matter",The Coq-HoTT Development Team,None,False
coq-http,https://github.com/liyishuai/coq-http,"HTTP specification in Coq, testable and verifiable","Yishuai Li, Li-yao Xia, Yao Li, Azzam Althagafi, Benjamin C. Pierce",68M12,True
coq-huffman,https://github.com/coq-community/huffman,"This projects contains a Coq proof of the correctness of the Huffman coding algorithm, as described in David A. Huffman's paper A Method for the Construction of Minimum-Redundancy Codes, Proc. IRE, pp. 1098-1101, September 1952.",Laurent Théry,68Wxx,False
coq-hydra-battles,https://github.com/coq-community/hydra-battles,"An exploration of some properties of Kirby and Paris' hydra battles, with the help of the Coq Proof assistant. This development includes the study of several representations of ordinal numbers, and a part of the so-called Ketonen and Solovay machinery (combinatorial properties of epsilon0).",Pierre Castéran,05-xx,False
coq-icharate,http://www.labri.fr/perso/anoun/Icharate,"The logical toolkit ICHARATE is built upon a formalization of multimodal categorial grammars in Coq proof assistant. This toolkit aims at facilitating the study of these complicated formalisms by allowing users to build interactively the syntactic derivations of different sentences, compute their semantic interpretations and also prove universal properties of entire classes of grammars using a collection of already established derived rules. Several tactics are defined to ease the interaction with users.","Houda Anoun, Pierre Casteran",68Q45,False
coq-idxassoc,https://github.com/coq-contribs/idxassoc,"We define the associative array (key -> value associations) datatype as list of couples, providing definitions of standards operations such as adding, deleting.  We introduce predicates for membership of a key and of couples.  Finally we define a search operator (""find"") which returns the value associated with a key or the ""none"" option (see file Option.v which should be part of this contribution) on failure.  Lemmas we prove about these concepts were motivated by our needs at the moment we created this file. We hope they'll suit your needs too but anyway, feel free to communicate any wish or remark.","Dominique Quatravaux, François-René Ridaux, Gérald Macinenti",68Q65,False
coq-ieee754,https://github.com/coq-contribs/ieee754,"This library contains a non-verified implementation of binary floating-point addition and multiplication operators inspired by the IEEE-754 standard. It is today outdated.  See the attached 1997 report rapport-stage-dea.ps.gz for a discussion (in French) of this work.  For the state of the art at the time of updating this notice, see e.g. ""Flocq: A Unified Library for Proving Floating-point Algorithms in Coq"" by S. Boldo and G. Melquiond, 2011.",Patrick Loiseleur,68Q65,False
coq-improper-integrals,https://github.com/ybertot/improper_integrals,"This package contains a few theorems whose use case was discovered when making experiments, for instance in the pi-agm package.  These theorems should probably integrated in coquelicot in the long run, but having this package makes them easily available while waiting for any necessary cleanup and discussion to happen.",Yves Bertot,14Pxx,False
coq-inf-seq-ext,https://github.com/DistributedComponents/InfSeqExt,"A Coq library for reasoning inductively and coinductively on infinite sequences, using modal operators similar to those in linear temporal logic (LTL).","Yuxin Deng, Jean-Francois Monin, Karl Palmskog, Ryan Doenges",03B45,False
coq-infotheo,https://github.com/affeldt-aist/infotheo,"Infotheo is a Coq library for reasoning about discrete probabilities, information theory, and linear error-correcting codes.","Reynald Affeldt, AIST, Manabu Hagiwara, Chiba U. (previously AIST), Jonas Senizergues, ENS Cachan (internship at AIST), Jacques Garrigue, Nagoya U., Kazuhiko Sakaguchi, Tsukuba U., Taku Asai, Nagoya U. (M2), Takafumi Saikawa, Nagoya U., Naruomi Obata, Titech (M2)",None,False
coq-int-map,https://github.com/coq-contribs/int-map,"This library contains a data structure for finite sets implemented by an efficient structure of map (trees indexed by binary integers). It was initially developed by Jean Goubault.  This user contribution used to be part of Coq Standard Library. It is now considered to be obsolete and subsumed by the new FSets/FMap library. IntMap can be now seen as a particular implementation of FMapInterface, see file FMapIntMap.",Jean Goubault,68Q65,False
coq-interval,https://coqinterval.gitlabpages.inria.fr/,A Coq tactic for proving bounds on real-valued expressions automatically,"Guillaume Melquiond, Érik Martin-Dorel, Pierre Roux, Thomas Sibut-Pinote",14Pxx,False
coq-intuitionistic-nuprl,https://github.com/coq-contribs/intuitionistic-nuprl,"http://www.nuprl.org/html/Nuprl2Coq/  This library formalizes Nuprl's Constructive Type Theory (CTT) as of 2015. CTT is an extensional type theory originally inspired by Martin-Lof's extensional type theory, and that has since then been extended with several new types such as: intersection types, union types, image types, partial types, set types, quotient types, partial equivalence relation (per) types, simulation and bisimulation types, an atom type, and the ""Base"" type.  Our formalization includes a definition of Nuprl's computation system, a definition of Howe's computational equivalence relation and a proof that it is a congruence, an impredicative definition of Nuprl's type system using Allen's PER semantics (using Prop's impredicativity, we can formalize Nuprl's infinite hierarchy of universes), definitions of most (but not all) of Nuprl's inference rules and proofs that these rules are valid w.r.t. Allen's PER semantics, and a proof of Nuprl's consistency.  In addition to the standard introduction and elimination rules for Nuprl's types, we have also proved several Brouwerian rules. Our computation system also contains: (1) free choice sequences that we used to prove Bar Induction rules; (2) named exceptions and a ""fresh"" operator to generate fresh names, that we used to prove a continuity rule.  More information can be found here: http://www.nuprl.org/html/Nuprl2Coq/ Feel free to send questions to the authors or to nuprl@cs.cornell.edu","Vincent Rahli, Abhishek Anand, Mark Bickford",03B38,False
coq-io,https://github.com/clarus/io,A library for effects in Coq,Guillaume Claret,68-04,True
coq-io-evaluate,https://github.com/clarus/io-evaluate,Generic functions to run effects,Guillaume Claret,68-04,True
coq-io-exception,https://github.com/clarus/io-exception,Abstract your errors into exceptions,Guillaume Claret,68-04,True
coq-io-hello-world,https://github.com/clarus/coq-hello-world,A Hello World program in Coq,Guillaume Claret,68-04,True
coq-io-list,https://github.com/clarus/io-list,Generic functions on lists with effects,Guillaume Claret,68-04,True
coq-io-system,https://github.com/clarus/io-system,System effects for Coq,Guillaume Claret,68-04,True
coq-io-system-ocaml,https://github.com/clarus/io-system-ocaml,Extraction to OCaml of system effects,Guillaume Claret,68-04,True
coq-ipc,https://github.com/coq-contribs/ipc,"This development treats proof search in intuitionistic propositional logic, a fragment of any constructive type theory. We present new and more efficient decision procedures for intuitionistic propositional logic. They themselves are given by (non-formal) constructive proofs. We take one of them to demonstrate that constructive type theory can be used in practice to develop a real, efficient, but error-free proof searcher. This was done by formally proving the decidability of intuitionistic propositional logic in Coq; the proof searcher was automatically extracted.",Klaus Weich,03F55,True
coq-iris,https://iris-project.org/,"This package provides the following Coq modules: iris.prelude, iris.algebra, iris.si_logic, iris.bi, iris.proofmode, iris.base_logic, iris.program_logic.",,None,False
coq-iris-heap-lang,https://iris-project.org/,This package provides the iris.heap_lang Coq module.,,None,False
coq-iris-string-ident,https://gitlab.mpi-sws.org/iris/string-ident,"This package implements string_to_ident in Ltac2, enabling support for Gallina names in Iris intro patterns (within strings).",,NA,False
coq-itauto,https://gitlab.inria.fr/fbesson/itauto,'itauto' is a reflexive SAT solver parameterised by a leaf tactic,Frédéric Besson,None,False
coq-iterable,https://github.com/clarus/coq-iterable,Generic definition of iterators,Guillaume Claret,None,False
coq-itree,https://github.com/DeepSpec/InteractionTrees,A Library for Representing Recursive and Impure Programs in Coq,"Li-yao Xia, Yannick Zakowski, Paul He, Chung-Kil Hur, Gregory Malecha, Steve Zdancewic, Benjamin C. Pierce",None,False
coq-itree-io,https://github.com/Lysxia/coq-itree-io,Interpret itree in the IO monad of simple-io.,Li-yao Xia,None,False
coq-izf,https://github.com/coq-contribs/izf,"This development contains the set-as-pointed-graph interpretation of Intuitionistic Zermelo Frankel set theory in system F_omega.2++ (F_omega + one extra universe + intuitionistic choice operator), which is described in chapter 9 of the author's PhD thesis (for IZ) and in the author's CSL'03 paper (for the extension IZ -> IZF).",Alexandre Miquel,03Exx,False
coq-jmlcoq,https://github.com/coq-community/jmlcoq,"A Coq formalization of the syntax and semantics of the Java-targeted JML specification language, along with a verified runtime assertion checker for JML.","Hermann Lehner, David Pichardie, Andreas Kägi",68Wxx,False
coq-jordan-curve-theorem,http://dpt-info.u-strasbg.fr/~jfd/Downloads/JORDAN_Contrib_Coq.tar.gz,"Constructive formalization of the combinatorial hypermaps, characterization of the planarity, genus theorem, Euler formula, ring of faces, discrete Jordan curve theorem",Jean-François Dufourd,51-xx,False
coq-jprover,https://github.com/coq-contribs/jprover,"JProver is a theorem prover for first-order intuitionistic logic. It is originally implemented by Stephan Schmitt and then integrated into MetaPRL by Aleksey Nogin. After this, Huang Guan-Shieng extracted the necessary ML-codes from MetaPRL and then adapted it to Coq.",Huang Guan-Shieng,NA,False
coq-jsast,https://github.com/querycert/jsast,"A minimal JavaScript syntax tree carved out of the JsCert project, with additional support for let bindings and using native floats.","Martin Bodin, Arthur Charguéraud, Daniele Filaretti, Philippa Gardner, Sergio Maffeis, Daiva Naudziuniene, Alan Schmitt, Gareth Smith, Josh Auerbach, Martin Hirzel, Louis Mandel, Avi Shinnar, Jerome Simeon",None,False
coq-json,https://github.com/liyishuai/coq-json,"From JSON to Coq, and vice versa.",Yishuai Li,68Q65,False
coq-karatsuba,http://r6.ca/Karatsuba/,An implementation of Karatsuba's Multiplication algorithm,Russell O'Connor,11-xx,False
coq-kildall,http://www.lif-sud.univ-mrs.fr/Rapports/24-2005.html,This Library provides a generic data flow analysis algorithm and a proof of its correctness. This algorithm is then used to perform type and shape analysis at bytecode level on a first order functionnal language.,"Solange Coupet-Grimal, William Delobel",68Q55,False
coq-label,https://github.com/pedagand/coq-label,'label' is a Coq plugin for referring to Propositional hypotheses by their type,"Pierre-Évariste Dagand, Théo Zimmermann, Pierre-Marie Pédrot",None,False
coq-lambda,https://github.com/coq-contribs/lambda,"We present the complete development in Gallina of the residual theory of beta-reduction in pure lambda-calculus. The main result is the Prism Theorem, and its corollary Lévy's Cube Lemma, a strong form of the parallel-moves lemma, itself a key step towards the confluence theorem and its usual corollaries (Church-Rosser, uniqueness of normal forms).",Gérard Huet,68N18,False
coq-lambek,https://github.com/coq-contribs/lambek,"This library contains some definitions concerning Lambek calculus. Three formalisations of this calculus are proposed, and also some certified functions which translate derivations from one formalism to another. Several derived properties are proved and also some meta-theorems. Users can define their own lexicons and use the defined tactics to prove the derivation of sentences in a particular system (L, NL, LP, NLP ...)","Houda Anoun, Pierre Castéran",68Q45,False
coq-lazy-pcf,http://www.cs.bell-labs.com/~felty/abstracts/ppcoq.html,An Operational Semantics of Lazy Evaluation and a Proof of Subject Reduction,"Amy Felty, Jill Seaman",68N18,False
coq-lc,http://www.math.unifi.it/~/maggesi/mechanized/,"We define a notion of module over a monad and use it to propose a new definition (or semantics) for abstract syntax (with binding constructions). Using our notion of module, we build a category of `exponential' monads, which can be understood as the category of lambda-calculi, and prove that it has an initial object (the pure untyped lambda-calculus).","André Hirschowitz, Marco Maggesi",68N18,False
coq-legacy-ring,https://github.com/coq-contribs/legacy-ring,Tactics to decide equality and simplify polynomial expressions over an arbitrary commutative ring. This generalizes a previous tactics by Samuel Boutin.,Patrick Loiseleur,None,False
coq-lemma-overloading,https://github.com/coq-community/lemma-overloading,"This project contains Hoare Type Theory libraries which demonstrate a series of design patterns for programming with canonical structures that enable one to carefully and predictably coax Coq's type inference engine into triggering the execution of user-supplied algorithms during unification, and illustrates these patterns through several realistic examples drawn from Hoare Type Theory. The project also contains typeclass-based re-implementations for comparison.","Georges Gonthier, Beta Ziliani, Aleksandar Nanevski, Derek Dreyer",68Q65,False
coq-lens,https://github.com/bedrocksystems/coq-lens,Generation of lenses for record datatypes,Gregory Malecha,None,False
coq-lesniewski-mereology,http://www.polytech.univ-savoie.fr/index.php?id=listic-logiciels-coq&L=1,"LesniewskiMereology is a Coq library created by R. Dapoigny and P. Barlatier whose purpose is to implement the alternative to Set Theory of Stanislaw Lesniewski. It is part of an on-going project using the Coq language and called KDTL (Knowledge-based Dependently Typed Language) to build an alternative to Description Logics. The developed theory is close to the analysis of Denis Mieville (1984) in his book ""Un developpement des systemes logiques de Stanislaw Lesniewski"". It is a theoretical construct which relies on three dependent levels, logic (a.k.a. Protothetic), the Lesniewski Ontologie (LO) and mereology. Each level incorporates a minimal collection of axioms, protothetic and ontologic definitions and a set of theorems together with their intuitionist proofs.","Richard Dapoigny, Patrick Barlatier",03-xx,False
coq-libhyps,https://github.com/Matafou/LibHyps,"This library defines a set of tactics to manipulate hypothesis individually or by group. In particular it allows applying a tactic on each hypothesis of a goal, or only on *new* hypothesis after some tactic. Examples of manipulations: automatic renaming, subst, revert, or any tactic expecting a hypothesis name as argument.  It also provides the especialize tactic to ease forward reasoning by instantianting one, several or all premisses of a hypothesis.",Pierre Courtieu,NA,False
coq-library-undecidability,https://github.com/uds-psl/coq-library-undecidability/,A Coq Library of Undecidability Proofs,"Yannick Forster, Dominique Larchey-Wendling, Andrej Dudenhefner, Edith Heiter, Dominik Kirst, Fabian Kunze, Gert Smolka, Simon Spies, Dominik Wehr, Maximilian Wuttke",None,False
coq-libvalidsdp,https://sourcesup.renater.fr/validsdp/,"LibValidSDP is a library for the Coq formal proof assistant. It provides results mostly about rounding errors in the Cholesky decomposition algorithm used in the ValidSDP library which itself implements Coq tactics to prove multivariate inequalities using SDP solvers.  Once installed, the following modules can be imported : From libValidSDP Require Import Rstruct.v misc.v real_matrix.v bounded.v float_spec.v fsum.v fcmsum.v binary64.v cholesky.v float_infnan_spec.v binary64_infnan.v cholesky_infnan.v flx64.v zulp.v coqinterval_infnan.v.","Pierre Roux, Érik Martin-Dorel",NA,False
coq-lin-alg,https://github.com/coq-contribs/lin-alg,"A development of some preliminary linear algebra based on Chapter 1 of ""Linear Algebra"" by Friedberg, Insel and Spence",Jasper Stein,06-xx,False
coq-list-plus,https://github.com/clarus/coq-list-plus,More functions on lists,Guillaume Claret,None,False
coq-list-string,https://github.com/clarus/coq-list-string,Strings implemented as lists,Guillaume Claret,None,False
coq-ltac-iter,https://github.com/gmalecha/coq-ltac-iter,"Provides tactics for performing various forms of iteration over hypotheses, hint databases, and other collections.",Gregory Malecha,None,False
coq-ltac2,https://github.com/coq/ltac2,A tactic language for Coq,,None,False
coq-ltl,https://github.com/coq-contribs/ltl,"This contribution contains a shallow embedding of Linear Temporal Logic (LTL) based on a co-inductive representation of program executions. Temporal operators are implemented as inductive (respectively co-inductive) types when they are least (respectively greatest) fixpoints. Several general lemmas, that correspond to LTL rules, are proved.",Solange Coupet-Grimal,03B45,False
coq-maple-mode,https://github.com/coq-contribs/maple-mode,"This contribution is an interface between Coq and Maple. In particular, this exports the functions simplify/factor/expand/normal giving the corresponding tactics Simplify/Factor/Expand/Normal. The manipulations carried out by these tactics are proved thanks to the tactic Field. These tactics can be also used as functions by means of the Eval ... In command.","David Delahaye, Micaela Mayero",NA,False
coq-markov,https://github.com/coq-contribs/markov,"A proof of Markov's inequality, restricted to probability spaces, based on the Wikipedia proof. Defines Lebesgue integral and associated concepts such as measurability, measure functions, and sigma algebras. Extended real numbers did not need to be defined because we are working in a probability space with measure 1. Nonconstructive; uses classic, Extensionality_Ensembles, axiomatized real numbers from Coq standard library.",Robert Kam,14Pxx,False
coq-matching-logic,https://github.com/harp-project/AML-Formalization,A library for Matching Logic.,"Jan Tusil, Lucas Peña, Attila Boros, Mizsei Tamás",03-xx,False
coq-math-classes,https://github.com/coq-community/math-classes,"Math classes is a library of abstract interfaces for mathematical structures, such as:  *  Algebraic hierarchy (groups, rings, fields, …) *  Relations, orders, … *  Categories, functors, universal algebra, … *  Numbers: N, Z, Q, … *  Operations, (shift, power, abs, …)  It is heavily based on Coq’s new type classes in order to provide: structure inference, multiple inheritance/sharing, convenient algebraic manipulation (e.g. rewriting) and idiomatic use of notations.","Eelis van der Weegen, Bas Spitters, Robbert Krebbers",None,False
coq-mathcomp-abel,https://github.com/math-comp/abel,This repository contains a proof of Abel - Galois Theorem (equivalence between being solvable by radicals and having a solvable Galois group) and Abel - Ruffini Theorem (unsolvability of quintic equations) in the Coq proof-assistant and using the Mathematical Components library.,"Sophie Bernard, Cyril Cohen, Assia Mahboubi, Pierre-Yves Strub",None,False
coq-mathcomp-algebra,https://math-comp.github.io/,"This library contains definitions and theorems about discrete (i.e. with decidable equality) algebraic structures : ring, fields, ordered fields, real fields,  modules, algebras, integers, rational numbers, polynomials, matrices, vector spaces...","Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-mathcomp-analysis,https://github.com/math-comp/analysis,This repository contains an experimental library for real analysis for the Coq proof-assistant and using the Mathematical Components library.,"Reynald Affeldt, Cyril Cohen, Marie Kerjean, Assia Mahboubi, Damien Rouhling, Pierre Roux, Kazuhiko Sakaguchi, Pierre-Yves Strub, Laurent Théry",14Pxx,False
coq-mathcomp-bigenough,https://github.com/math-comp/bigenough,The package contains a package to reasoning with big enough objects (mostly natural numbers). This package is essentially for backward compatibility purposes as `bigenough` will be subsumed by the near tactics. The formalization is based on the Mathematical Components library.,Cyril Cohen,None,False
coq-mathcomp-character,https://math-comp.github.io/,"This library contains definitions and theorems about group representations, characters and class functions.","Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-mathcomp-dioid,https://github.com/math-comp/dioid,"Definitions of the algebraic structure of dioid following the style of ssralg in the Mathcomp library.  The main algebraic structures defined are: * semirings: rings without oppositve for the additive law * dioids: idempotent semirings (i.e., forall x, x + x = x) * complete dioids: dioids whose canonical order (x <= y wen x + y = y)   yields a complete lattice * commutative variants (multiplicative law is commutative)  More details can be found in comments at the beginning of each file.","Lucien Rakotomalala, Pierre Roux",NA,False
coq-mathcomp-field,https://math-comp.github.io/,"This library contains definitions and theorems about field extensions, galois theory, algebraic numbers, cyclotomic polynomials...","Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-mathcomp-field-extra,http://ssr.msr-inria.inria.fr/,"This library contains extra definitions and theorems about field extensions, galois theory, algebraic numbers, cyclotomic polynomials... needed for coq-mathcomp-odd-order","Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-mathcomp-fingroup,https://math-comp.github.io/,"This library contains definitions and theorems about finite groups, group quotients, group morphisms, group presentation, group action...","Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-mathcomp-finmap,https://github.com/math-comp/finmap,"This library is an extension of mathematical component in order to support finite sets and finite maps on choicetypes (rather that finite types). This includes support for functions with finite support and multisets. The library also contains a generic order and set libary, which will be used to subsume notations for finite sets, eventually.","Cyril Cohen, Kazuhiko Sakaguchi",None,False
coq-mathcomp-grobner,https://github.com/thery/grobner,"A fornalisation of Grobner basis in ssreflect. It contains one file  grobner.v  It defines.  From mathcomp Require Import all_ssreflect all_algebra. From SsrMultinomials Require Import ssrcomplements poset freeg mpoly. From mathcomp.contrib.grobner Require Import grobner.  (* p belongs to the ideal generated by L *)  Check ideal.  ideal =  fun (R : ringType) (n : nat) (L : seq {mpoly R[n]}) (p : {mpoly R[n]})   =>   exists t, p = \sum_(i < size L) t`_i * L`_i   (* it is decidable *)  Check idealfP.  idealfP      : forall (R : fieldType)  (n : nat) (p : {mpoly R[n]})               (l : seq {mpoly R[n]}),        reflect (ideal l p) (idealf l p)",,None,False
coq-mathcomp-multinomials,https://github.com/math-comp/multinomials,A Multivariate polynomial Library for the Mathematical Components Library,Pierre-Yves Strub,08A40,False
coq-mathcomp-odd-order,http://math-comp.github.io/math-comp/,"The formal proof of the Feit-Thompson theorem.  From mathcomp Require Import all_ssreflect all_fingroup all_solvable PFsection14.  Check Feit_Thompson.    : forall (gT : finGroupType) (G : {group gT}), odd #|G| -> solvable G  From mathcomp Require Import all_ssreflect all_fingroup                               all_solvable stripped_odd_order_theorem.  Check stripped_Odd_Order.    : forall (T : Type) (mul : T -> T -> T) (one : T) (inv : T -> T)          (G : T -> Type) (n : natural),        group_axioms T mul one inv ->        group T mul one inv G ->        finite_of_order T G n -> odd n -> solvable_group T mul one inv G","Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-mathcomp-real-closed,https://github.com/math-comp/real-closed,"This library contains definitions and theorems about real closed fields, with a construction of the real closure and the algebraic closure (including a proof of the fundamental theorem of algebra). It also contains a proof of decidability of the first order theory of real closed field, through quantifier elimination.","Cyril Cohen, Assia Mahboubi",None,False
coq-mathcomp-solvable,https://math-comp.github.io/,This library contains more definitions and theorems about finite groups.,"Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-mathcomp-ssreflect,https://math-comp.github.io/,"This library includes the small scale reflection proof language extension and the minimal set of libraries to take advantage of it. This includes libraries on lists (seq), boolean and boolean predicates, natural numbers and types with decidable equality, finite types, finite sets, finite functions, finite graphs, basic arithmetics and prime numbers, big operators","Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-mathcomp-sum-of-two-square,https://github.com/thery/twoSquare,"gauss_int.v : the definition of gaussian integers  fermat2.v : the proof of Fermat's theorem  The final statement reads:  ===================================================  From mathcomp Require Import all_ssreflect.  From mathcomp.contrib.sum_of_two_square Require Import gauss_int fermat2. Check sum2stest.  sum2stest      : forall n : nat,        reflect          (forall p : nat,           prime p ->           odd p -> p %| n -> odd (logn p n) -> p %% 4 = 1)          (n \is a sum_of_two_square)  ===================================================",,None,False
coq-mathcomp-zify,https://github.com/math-comp/mczify,This small library enables the use of the Micromega tactics for goals stated with the definitions of the Mathematical Components library by extending the zify tactic.,Kazuhiko Sakaguchi,None,False
coq-maths,https://github.com/coq-contribs/maths,"Basic mathematics (gcd, primality, etc.) from French ``Mathematiques Superieures'' (first year of preparation to high schools)",Jean-Christophe Filliâtre,11-xx,False
coq-matrices,https://github.com/coq-contribs/matrices,"This contribution contains an operational formalization of square matrices. (m,n)-Matrices are represented as vectors of length n. Each vector (a row) is itself a vector whose length is m. Vectors are actually implemented as dependent lists.  We define basic operations for this datatype (addition, product, neutral elements O_n and I_n). We then prove the ring properties for these operations. The development uses Coq modules to specify the interface (the ring structure properties) as a signature.  This development deals with dependent types and partial functions. Most of the functions are defined by dependent case analysis and some functions such as getting a column require the use of preconditions (to check whether we are within the bounds of the matrix).",Nicolas Magaud,06-xx,False
coq-menhirlib,https://gitlab.inria.fr/fpottier/coq-menhirlib,A support library for verified Coq parsers produced by Menhir,Jacques-Henri Jourdan,None,False
coq-metacoq,https://metacoq.github.io/metacoq,"MetaCoq is a meta-programming framework for Coq.  The meta-package includes the template-coq library, unverified checker for Coq, PCUIC development including a verified translation from Coq to PCUIC,  safe checker and erasure for PCUIC and example translations.   See individual packages for more detailed descriptions.","Abhishek Anand, Simon Boulier, Cyril Cohen, Yannick Forster, Fabian Kunze, Gregory Malecha, Matthieu Sozeau, Nicolas Tabareau, Théo Winterhalter",68-04,True
coq-metacoq-checker,https://metacoq.github.io/metacoq,MetaCoq is a meta-programming framework for Coq.  The Checker module provides a complete specification of Coq's typing and conversion relation along with a reference type-checker that is extracted to a pluging.  This provides a command: `MetaCoq Check [global_reference]` that can be used to typecheck a Coq definition using the verified type-checker.,"Abhishek Anand, Simon Boulier, Cyril Cohen, Yannick Forster, Fabian Kunze, Gregory Malecha, Matthieu Sozeau, Nicolas Tabareau, Théo Winterhalter",68-04,True
coq-metacoq-erasure,https://metacoq.github.io/metacoq,"MetaCoq is a meta-programming framework for Coq.  The Erasure module provides a complete specification of Coq's so-called ""extraction"" procedure, starting from the PCUIC calculus and targeting untyped call-by-value lambda-calculus.  The `erasure` function translates types and proofs in well-typed terms into a dummy `tBox` constructor, following closely P. Letouzey's PhD thesis.","Abhishek Anand, Simon Boulier, Cyril Cohen, Yannick Forster, Fabian Kunze, Gregory Malecha, Matthieu Sozeau, Nicolas Tabareau, Théo Winterhalter",68-04,True
coq-metacoq-pcuic,https://metacoq.github.io/metacoq,"MetaCoq is a meta-programming framework for Coq.  The PCUIC module provides a cleaned-up specification of Coq's typing algorithm along with a certified typechecker for it. This module includes the standard metatheory of PCUIC: Weakening, Substitution, Confluence and Subject Reduction are proven here.","Abhishek Anand, Simon Boulier, Cyril Cohen, Yannick Forster, Fabian Kunze, Gregory Malecha, Matthieu Sozeau, Nicolas Tabareau, Théo Winterhalter",68-04,True
coq-metacoq-safechecker,https://metacoq.github.io/metacoq,"MetaCoq is a meta-programming framework for Coq.  The SafeChecker modules provides a correct implementation of weak-head reduction, conversion and typechecking of Coq definitions and global environments.","Abhishek Anand, Simon Boulier, Cyril Cohen, Yannick Forster, Fabian Kunze, Gregory Malecha, Matthieu Sozeau, Nicolas Tabareau, Théo Winterhalter",68-04,True
coq-metacoq-template,https://metacoq.github.io/metacoq,"MetaCoq is a meta-programming framework for Coq.  Template Coq is a quoting library for Coq. It takes Coq terms and constructs a representation of their syntax tree as a Coq inductive data type. The representation is based on the kernel's term representation.  In addition to a complete reification and denotation of CIC terms, Template Coq includes:  - Reification of the environment structures, for constant and inductive declarations. - Denotation of terms and global declarations - A monad for manipulating global declarations, calling the type   checker, and inserting them in the global environment, in the style of   MetaCoq/MTac.","Abhishek Anand, Simon Boulier, Cyril Cohen, Yannick Forster, Fabian Kunze, Gregory Malecha, Matthieu Sozeau, Nicolas Tabareau, Théo Winterhalter",68-04,True
coq-metacoq-translations,https://metacoq.github.io/metacoq,"MetaCoq is a meta-programming framework for Coq.  The Translations modules provides implementation of standard translations  from type theory to type theory, e.g. parametricity and the `cross-bool`  translation that invalidates functional extensionality.","Simon Boulier, Cyril Cohen, Matthieu Sozeau, Nicolas Tabareau, Théo Winterhalter",68-04,True
coq-metalib,https://github.com/plclub/metalib,Locally Nameless Metatheory Library,,None,False
coq-mi-cho-coq,https://gitlab.com/nomadic-labs/mi-cho-coq/,"Michelson is a language for writing smart contracts on the Tezos blockchain. This package provides a Coq encoding of the syntax and semantics of Michelson, automatically generated by the Ott tool. Also included is a framework called Mi-Cho-Coq for reasoning about Michelson programs in Coq using a weakest precondition calculus.","Raphaël Cauderlier, Bruno Bernardo, Julien Tesson, Arvid Jakobsson",68N15,False
coq-min-imports,https://github.com/vzaliva/coq-min-imports,"sources. It examines modules listed in ""Require Import"" statements one by one and tries to recompile to see if their removal would cause compilation errors.",Vadim Zaliva,NA,False
coq-mini-compiler,https://github.com/coq-contribs/mini-compiler,"Tutorial correctness proof of a tiny compiler from simple arithmetic expressions (constants, variables and additions) to simple assembly-like code (one accumulator, infinitly many registers and addition)",Jean-Christophe Filliâtre,68N20,False
coq-minic,https://github.com/coq-contribs/minic,"This contribution defines the denotational semantics of MiniC, a sub-set of the C language. This sub-set is sufficiently large to contain any program generated by lustre2C. The denotation function describing the semantics of a MiniC program actually provides an interpreter for the program.",Eduardo Giménez and Emmanuel Ledinot,68Q55,False
coq-miniml,https://github.com/coq-contribs/miniml,A formalisation of Mini-ML and of the Categorical Abstract Machine (C.A.M) in natural semantics. It also contains the definition of the translation from Mini-ML to the CAM and the proof that this translation is correct,Samuel Boutin,68N20,False
coq-mirror-core,https://github.com/gmalecha/mirror-core,A framework for computational reflection,Gregory Malecha,None,False
coq-mod-red,https://github.com/coq-contribs/mod-red,"Fast reduction of integers by moduli up to 2^(w-1), where w is a processor's word size.",Luc Rutten,11-xx,False
coq-moment,https://github.com/clarus/coq-moment,"Parse, manipulate and pretty-print times and dates in Coq",Guillaume Claret,None,False
coq-monae,https://github.com/affeldt-aist/monae,This Coq library contains a hierarchy of monads with their laws used in several examples of monadic equational reasoning.,"Reynald Affeldt, David Nowak, Takafumi Saikawa, Jacques Garrigue, Celestine Sauvage, Kazunari Tanaka",18C15,True
coq-msets-extra,https://github.com/thtuerk/MSetsExtra,"Coq's MSet library provides various, reasonably efficient finite set implementations. Nevertheless, FireEye was struggling with performance issues. This library contains extensions to Coq's MSet library that helped the FireEye Formal Methods team (formal-methods@fireeye.com), solve these performance issues. There are  - Fold With Abort   efficient folding with possibility to start late and stop early  - Interval Sets   a memory efficient representation of sets of numbers    - Unsorted Lists with Duplicates","FireEye Formal Methods Team, Thomas Tuerk",68Q65,False
coq-mtac,https://github.com/beta-ziliani/mtac-plugin,Typed Tactics for Coq 8.5,Beta Ziliani,None,False
coq-mtac2,https://github.com/Mtac2/Mtac2,Mtac2: Typed Tactics for Coq,"Beta Ziliani, Jan-Oliver Kaiser, Robbert Krebbers, Yann Régis-Gianas, Derek Dreyer",None,False
coq-multiplier,https://github.com/coq-contribs/multiplier,Proof of a multiplier circuit,Christine Paulin,94Cxx,False
coq-mutual-exclusion,https://github.com/coq-contribs/mutual-exclusion,This is a proof of certification of Peterson's algorithm for managing mutual exclusion. The case of two processes is treated in the directory called ``binary'' (see the README file in this directory). The case of n processes will be available soon.,Eduardo Giménez,68N19,True
coq-nfix,https://github.com/coq-contribs/nfix,This plugin provides a syntactic extension that allows one to write mutual fixpoints over nested inductives.,Stéphane Lescuyer,NA,False
coq-of-ocaml,https://github.com/clarus/coq-of-ocaml,Compile a subset of OCaml to Coq,Guillaume Claret,None,False
coq-ollibs,https://github.com/olaure01/ollibs,Add-ons for the Coq standard library,"Olivier Laurent, Christophe Lucas",NA,False
coq-opam-website,https://github.com/clarus/coq-opam-website,Generation of a Coq website for OPAM: http://coq.io/opam/,Guillaume Claret,None,False
coq-orb-stab,https://github.com/coq-contribs/orb-stab,"Finite orbit-stabilizer theorem, based on Rahbar Virk's lecture notes. A large portion of the work was a simplified version of the inclusion-exclusion principle. Requires Loic Pottier's Algebra contribution, and Jasper Stein's Linear Algebra contribution.",Robert Kam,06-xx,False
coq-ordinal,https://github.com/minkiminki/Ordinal,Ordinal Numbers in Coq,Minki Cho,03-xx,False
coq-ott,http://www.cl.cam.ac.uk/~pes20/ott/,"Ott takes as input a definition of a language syntax and semantics, in a concise and readable ASCII notation that is close to what one would write in informal mathematics. It can then generate a Coq version of the definition, which requires this library.","Peter Sewell, Francesco Zappa Nardelli, Scott Owens",68Q55,False
coq-otway-rees,https://github.com/coq-contribs/otway-rees,"A description and a proof of correctness for the Otway-Rees cryptographic protocol, usually used as an example for formalisation of such protocols.",Dominique Bolignano and Valérie Ménissier-Morain,68M25,True
coq-paco,https://github.com/snu-sf/paco/,Coq library implementing parameterized coinduction,"Chung-Kil Hur, Georg Neis, Derek Dreyer, Viktor Vafeiadis, Minki Cho",68N15,False
coq-paradoxes,https://github.com/coq-contribs/paradoxes,"A formalisation of Burali-Forti paradox in system U (the existence of an ordinal of ordinals is inconsistent), of Diaconescu paradox (axiom of choice implies excluded-middle), of Reynolds paradox (there is no set-theoretic model of system F) and Hurkens paradox in system U (adapted by H. Geuvers to show the inconsistency of Excluded-Middle in impredicative-Set Calculus of Inductive Constructions).","Bruno Barras, Thierry Coquand, Hugo Herbelin, Benjamin Werner",03-xx,False
coq-param-pi,https://github.com/coq-contribs/param-pi,"This development contains the specification for a monadic pi-calculus using the same coding method for names than J. Mc Kinna and R. Pollack used for PTS in LEGO: ""Some Lambda Calculus and Type Theory Formalized"".  The basic, monadic calculus encoded here has a type system restraining the direction of communication for processes' names.  A number of lemmas usefull for doing proofs on that coding are included, and subject reduction properties for each kind of transition is made as an example of actually using the coding to mechanize proofs on the pi-calculus.",Loïc Henry-Gréard,68N18,False
coq-paramcoq,https://github.com/coq-community/paramcoq,"The plugin is still in an experimental state. It is not very user friendly (lack of good error messages) and still contains bugs. But is useable enough to ""translate"" a large chunk of standard library.","Chantal Keller (Inria, École polytechnique), Marc Lasson (ÉNS de Lyon), Abhishek Anand, Pierre Roux, Emilio Jesús Gallego Arias, Cyril Cohen, Matthieu Sozeau",NA,False
coq-parsec,https://github.com/liyishuai/coq-parsec,Inspired by Haskell Parsec library.,"Yishuai Li, Azzam Althagafi, Yao Li, Li-yao Xia, Benjamin C. Pierce",68Q65,False
coq-pautomata,https://github.com/coq-contribs/pautomata,"This contribution is a modelisation in Coq of the p-automata designed in the CALIFE project (http://www.loria.fr/calife). It contains an axiomatisation of time, the definition of a p-automaton, the definition of binary and arbitrary synchronisation of a family of p-automaton, the semantics of a p-automaton as a labelled transition system. The description of the ABR algorithm as a p-automaton is also given.  This work is reported in : P. Castéran, E. Freund, C. Paulin and D. Rouillard ``Bibliothèques Coq et Isabelle-HOL pour les systèmes de transitions et les p-automates''",Emmanuel Freund & Christine Paulin,68Q85,False
coq-performance-tests,https://github.com/coq-community/coq-performance-tests,A library of Coq source files testing for performance regressions on Coq,Jason Gross,None,False
coq-performance-tests-lite,https://github.com/coq-community/coq-performance-tests,A library of Coq source files testing for performance regressions on Coq (lite version),Jason Gross,None,False
coq-persistent-union-find,http://www.lri.fr/~filliatr/puf/,Correctness proof of the Ocaml implementation of a persistent union-find data structure. See http://www.lri.fr/~filliatr/puf/ for more details.,Jean-Christophe Filliâtre,68Wxx,False
coq-pi-agm,http://www-sop.inria.fr/members/Yves.Bertot/,"This is a proof of correctness for two algorithms to compute PI to high precision using arithmetic-geometric means.  A first file contains the calculus-based proofs for an abstract view of the algorithm, where all numbers are real numbers.  A second file describes how to approximate all computations using large integers.  Other files describe the second algorithm which is close to the one used in mpfr, for instance.  The whole development can be used to produce mathematically proved and formally verified approximations of PI.",Yves Bertot,14Pxx,False
coq-pi-calc,http://www.dimi.uniud.it/~scagnett/pi-calculus.html,"This is a HOAS-based encoding of the pi-calculus (as originally conceived by Milner, Parrow and Walker in ""A Calculus of Mobile Processes"" Parts I-II, Information and Computation n. 100) together with the formal verification of a large part of the metatheory of Strong Late Bisimilarity.",Ivan Scagnetto,68Q85,False
coq-plouffe,https://github.com/thery/Plouffe,A Coq formalization of Plouffe formula,,None,False
coq-plugin-utils,https://github.com/gmalecha/coq-plugin-utils,"numbers, interfacing with Ltac, etc.",,None,False
coq-pocklington,https://github.com/coq-community/pocklington,Coq formalization of Pocklington's criterion for checking primality for large natural numbers. Includes a formal proof of Fermat's little theorem.,"Olga Caprotti, Martijn Oostdijk",11-xx,False
coq-poltac,https://github.com/thery/PolTac,"A set of tactics to deal with inequalities in Coq over N, Z and R:",Laurent Théry,None,False
coq-ppsimpl,https://fbesson.gitlabpages.inria.fr/ppsimpl/,Ppsimpl is a reflexive tactic for canonising (arithmetic) goals,Frédéric Besson,NA,False
coq-presburger,https://github.com/coq-contribs/presburger,A formalization of Presburger's algorithm as stated in the initial paper by Presburger.,Laurent Théry,03-xx,False
coq-prfx,http://www.cs.ru.nl/~hendriks/coq/prfx/,A formalisation of natural deduction for first-order logic with explicit proof terms. Read README.,Dimitri Hendriks,03-xx,False
coq-printf,https://github.com/gmalecha/coq-printf,Library providing implementation of sprintf for Coq,Gregory Malecha,None,False
coq-procrastination,https://github.com/Armael/coq-procrastination,A small library for collecting side conditions and deferring their proof,Armaël Guéneau,None,False
coq-projective-geometry,https://github.com/coq-contribs/projective-geometry,"This contributions contains elements of formalization of projective geometry. In the plane: Two axiom systems are shown equivalent. We prove some results about the decidability of the the incidence and equality predicates. The classic notion of duality between points and lines is formalized thanks to a functor. The notion of 'flat' is defined and flats are characterized. Fano's plane, the smallest projective plane is defined. We show that Fano's plane is desarguesian. In the space: We prove Desargues' theorem.","Nicolas Magaud, Julien Narboux, Pascal Schreck",51-xx,False
coq-propcalc,http://arxiv.org/abs/1503.08744,"Formalization of basic theorems about classical propositional logic. The main theorems are (1) the soundness and completeness of natural deduction calculus, (2) the equivalence between natural deduction calculus, Hilbert systems and sequent calculus and (3) cut elimination for sequent calculus.",Floris van Doorn,03-xx,False
coq-prosa,https://prosa.mpi-sws.org/,Prosa is a repository of definitions and proofs for real-time schedulability analysis built with Coq. Prosa’s distinguishing characteristic is that Prosa prioritizes readability over all other concerns to ensure that specifications remain accessible to readers without a background in formal proofs. (A background in real-time scheduling is assumed.),"Felipe Cerqueira, Björn Brandenburg, Maxime Lesourd, Sergey Bozhko, Xiaojie Guo, Sophie Quinton, Marco Perronet",None,False
coq-pts,https://github.com/coq-contribs/pts,"This contrib is a formalization of Pure Type Systems. It includes most of the basic metatheoretical properties: weakening, substitution, subject-reduction, decidability of type-checking (for strongly normalizing PTSs). Strengtheningis not proven here.  The kernel of a very simple proof checker is automatically generated from the proofs. A small interface allows interacting with this kernel, making up a standalone proof system.  The Makefile has a special target ""html"" that produces html files from the sources and main.html that gives a short overview.",Bruno Barras,68N18,False
coq-ptsatr,http://www.lix.polytechnique.fr/~vsiles/coq/PTSATR.html,"Formalization of the proof that PTS and PTS with judgmental equality (PTSe) are equivalent. With this equivalence, we are able to derive all the meta-theory of PTSe, like Pi-injectivity or Subject Reduction.","Vincent Siles, Hugo Herbelin",03B38,False
coq-ptsf,http://www.andrew.cmu.edu/user/fpv/ptsf/,Formalization of the proof that PTS and PTS with explicit convertibility proofs (PTSf) are equivalent.,"Floris van Doorn, Herman Geuvers, Freek Wiedijk",03B38,False
coq-qarith,https://github.com/coq-contribs/qarith,This contribution is a proposition of a library formalizing rational number in Coq.,Pierre Letouzey,NA,False
coq-qarith-stern-brocot,https://github.com/coq-community/qarith-stern-brocot,Development of rational numbers as finite binary lists and defining field operations on them in two different ways: strict and lazy.,"Milad Niqui, Yves Bertot",NA,False
coq-qcert,https://querycert.github.io,"This is the Coq library for Q*cert, a platform for implementing and verifying data languages and compilers. It includes abstract syntax and semantics for several source query languages (OQL, SQL), for intermediate database representations (nested relational algebra and calculus), and correctness proofs for part of the compilation to JavaScript and Java.","Josh Auerbach, Martin Hirzel, Louis Mandel, Avi Shinnar, Jerome Simeon",None,False
coq-quickchick,https://github.com/QuickChick/QuickChick,Randomized Property-Based Testing Plugin for Coq,"Leonidas Lampropoulos, Zoe Paraskevopoulou, Maxime Denes, Catalin Hritcu, Benjamin Pierce, Li-yao Xia, Arthur Azevedo de Amorim, Yishuai Li, Antal Spector-Zabusky",NA,False
coq-quicksort-complexity,https://github.com/coq-contribs/quicksort-complexity,"The development contains: - a set of monads and monad transformers for measuring a (possibly nondeterministic) algorithm's use of designated operations; - monadically expressed deterministic and nondeterministic implementations of Quicksort; - proofs of these implementations' worst- and average case complexity.  Most of the development is documented in the TYPES 2008 paper ""A Machine-Checked Proof of the Average-Case Complexity of Quicksort in Coq"", available at the homepage.",Eelis,68Wxx,False
coq-railroad-crossing,https://github.com/coq-contribs/railroad-crossing,"This library present the specification and verification of one real time system: the Railroad Crossing Problem, which has been proposed as a benchmark for the comparison of real-time formalisms. We specify the system using timed automatas (timed graphs) with discrete time and we prove invariants, the system safety property and the NonZeno property, using the logics CTL and TCTL.",Carlos Daniel Luna [http://www.fing.edu.uy/~cluna],68M12,False
coq-ramsey,https://github.com/coq-contribs/ramsey,"For dimension one, the Infinite Ramsey Theorem states that, for any subset A of the natural numbers nat, either A or nat\A is infinite. This special case of the Pigeon Hole Principle is classically equivalent to: if A and B are both co-finite, then so is their intersection. None of these principles is constructively valid. In [VB] the notion of an almost full set is introduced, classically equivalent to co-finiteness, for which closure under finite intersection can be proved constructively. A is almost full if for every (strictly) increasing sequence f: nat -> nat there exists an x in nat such that f(x) in A. The notion of almost full and its closure under finite intersection are generalized to all finite dimensions, yielding constructive Ramsey Theorems. The proofs for dimension two and higher essentially use Brouwer's Bar Theorem.  In the proof development below we strengthen the notion of almost full for dimension one in the following sense. A: nat -> Prop is called Y-full if for every (strictly) increasing sequence f: nat -> nat we have (A (f (Y f))). Here of course Y : (nat -> nat) -> nat. Given YA-full A and YB-full B we construct X from YA and YB such that the intersection of A and B is X-full. This is essentially [VB, Th. 5.4], but now it can be done without using axioms, using only inductive types. The generalization to higher dimensions will be much more difficult and is not pursued here.",Marc Bezem,05C15,True
coq-random,https://github.com/coq-contribs/random,"This contribution is a modelisation of random programs as measures in Coq. It started in 2004 in the context of the AVERROES project (http://www-verimag.imag.fr/AVERROES/). It is based on comon work with Philippe Audebaud (ENS Lyon). It was last updated in february 2007.  It contains the following elements   - an axiomatisation of the interval [0,1] and derived properties (files Ubase.v and Uprop.v);    - a definition of measures on a type A as functions of type (A->[0,1])->[0,1] enjoying special stability properties (files Monads.v and Probas.v); proofs that these constructions have a monadic structure;    - an interpretation of programs of type A as measures, in particular a fixpoint construction; the definition of an axiomatic semantic for deriving judgements such as ``the probability of an expression e to evaluate to a result satisfying property q belongs to an interval [p,q]'' (file Prog.v);    - Proof of probabilistic termination of a linear random walk (file Iterflip.v);    - Proof of a program implementing a bernoulli distribution (Proba(bernouilli(p)=true)=p) using a coin flip and the derived binomial law (Proba(binomial p n=k)=C(n,k)p^k(1-p)^{n-k}) (file Bernoulli.v);    - Proof of estimation of the combination of two random executions (file Choice.v)    - Proof of partial termination of parameterized random walk (file Ycart.v)    - Definition of a measure on traces from a mesure on transitions steps (file Nelist.v, Transitions.v)  The document random.pdf contains a short introduction to the library associated to the Gallina source code of the library.",Christine Paulin,68Wxx,False
coq-rational,https://github.com/coq-contribs/rational,Definition of integers as the usual symetric completion of a semi-group and of rational numbers as the product of integers and strictly positive integers quotiented by the usual relation. This implementation assumes two sets of axioms allowing to define quotient types and subset types. These sets of axioms should be proved coherent by mixing up the deliverable model and the setoid model (both are presented in Martin Hofmann' thesis).,Samuel Boutin,NA,False
coq-record-update,https://github.com/tchajed/coq-record-update,"While Coq provides projections for each field of a record, it has no convenient way to update a single field of a record. This library provides a generic way to update a field by name, where the user only has to implement a simple typeclass that lists out the record fields.",Tej Chajed,68Q65,False
coq-recursive-definition,https://github.com/coq-contribs/recursive-definition,"This module provides a facility to define recursive functions in an ML-like style, giving a fixpoint equation, a variant and a well-founded relation. A pure function is then generated, together with a theorem giving the fixpoint equation. THIS IS MAINLY A TEST CONTRIB, BEFORE INTEGRATION IN COQ.","Antonia Balaa, Yves Bertot",NA,False
coq-reduction-effects,https://github.com/coq-community/reduction-effects,A Coq plugin to add reduction side effects to some Coq reduction strategies,,None,False
coq-reflexive-first-order,https://github.com/coq-contribs/reflexive-first-order,"This contribution is a package which can be used to interpret firstorder proofs provided by an external theorem prover, using computational reflexion.",Pierre Corbineau,NA,False
coq-regexp,https://github.com/coq-contribs/regexp,"The Library RegExp is a Coq library for regular expression. The implementation is based on the Janusz Brzozowski's algorithm (""Derivatives of Regular Expressions"", Journal of the ACM 1964). The RegExp library satisfies the axioms of Kleene Algebra. The proofs are shown in the library.",Takashi Miyamoto,68Q45,False
coq-reglang,https://github.com/coq-community/reglang,"This library provides definitions and verified translations between different representations of regular languages: various forms of automata (deterministic, nondeterministic, one-way, two-way), regular expressions, and the logic WS1S. It also contains various decidability results and closure properties of regular languages.","Christian Doczkal, Jan-Oliver Kaiser, Gert Smolka",68Q45,False
coq-relation-algebra,http://perso.ens-lyon.fr/damien.pous/ra/,Relation Algebra and KAT in Coq,"Damien Pous, Christian Doczkal",03G15,True
coq-relation-extraction,https://github.com/coq-contribs/relation-extraction,This plugin introduces a new set of extraction commands that generates functional code form inductive specifications.,"Catherine Dubois, David Delahaye, Pierre-Nicolas Tollitte",68N20,False
coq-rem,https://github.com/coq-contribs/rem,A formalisation of Rem Theorem in Baire space,Henk Barendregt,14Pxx,False
coq-rewriter,https://github.com/mit-plv/rewriter,Reflective PHOAS rewriting/pattern-matching-compilation framework for simply-typed equalities and let-lifting,"Google Inc., Massachusetts Institute of Technology",None,False
coq-rewriter-perf-Fast,https://github.com/mit-plv/rewriter,Performance Benchmark for Reflective PHOAS rewriting/pattern-matching-compilation framework for simply-typed equalities and let-lifting,"Google Inc., Massachusetts Institute of Technology",None,False
coq-rewriter-perf-Medium,https://github.com/mit-plv/rewriter,Performance Benchmark for Reflective PHOAS rewriting/pattern-matching-compilation framework for simply-typed equalities and let-lifting,"Google Inc., Massachusetts Institute of Technology",None,False
coq-rewriter-perf-Slow,https://github.com/mit-plv/rewriter,Performance Benchmark for Reflective PHOAS rewriting/pattern-matching-compilation framework for simply-typed equalities and let-lifting,"Google Inc., Massachusetts Institute of Technology",None,False
coq-rewriter-perf-SuperFast,https://github.com/mit-plv/rewriter,Performance Benchmark for Reflective PHOAS rewriting/pattern-matching-compilation framework for simply-typed equalities and let-lifting,"Google Inc., Massachusetts Institute of Technology",None,False
coq-rewriter-perf-VerySlow,https://github.com/mit-plv/rewriter,Performance Benchmark for Reflective PHOAS rewriting/pattern-matching-compilation framework for simply-typed equalities and let-lifting,"Google Inc., Massachusetts Institute of Technology",None,False
coq-robot,https://github.com/affeldt-aist/robot,"This library is a formalization of the mathematics of rigid body transformations in the Coq proof-assistant. It can be used to address the forward kinematics problem of robot manipulators. It contains theories for angles, three-dimensional geometry (including three-dimensional rotations, skew-symmetric matrices, quaternions), rigid body transformations (isometries, homogeneous representation, Denavit-Hartenberg convention, screw motions), and an application to the SCARA robot manipulator.","Reynald Affeldt, AIST, Cyril Cohen, Inria, Laurent Thery, Inria",None,False
coq-rsa,https://github.com/coq-contribs/rsa,This directory contains the proof of correctness of RSA algorithm. It contains a proof of Fermat's little theorem,"Jose C. Almeida, Laurent Théry",68Wxx,False
coq-ruler-compass-geometry,https://github.com/coq-contribs/ruler-compass-geometry,This library contains an axiomatization of the ruler and compass euclidian geometry. Files A1 to A6 contain the axioms and the basic constructions. The other files build the proof that this axiomatization induces the whole plane geometry except the continuity axiom. For that the proofs of the Hilbert's axioms conclude this work in the files E1 to E5.,Jean Duprat,51-xx,False
coq-scev,https://github.com/bollu/SCEV-coq,Proofs and simplification lemmas of an algebraic theory of recurrences,Siddharth Bhat,NA,False
coq-schroeder,https://github.com/coq-contribs/schroeder,"Fraenkel's proof of Schroeder-Bernstein theorem on decidable sets is formalized in a constructive variant of set theory based on stratified universes (the one defined in the Ensemble library). The informal proof can be found for instance in ""Axiomatic Set Theory"" from P. Suppes.",Hugo herbelin,03Exx,False
coq-search-trees,https://github.com/coq-contribs/search-trees,"Algorithms for collecting, searching, inserting and deleting elements in binary search trees on nat",Pierre Castéran,68Q65,False
coq-semantics,https://github.com/coq-community/semantics,"This is a survey of programming language semantics styles for a miniature example of a programming language, with their encoding in Coq, the proofs of equivalence of different styles, and the proof of soundess of tools obtained from axiomatic semantics or abstract interpretation.  The tools can be run inside Coq, thus making them available for proof by reflection, and the code can also be extracted and connected to a yacc-based parser, thanks to the use of a functor parameterized by a module type of strings.  A hand-written parser is also provided in Coq, but there are no proofs associated.",Yves Bertot,68Q55,False
coq-sf-plf,https://softwarefoundations.cis.upenn.edu/,"Programming Language Foundations, surveys the theory of programming languages, including operational semantics, Hoare logic, and static type systems.","Benjamin C. Pierce, Arthur Azevedo de Amorim, Chris Casinghino, Marco Gaboardi, Michael Greenberg, Cătălin Hriţcu, Vilhelm Sjöberg, Andrew Tolmach, Brent Yorgey",None,False
coq-shuffle,https://github.com/coq-contribs/shuffle,"A full axiomatization and proof development of a non-trivial property of binary sequences, inspired from a card trick of N. Gilbreath.",Gérard Huet,00A08,True
coq-simple-io,https://github.com/Lysxia/coq-simple-io,"This library provides tools to implement IO programs directly in Coq, in a similar style to Haskell. Facilities for formal verification are not included.  IO is defined as a parameter with a purely functional interface in Coq, to be extracted to OCaml. Some wrappers for the basic types and functions in the OCaml Pervasives module are provided. Users are free to define their own APIs on top of this IO type.",,None,False
coq-smc,https://github.com/coq-contribs/smc,"Provides BDD algorithms, a symbolic model checker for the modal mu-calculus based on it, together with a garbage collector",Kumar Neeraj Verma,68Wxx,False
coq-smpl,https://github.com/uds-psl/smpl,"Smpl is useful for proof automation in Coq. Smpl provides named lists of tactics to which tactics can be added with Coq commands. A special tactic called 'smpl foo' executes the tactics in the lists named foo in order, until one of them succeeds. Smpl works across modules by merging tactics from all imports according to a priority number that can be provided upon addition. Smpl thus allows to modify the behavior of a tactic after it is defined in a convenient and modular way.","Sigurd Schneider, Yannick Forster, Fabian Kunze",None,False
coq-smt-check,https://github.com/gmalecha/coq-smt-check,Invoke SMT solvers to check goals,,None,False
coq-smtcoq,https://smtcoq.github.io/,"- a certified checker for proof witnesses coming from the SAT solver ZChaff and the SMT solvers veriT and CVC4. This checker increases the confidence in these tools by checking their answers a posteriori and allows to import new theroems proved by these solvers in Coq; - decision procedures through new tactics that discharge some Coq goals to ZChaff, veriT, CVC4, and their combination","Michaël Armand, Valentin Blot, Amina Bousalem, Quentin Garchery, Benjamin Grégoire, Chantal Keller, Burak Ekici, Alain Mebsout",68Wxx,False
coq-sniper,https://github.com/smtcoq/sniper,"Sniper is a Coq plugin that provides a new Coq tactic, snipe, for general proof automation.  This plugin is an extension of SMTCoq, a plugin to safely call external SMT solvers from Coq. Sniper extends SMTCoq by translating (a subset) of Coq goals into first-order logic before calling SMTCoq.  The translation is implemented through a combination of modular, small transformations that independently eliminate specific aspects of Coq logic towards first-order logic. These small transformations are safe, either generating proof terms on the fly (certifying transformations) or being proved once and for all in Coq (certified transformations).","Valentin Blot, Louise Dubois de Prisque, Chantal Keller, Pierre Vial",68Wxx,False
coq-square-matrices,https://github.com/coq-contribs/square-matrices,This development is a formalization of Chris Okasaki's article ``From Fast Exponentiation to Square Matrices: An Adventure in Types'',Jean-Christophe Filliâtre,06-xx,False
coq-squiggle-eq,https://github.com/aa755/SquiggleEq,"based on ideas in the following paper:  Howe, Douglas J. “Equality in Lazy Computation Systems.” In LICS, 198–203, 1989.","Abhishek Anand, Vincent Rahli",None,False
coq-ssreflect,http://ssr.msr-inria.inria.fr/,The Small Scale Reflection extension,"Jeremy Avigad, Andrea Asperti, Stephane Le Roux, Yves Bertot, Laurence Rideau, Enrico Tassi, Ioana Pasca, Georges Gonthier, Sidi Ould Biha, Cyril Cohen, Francois Garillot, Alexey Solovyev, Russell O'Connor, Laurent Théry, Assia Mahboubi",None,False
coq-stalmarck,https://github.com/coq-community/stalmarck,A two-level approach to prove tautologies using Stålmarck's algorithm in Coq.,"Pierre Letouzey, Laurent Théry",68Wxx,False
coq-stalmarck-tactic,https://github.com/coq-community/stalmarck,Coq tactic and verified tool for proving tautologies using Stålmarck's algorithm,"Pierre Letouzey, Laurent Théry",NA,False
coq-stdpp,https://gitlab.mpi-sws.org/iris/stdpp,"The key features of this library are as follows:  - It provides a great number of definitions and lemmas for common data   structures such as lists, finite maps, finite sets, and finite multisets. - It uses type classes for common notations (like `∅`, `∪`, and Haskell-style   monad notations) so that these can be overloaded for different data structures. - It uses type classes to keep track of common properties of types, like it   having decidable equality or being countable or finite. - Most data structures are represented in canonical ways so that Leibniz   equality can be used as much as possible (for example, for maps we have   `m1 = m2` iff `∀ i, m1 !! i = m2 !! i`). On top of that, the library provides   setoid instances for most types and operations. - It provides various tactics for common tasks, like an ssreflect inspired   `done` tactic for finishing trivial goals, a simple breadth-first solver   `naive_solver`, an equality simplifier `simplify_eq`, a solver `solve_proper`   for proving compatibility of functions with respect to relations, and a solver   `set_solver` for goals involving set operations. - It is entirely dependency- and axiom-free.",,None,False
coq-streams,https://github.com/coq-contribs/streams,"Proof of Eratosthene Sieve formalised using streams encoded as greatest fixpoints. See paper: @InProceedings{LePa94,   author =       ""F. Leclerc and C. Paulin-Mohring"",   title =        ""Programming with Streams in {Coq}. A case study : The Sieve of Eratosthenes"",   editor =       ""H. Barendregt and T. Nipkow"",   volume =       806,   series =       ""LNCS"",   booktitle =    ""{Types for Proofs and Programs, Types' 93}"",   year =         1994,   publisher =    ""Springer-Verlag"" }","François Leclerc, Christine Paulin-Mohring",11-xx,False
coq-string,https://github.com/coq-contribs/string,Strings as list of characters.,Laurent Théry,NA,False
coq-struct-tact,https://github.com/uwplse/StructTact,"A Coq library of ""structural tactics"" and lemmas about lists and finite types that use the tactics.","Ryan Doenges, Karl Palmskog, Keith Simmons, James R. Wilcox, Doug Woos",68Q65,False
coq-subst,https://github.com/coq-contribs/subst,"The confluence of Hardin-Lévy lambda-sigma-lift-calcul is proven. By the way, several standard definition and results about rewriting systems are proven (Newman's lemma, Yokouchi's lemma, ...).",Amokrane Saïbi,68N18,False
coq-sudoku,https://github.com/ftp://ftp-sop.inria.fr/lemme/Laurent.Thery/Sudoku.zip,A formalisation of Sudoku in Coq. It implements a naive Davis-Putnam procedure to solve sudokus.,Laurent Théry,00A08,True
coq-sum-of-two-square,https://github.com/coq-contribs/sum-of-two-square,A proof that a number n can be written as the sum of two square numbers if and only if each prime factor p of n that is equal to 3 modulo 4 has its exponent in the decomposition of n that is even.,Laurent Thery,11-xx,False
coq-switch,https://github.com/vzaliva/coq-switch,"It allows easier dispatch on several constant values of a type with decidable equality. Given a type, boolean equality predicate, and list of choices, it will generate (using TemplateCoq) an inductive type with constructors, one for each of the choices, and a function mapping values to this type.",Vadim Zaliva,NA,False
coq-tactician,https://coq-tactician.github.io,"Tactician is a tactic learner and prover for the Coq Proof Assistant.   The system will help users make tactical proof decisions while they retain   control over the general proof strategy. To this end, Tactician will learn   from previously written tactic scripts, and either gives the user suggestions   about the next tactic to be executed or altogether takes over the burden of   proof synthesis. Tactician's goal is to provide the user with a seamless,   interactive, and intuitive experience together with strong, adaptive proof   automation.",,NA,False
coq-tactician-dummy,https://coq-tactician.github.io,"This package acts as a stand-in for the Tactician plugin (`coq-tactician`).   It provides short files that replicate Tactician's tactics without actually   doing much. This is useful when you have a development that uses Tactician   that you want to package up. In most situations, it is not a good idea to   have your package directly depend on `coq-tactician`. Instead you should load   Tactician through your `coqrc` file. In order for your package to be compilable   by others, your package can depend on this package. Just add   `From Tactician import Ltac1Dummy` in your development and you are good to go.",,NA,False
coq-tactician-stdlib,https://coq-tactician.github.io,"*** WARNING *** This package will overwrite Coq's standard library files.    This package recompiles Coq's standard library with Tactician's (`coq-tactician`)   instrumentation loaded such that Tactician can learn from the library. When you   install this package, the current `.vo` files of the standard library are backed   in the folder `user-contrib/Tactician/stdlib-backup`. Then exactly the same `.vo`   files are installed, except that they also contain Tactician's tactic databases.   Upon removal of this package, the original files will be placed back.",,NA,False
coq-tait,https://github.com/coq-contribs/tait,"This is a formalization of Berger's TLCA'93 paper, with complete proofs of the axioms and an extraction of a normalization program close to N.B.E.","Pierre Letouzey, Helmut Schwichtenberg",03B38,False
coq-tarski-geometry,http://dpt-info.u-strasbg.fr/~narboux/tarski.html,"This is a formalization of geometry using a simplified version of Tarski's axiom system. The development contains a formalization of the chapters 1-8 of the book ""Metamathematische Methoden in der Geometrie"" by W. Schwabhäuser, W. Szmielew and A. Tarski. This includes between properties, congruence properties,   midpoint, perpendicular lines, point reflection, orthogonality ... This development aims to be a low level complement for Frédérique Guilhot's development about high-school geometry.  For more information see: Mechanical Theorem Proving in Tarski's geometry in the post-proceeding of ADG 2006, F. Botana and T. Recio (Eds.), LNAI 4869, pages 139-156, 2007.",Julien Narboux,51-xx,False
coq-template-coq,https://template-coq.github.io/template-coq,"Template Coq is a quoting library for Coq. It takes Coq terms and constructs a representation of their syntax tree as a Coq inductive data type. The representation is based on the kernel's term representation.  In addition to a complete reification and denotation of CIC terms, Template Coq includes:  - Reification of the environment structures, for constant and inductive declarations. - Denotation of terms and global declarations - A monad for manipulating global declarations, calling the type   checker, and inserting them in the global environment, in the style of   MetaCoq/MTac. - A partial type-checker for the Calculus of Inductive Constructions,   runnable as a plugin. - Example plugins built on top of this.","Abhishek Anand, Simon Boulier, Cyril Cohen, Gregory Malecha, Matthieu Sozeau, Nicolas Tabareau",None,False
coq-three-gap,https://github.com/coq-contribs/three-gap,This proof uses the real numbers. It is a classical proof.,Micaela Mayero,52-xx,False
coq-tlc,https://github.com/charguer/tlc,"Provides an alternative to the core of the Coq standard library, using classic definitions.",Arthur Charguéraud,NA,False
coq-topology,https://github.com/coq-community/topology,This library develops some of the basic concepts and results of general topology in Coq.,Daniel Schepler,22A05,True
coq-tortoise-hare-algorithm,https://github.com/coq-contribs/tortoise-hare-algorithm,"Correctness proof of Floyd's cycle-finding algorithm, also known as the ""tortoise and the hare""-algorithm. See http://en.wikipedia.org/wiki/Floyd's_cycle-finding_algorithm",Jean-Christophe Filliâtre,68Wxx,False
coq-traversable-fincontainer,https://github.com/oconnorr/traversable-fincontainer,A Coq proof that all Traversable functors are isomorphic to finitary containers.,Russell O'Connor,68Q65,False
coq-tree-automata,https://github.com/coq-contribs/tree-automata,"provides tree automatas algorithms in Coq (merge, intersection, vacuity test, deletion of empty states, coaccessiblity test, deletion of non coaccessible states)",Xavier Rival [http://www.eleves.ens.fr/home/rival],68Q45,False
coq-tree-calculus,https://github.com/barry-jay-personal/tree-calculus,"This library accompanies the book *Reflective Programs in Tree Calculus*.  In tree calculus, computations are given by natural trees, i.e. finitely-branching trees without labels. The functions, data structures, programs, inputs, outputs and values are all given by binary trees.  The trees are built as combinations of a single operator. It has three evaluation rules, for leaves stems and forks.  This is enough to support reflective programs such as a size function that can decide its own size,  an equality program that can decide its own equality, and self-evaluators than can evaluate themselves.  Since this does not require any meta-theory for, say, substitution, quotation, serialisation or Goedel numbers,  it is simpler and more powerful than traditional models of computation.    The organisation of the proofs is shown in the _CoqProject file, with one or two files per chapter.",Barry Jay,68N18,False
coq-tree-diameter,https://github.com/coq-contribs/tree-diameter,This contribution contains the verification of a divide-and-conquer algorithm to compute the diameter of a binary tree (the maxmimal distance between two nodes in the tree).,Jean-Christophe Filliâtre,68Wxx,False
coq-type-infer,https://github.com/fetburner/type-infer,A formal verification of algorithm W,Masayuki Mizuno,None,False
coq-typing-flags,https://github.com/SimonBoulier/TypingFlags,"A Coq plugin to disable positivity check, guard check and termination check",Simon Boulier,NA,False
coq-unicoq,https://github.com/unicoq/unicoq,An enhanced unification algorithm for Coq,"Matthieu Sozeau, Beta Ziliani",None,False
coq-unimath,https://github.com/UniMath/UniMath,Library of Univalent Mathematics,The UniMath Development Team,03F65,True
coq-unimath-category-theory,https://github.com/UniMath/UniMath,Aims to formalize a substantial body of mathematics using the univalent point of view,The UniMath Development Team,03F65,True
coq-unimath-dedekind,https://github.com/UniMath/UniMath,Aims to formalize a substantial body of mathematics using the univalent point of view,The UniMath Development Team,03F65,True
coq-unimath-foundations,https://github.com/UniMath/UniMath,Aims to formalize a substantial body of mathematics using the univalent point of view,The UniMath Development Team,03F65,True
coq-unimath-ktheory,https://github.com/UniMath/UniMath,Aims to formalize a substantial body of mathematics using the univalent point of view,The UniMath Development Team,03F65,True
coq-unimath-substitution-systems,https://github.com/UniMath/UniMath,Aims to formalize a substantial body of mathematics using the univalent point of view,The UniMath Development Team,03F65,True
coq-unimath-tactics,https://github.com/UniMath/UniMath,Aims to formalize a substantial body of mathematics using the univalent point of view,The UniMath Development Team,03F65,True
coq-universe-comparator,https://amintimany.github.io/UniverseComparator/html/test.html,A tool to compare universe levels in Coq,Amin Timany,None,False
coq-validsdp,https://sourcesup.renater.fr/validsdp/,"ValidSDP is a library for the Coq formal proof assistant. It provides reflexive tactics to prove multivariate inequalities involving real-valued variables and rational constants, using SDP solvers as untrusted back-ends and verified checkers based on libValidSDP.  Once installed, you can import the following modules: From Coq Require Import Reals. From ValidSDP Require Import validsdp.","Érik Martin-Dorel, Pierre Roux",NA,False
coq-verdi,https://github.com/uwplse/verdi,"Verdi is a Coq framework to implement and formally verify distributed systems. Verdi supports several different fault models ranging from idealistic to realistic. Verdi's verified system transformers (VSTs) encapsulate common fault tolerance techniques. Developers can verify an application in an idealized fault model, and then apply a VST to obtain an application that is guaranteed to have analogous properties in a more adversarial environment.","Justin Adsuara, Steve Anton, Ryan Doenges, Karl Palmskog, Pavel Panchekha, Zachary Tatlock, James R. Wilcox, Doug Woos",68Q85,False
coq-verdi-raft,https://github.com/uwplse/verdi-raft,"Raft is a distributed consensus algorithm that is designed to be easy to understand and is equivalent to Paxos in fault tolerance and performance. Verdi Raft is a verified implementation of Raft in Coq, constructed using the Verdi framework. Included is a verified fault-tolerant key-value store using Raft.","Justin Adsuara, Steve Anton, Ryan Doenges, Karl Palmskog, Pavel Panchekha, Zachary Tatlock, James R. Wilcox, Doug Woos",68Q85,False
coq-void,https://github.com/arthuraa/coq-void,MathComp instances for the empty type (Empty_set),Arthur Azevedo de Amorim,68Q65,False
coq-vst,http://vst.cs.princeton.edu/,"The software toolchain includes static analyzers to check assertions about your program; optimizing compilers to translate your program to machine language; operating systems and libraries to supply context for your program. The Verified Software Toolchain project assures with machine-checked proofs that the assertions claimed at the top of the toolchain really hold in the machine-language program, running in the operating-system context.","Andrew W. Appel, Lennart Beringer, Sandrine Blazy, Qinxiang Cao, Santiago Cuellar, Robert Dockins, Josiah Dodds, Nick Giannarakis, Samuel Gruetter, Aquinas Hobor, Jean-Marie Madiot, William Mansky",68Q55,False
coq-vst-32,http://vst.cs.princeton.edu/,"The software toolchain includes static analyzers to check assertions about your program; optimizing compilers to translate your program to machine language; operating systems and libraries to supply context for your program. The Verified Software Toolchain project assures with machine-checked proofs that the assertions claimed at the top of the toolchain really hold in the machine-language program, running in the operating-system context.","Andrew W. Appel, Lennart Beringer, Sandrine Blazy, Qinxiang Cao, Santiago Cuellar, Robert Dockins, Josiah Dodds, Nick Giannarakis, Samuel Gruetter, Aquinas Hobor, Jean-Marie Madiot, William Mansky",68Q55,False
coq-vst-64,http://vst.cs.princeton.edu/,"The software toolchain includes static analyzers to check assertions about your program; optimizing compilers to translate your program to machine language; operating systems and libraries to supply context for your program. The Verified Software Toolchain project assures with machine-checked proofs that the assertions claimed at the top of the toolchain really hold in the machine-language program, running in the operating-system context.","Andrew W. Appel, Lennart Beringer, Sandrine Blazy, Qinxiang Cao, Santiago Cuellar, Robert Dockins, Josiah Dodds, Nick Giannarakis, Samuel Gruetter, Aquinas Hobor, Jean-Marie Madiot, William Mansky",68Q55,False
coq-waterproof,https://github.com/impermeable/coq-waterproof,"The Waterproof library provides tactics, notations, and mathematical theories geared towards use in Mathematics educational environments. It aims to provide syntax such that proof scripts mimic handwritten mathematical proofs.","Jim Portegies, Cosmin Manea, Lulof Pirée, Adrian Vrămuleţ, Tudor Voicu",97-xx,False
coq-weak-up-to,http://perso.ens-lyon.fr/damien.pous/upto/,"This contribution is the formalisation of a paper that appeared in Proc. of ICALP 2005: ""Up-to Techniques for Weak Bisimulation"". First we define a framework for defining up-to techniques for weak bisimulation in a modular way. Then we prove the correctness of some new up-to techniques, based on termination guarantees. Notably, a generalisation of Newman's Lemma to commutation results is established.",Damien Pous,68Q85,False
coq-yalla,https://perso.ens-lyon.fr/olivier.laurent/yalla/,YALLA: an LL library for Coq   Yet Another deep embedding of Linear Logic in Coq,Olivier Laurent,03-xx,False
coq-zchinese,https://github.com/coq-contribs/zchinese,This is a rewriting of the contribution chinese-lemma using Zarith,Valérie Ménissier-Morain,11-xx,False
coq-zf,https://github.com/coq-contribs/zf,An axiomatisation of intuitionistic Zermelo-Fraenkel set theory,Guillaume Alexandre,03Exx,False
coq-zfc,https://github.com/coq-contribs/zfc,"The encoding of Zermelo-Fraenkel Set Theory is largely inspired by Peter Aczel's work dating back to the eighties. A type Ens is defined, which represents sets. Two predicates IN and EQ stand for membership and extensional equality between sets. The axioms of ZFC are then proved and thus appear as theorems in the development.    A main motivation for this work is the comparison of the respective expressive power of Coq and ZFC.    A non-computational type-theoretical axiom of choice is necessary to prove the replacement schemata and the set-theoretical AC.    The main difference between this work and Peter Aczel's is that propositions are defined on the impredicative level Prop. Since the definition of Ens is, however, still unchanged, I also added most of Peter Aczel's definition. The main advantage of Aczel's approach is a more constructive vision of the existential quantifier (which gives the set-theoretical axiom of choice for free).",Benjamin Werner,03Exx,False
coq-zorns-lemma,https://github.com/coq-community/topology,This Coq library develops some basic set theory. The main purpose the author had in writing it was as support for the Topology library.,Daniel Schepler,03Exx,False
coq-zsearch-trees,https://github.com/coq-contribs/zsearch-trees,"Algorithms for collecting, searching, inserting and deleting elements in binary search trees on Z",Pierre Castéran,68Q65,False
itauto,https://gitlab.inria.fr/fbesson/itauto,'itauto' is a reflexive SAT solver parameterised by a leaf tactic and Nelson-Oppen support,Frédéric Besson,None,False
menhir,http://gitlab.inria.fr/fpottier/menhir,An LR(1) parser generator,"François Pottier, Yann Régis-Gianas",None,False
menhirLib,http://gitlab.inria.fr/fpottier/menhir,Runtime support library for parsers generated by Menhir,"François Pottier, Yann Régis-Gianas",None,False
menhirSdk,http://gitlab.inria.fr/fpottier/menhir,Compile-time library for auxiliary tools related to Menhir,"François Pottier, Yann Régis-Gianas",None,False
