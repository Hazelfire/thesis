%% This BibTeX bibliography file was created using BibDesk.
%% http://bibdesk.sourceforge.net/

%% Created for Blayney Walshe at 2018-04-18 22:09:34 +1000 


%% Saved with string encoding Unicode (UTF-8) 

@inproceedings{bonacina_theorem_2010,
	address = {New York, NY, USA},
	series = {{PPDP} '10},
	title = {On {Theorem} {Proving} for {Program} {Checking}: {Historical} {Perspective} and {Recent} {Developments}},
	isbn = {978-1-4503-0132-9},
	doi = {10.1145/1836089.1836090},
	abstract = {This article is a survey of recent results, related works and new challenges in automated theorem proving for program checking. The aim is to give some historical perspective, albeit necessarily incomplete, and highlight some of the turning points that made crucial advances possible.},
	booktitle = {Proceedings of the 12th {International} {ACM} {SIGPLAN} {Symposium} on {Principles} and {Practice} of {Declarative} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Bonacina, Maria Paola},
	year = {2010},
	note = {event-place: Hagenberg, Austria},
	keywords = {combination of theories, rewrite-based theorem proving, satisfiability modulo theories, speculative inferences},
	pages = {1--12},
	file = {1836089.1836090.pdf:/home/sam/Books/1836089.1836090.pdf:application/pdf}
}

@inproceedings{hoare_verifying_2003,
	address = {Berlin, Heidelberg},
	title = {The {Verifying} {Compiler}: {A} {Grand} {Challenge} for {Computing} {Research}},
	isbn = {978-3-540-45213-3},
	abstract = {I propose a set of criteria which distinguish a grand challenge in science or engineering from the many other kinds of short-term or long-term research problems that engage the interest of scientists and engineers. As an example drawn from Computer Science, I revive an old challenge: the construction and application of a verifying compiler that guarantees correctness of a program before running it.},
	booktitle = {Modular {Programming} {Languages}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hoare, Tony},
	editor = {Böszörményi, László and Schojer, Peter},
	year = {2003},
	pages = {25--35},
	file = {2003_Book_ModularProgrammingLanguages.pdf:/home/sam/Books/2003_Book_ModularProgrammingLanguages.pdf:application/pdf}
}


@inproceedings{Rust,
	address = {New York, NY, USA},
	series = {{HILT} '14},
	title = {The {Rust} {Language}},
	isbn = {978-1-4503-3217-0},
	doi = {10.1145/2663171.2663188},
	abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety.Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
	booktitle = {Proceedings of the 2014 {ACM} {SIGAda} {Annual} {Conference} on {High} {Integrity} {Language} {Technology}},
	publisher = {Association for Computing Machinery},
	author = {Matsakis, Nicholas D. and Klock, Felix S.},
	year = {2014},
	note = {event-place: Portland, Oregon, USA},
	keywords = {affine type systems, memory management, rust, systems programming},
	pages = {103--104}
}

@misc{Elm,
  title = {Elm Book},
  author = {Evan Czaplicki},
  url = {https://guide.elm-lang.org/}
}

@inproceedings{Sel4,
	address = {New York, NY, USA},
	series = {{SOSP} '09},
	title = {{SeL4}: {Formal} {Verification} of an {OS} {Kernel}},
	isbn = {978-1-60558-752-3},
	doi = {10.1145/1629575.1629596},
	abstract = {Complete formal verification is the only known way to guarantee that a system is free of programming errors.We present our experience in performing the formal, machine-checked verification of the seL4 microkernel from an abstract specification down to its C implementation. We assume correctness of compiler, assembly code, and hardware, and we used a unique design approach that fuses formal and operating systems techniques. To our knowledge, this is the first formal proof of functional correctness of a complete, general-purpose operating-system kernel. Functional correctness means here that the implementation always strictly follows our high-level abstract specification of kernel behaviour. This encompasses traditional design and implementation safety properties such as the kernel will never crash, and it will never perform an unsafe operation. It also proves much more: we can predict precisely how the kernel will behave in every possible situation.seL4, a third-generation microkernel of L4 provenance, comprises 8,700 lines of C code and 600 lines of assembler. Its performance is comparable to other high-performance L4 kernels.},
	booktitle = {Proceedings of the {ACM} {SIGOPS} 22nd {Symposium} on {Operating} {Systems} {Principles}},
	publisher = {Association for Computing Machinery},
	author = {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal and Norrish, Michael and Sewell, Thomas and Tuch, Harvey and Winwood, Simon},
	year = {2009},
	note = {event-place: Big Sky, Montana, USA},
	keywords = {isabelle/hol, l4, microkernel, sel4},
	pages = {207--220}
}


@article{CompCert,
	title = {Formal verification of a realistic compiler},
	volume = {52},
	abstract = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
	number = {7},
	journal = {Communications of the ACM},
	author = {Leroy, Xavier},
	year = {2009},
	pages = {107--115}
}

@article{snook_practitioners_2001,
	title = {Practitioners' views on the use of formal methods: an industrial survey by structured interview},
	volume = {43},
	issn = {0950-5849},
	doi = {10.1016/S0950-5849(00)00166-X},
	abstract = {The recognised deficiency in the level of empirical investigation of software engineering methods is particularly acute in the area of formal methods, where reports about their usefulness vary widely. We interviewed several formal methods users about the use of formal methods and their impact on various aspects of software engineering including the effects on the company, its products and its development processes as well as pragmatic issues such as scalability, understandability and tool support. The interviews are a first stage of empirical assessment. Future work will investigate some of the issues raised using formal experimentation and case studies.},
	number = {4},
	journal = {Information and Software Technology},
	author = {Snook, C and Harrison, R},
	month = mar,
	year = {2001},
	keywords = {Empirical assessment, Formal methods, Structured interview, Survey},
	pages = {275--283},
}


@book{chlipala_certified_2013,
	address = {Cambridge, Massachusetts},
	title = {Certified programming with dependent types : a pragmatic introduction to the {Coq} proof assistant},
	isbn = {978-0-262-31787-0},
	abstract = {The technology of mechanized program verification can play a supporting role in many kinds of research projects in computer science, and related tools for formal proof-checking are seeing increasing adoption in mathematics and engineering. This book provides an introduction to the Coq software for writing and checking mathematical proofs. It takes a practical engineering focus throughout, emphasizing techniques that will help users to build, understand, and maintain large Coq developments and minimize the cost of code change over time. Two topics, rarely discussed elsewhere, are covered in detail: effective dependently typed programming (making productive use of a feature at the heart of the Coq system) and construction of domain-specific proof tactics. Almost every subject covered is also relevant to interactive computer theorem proving in general, not just program verification, demonstrated through examples of verified programs applied in many different sorts of formalizations. The book develops a unique automated proof style and applies it throughout; even experienced Coq users may benefit from reading about basic Coq concepts from this novel perspective. The book also offers a library of tactics, or programs that find proofs, designed for use with examples in the book. Readers will acquire the necessary skills to reimplement these tactics in other settings by the end of the book. All of the code appearing in the book is freely available online.},
	language = {eng},
	publisher = {MIT Press},
	author = {Chlipala, Adam, 1981- and Chlipala, Adam, 1981- author},
	year = {2013},
	note = {ISSN: 9780262026659},
	keywords = {Electronic books, Automatic theorem proving – Computer programs, Computer programming, Coq (Electronic resource)},
}


@inproceedings{aydemir_mechanized_2005,
	address = {Berlin, Heidelberg},
	title = {Mechanized {Metatheory} for the {Masses}: {The} {PoplMark} {Challenge}},
	isbn = {978-3-540-31820-0},
	abstract = {How close are we to a world where every paper on programming languages is accompanied by an electronic appendix with machine-checked proofs?},
	booktitle = {Theorem {Proving} in {Higher} {Order} {Logics}},
	publisher = {Springer Berlin Heidelberg},
	author = {Aydemir, Brian E. and Bohannon, Aaron and Fairbairn, Matthew and Foster, J. Nathan and Pierce, Benjamin C. and Sewell, Peter and Vytiniotis, Dimitrios and Washburn, Geoffrey and Weirich, Stephanie and Zdancewic, Steve},
	editor = {Hurd, Joe and Melham, Tom},
	year = {2005},
	pages = {50--65},
}


@inproceedings{bove_brief_2009,
	address = {Berlin, Heidelberg},
	title = {A {Brief} {Overview} of {Agda} – {A} {Functional} {Language} with {Dependent} {Types}},
	isbn = {978-3-642-03359-9},
	abstract = {We give an overview of Agda, the latest in a series of dependently typed programming languages developed in Gothenburg. Agda is based on Martin-Löf’s intuitionistic type theory but extends it with numerous programming language features. It supports a wide range of inductive data types, including inductive families and inductive-recursive types, with associated flexible pattern-matching. Unlike other proof assistants, Agda is not tactic-based. Instead it has an Emacs-based interface which allows programming by gradual refinement of incomplete type-correct terms.},
	booktitle = {Theorem {Proving} in {Higher} {Order} {Logics}},
	publisher = {Springer Berlin Heidelberg},
	author = {Bove, Ana and Dybjer, Peter and Norell, Ulf},
	editor = {Berghofer, Stefan and Nipkow, Tobias and Urban, Christian and Wenzel, Makarius},
	year = {2009},
	pages = {73--78},
}


@book{mcconnell_code_2004,
	address = {USA},
	title = {Code {Complete}, {Second} {Edition}},
	isbn = {0-7356-1967-0},
	abstract = {Take a strategic approach to software construction-and produce superior products-with this fully updated edition of Steve McConnell's critically praised and award-winning guide to software development best practices.},
	publisher = {Microsoft Press},
	author = {McConnell, Steve},
	year = {2004}
}


@article{nawaz_survey_2019,
	title = {A {Survey} on {Theorem} {Provers} in {Formal} {Methods}},
	author = {Nawaz, M. Saqib and Malik, Moin and Li, Yi and Sun, Meng and Lali, M. Ikram Ullah},
	year = {2019},
	note = {\_eprint: 1912.03028},
}


@book{clarke_jr_model_2018,
	title = {Model checking},
	publisher = {MIT press},
	author = {Clarke Jr, Edmund M and Grumberg, Orna and Kroening, Daniel and Peled, Doron and Veith, Helmut},
	year = {2018},
}

@article{formal_verification,
	title = {Formal verification: will the seedling ever flower?},
}

@inproceedings{marlow_haskell_2010,
	title = {Haskell 2010 {Language} {Report}},
	author = {Marlow, S.},
	year = {2010}
}


@inproceedings{hudak_history_2007,
	address = {New York, NY, USA},
	series = {{HOPL} {III}},
	title = {A {History} of {Haskell}: {Being} {Lazy} with {Class}},
	isbn = {978-1-59593-766-7},
	doi = {10.1145/1238844.1238856},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	booktitle = {Proceedings of the {Third} {ACM} {SIGPLAN} {Conference} on {History} of {Programming} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	year = {2007},
	note = {event-place: San Diego, California},
	pages = {12--1--12--55}
}


@article{lindley_hasochism_2013,
	title = {Hasochism: {The} {Pleasure} and {Pain} of {Dependently} {Typed} {Haskell} {Programming}},
	volume = {48},
	issn = {0362-1340},
	doi = {10.1145/2578854.2503786},
	abstract = {Haskell's type system has outgrown its Hindley-Milner roots to the extent that it now stretches to the basics of dependently typed programming. In this paper, we collate and classify techniques for programming with dependent types in Haskell, and contribute some new ones. In particular, through extended examples—merge-sort and rectangular tilings—we show how to exploit Haskell's constraint solver as a theorem prover, delivering code which, as Agda programmers, we envy. We explore the compromises involved in simulating variations on the theme of the dependent function space in an attempt to help programmers put dependent types to work, and to inform the evolving language design both of Haskell and of dependently typed languages more broadly.},
	number = {12},
	journal = {SIGPLAN Not.},
	author = {Lindley, Sam and McBride, Conor},
	month = sep,
	year = {2013},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {dependent types, singletons, data type promotion, invariants, proof search},
	pages = {81--92},
	file = {2503778.2503786.pdf:/home/sam/Books/2503778.2503786.pdf:application/pdf}
}

@incollection{kaufmann_acl2_2010,
	address = {Boston, MA},
	title = {{ACL2} and {Its} {Applications} to {Digital} {System} {Verification}},
	isbn = {978-1-4419-1539-9},
	abstract = {We describe a methodology for using a mechanical theorem proving system, ACL2, to verify correctness properties for digital system models. After introducing some of the basic terminology and some of the decisions facing those who wish to formalize digital systems, we introduce ACL2, A Computational Logic for Applicative Common Lisp, which is a functional programming language, a first-order mathematical logic, and a proof development environment including a powerful interactive automated theorem prover. We then show how a simple digital system can be formalized in ACL2 and exhibit or describe formal properties provable about it. We conclude with some bibliographic references to examples of variations of the illustrated approach, various proof strategies, and examples of industrial interest.},
	booktitle = {Design and {Verification} of {Microprocessor} {Systems} for {High}-{Assurance} {Applications}},
	publisher = {Springer US},
	author = {Kaufmann, Matt and Moore, J. Strother},
	editor = {Hardin, David S.},
	year = {2010},
	doi = {10.1007/978-1-4419-1539-9_1},
	pages = {1--21},
	file = {2010_Book_DesignAndVerificationOfMicropr.pdf:/home/sam/Books/2010_Book_DesignAndVerificationOfMicropr.pdf:application/pdf}
}

@article{moore_mechanically_1996,
	title = {A {Mechanically} {Checked} {Proof} of the {Correctness} of the {Kernel} of the {AMD5K86} {Floating}-{Point} {Division} {Algorithm}},
	volume = {47},
	journal = {IEEE Transactions on Computers},
	author = {Moore, J. Strother and Lynch, Tom and Kaufmann, Matt},
	year = {1996}
}

@article{swamy_dependent_2016,
	title = {Dependent {Types} and {Multi}-{Monadic} {Effects} in {F}*},
	volume = {51},
	issn = {0362-1340},
	doi = {10.1145/2914770.2837655},
	abstract = {We present a new, completely redesigned, version of F*, a language that works both as a proof assistant as well as a general-purpose, verification-oriented, effectful programming language. In support of these complementary roles, F* is a dependently typed, higher-order, call-by-value language with \_primitive\_ effects including state, exceptions, divergence and IO. Although primitive, programmers choose the granularity at which to specify effects by equipping each effect with a monadic, predicate transformer semantics. F* uses this to efficiently compute weakest preconditions and discharges the resulting proof obligations using a combination of SMT solving and manual proofs. Isolated from the effects, the core of F* is a language of pure functions used to write specifications and proof terms—its consistency is maintained by a semantic termination check based on a well-founded order. We evaluate our design on more than 55,000 lines of F* we have authored in the last year, focusing on three main case studies. Showcasing its use as a general-purpose programming language, F* is programmed (but not verified) in F*, and bootstraps in both OCaml and F\#. Our experience confirms F*'s pay-as-you-go cost model: writing idiomatic ML-like code with no finer specifications imposes no user burden. As a verification-oriented language, our most significant evaluation of F* is in verifying several key modules in an implementation of the TLS-1.2 protocol standard. For the modules we considered, we are able to prove more properties, with fewer annotations using F* than in a prior verified implementation of TLS-1.2. Finally, as a proof assistant, we discuss our use of F* in mechanizing the metatheory of a range of lambda calculi, starting from the simply typed lambda calculus to System F-omega and even micro-F*, a sizeable fragment of F* itself—these proofs make essential use of F*'s flexible combination of SMT automation and constructive proofs, enabling a tactic-free style of programming and proving at a relatively large scale.},
	number = {1},
	journal = {SIGPLAN Not.},
	author = {Swamy, Nikhil and Hriţcu, Cătălin and Keller, Chantal and Rastogi, Aseem and Delignat-Lavaud, Antoine and Forest, Simon and Bhargavan, Karthikeyan and Fournet, Cédric and Strub, Pierre-Yves and Kohlweiss, Markulf and Zinzindohoue, Jean-Karim and Zanella-Béguelin, Santiago},
	month = jan,
	year = {2016},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {proof assistants, verification, effectful programming},
	pages = {256--270}
}

@book{megill_metamath_2019,
	title = {Metamath: {A} {Computer} {Language} for {Mathematical} {Proofs}},
	isbn = {978-0-359-70223-7},
	url = {https://books.google.com.au/books?id=dxqeDwAAQBAJ},
	publisher = {Lulu.com},
	author = {Megill, N. and Wheeler, D.A.},
	year = {2019}
}

@article{bancerek_mizar_2018,
	title = {The {Role} of the {Mizar} {Mathematical} {Library} for {Interactive} {Proof} {Development} in {Mizar}},
	volume = {61},
	issn = {1573-0670},
	url = {https://doi.org/10.1007/s10817-017-9440-6},
	doi = {10.1007/s10817-017-9440-6},
	abstract = {The Mizar system is one of the pioneering systems aimed at supporting mathematical proof development on a computer that have laid the groundwork for and eventually have evolved into modern interactive proof assistants. We claim that an important milestone in the development of these systems was the creation of organized libraries accumulating all previously available formalized knowledge in such a way that new works could effectively re-use all previously collected notions. In the case of Mizar, the turning point of its development was the decision to start building the Mizar Mathematical Library as a centrally-managed knowledge base maintained together with the formalization language and the verification system. In this paper we show the process of forming this library, the evolution of its design principles, and also present some data showing its current use with the modern version of the Mizar proof checker, but also as a rich corpus of semantically linked mathematical data in various areas including web-based and natural language proof presentation, maths education, and machine learning based automated theorem proving.},
	number = {1},
	journal = {Journal of Automated Reasoning},
	author = {Bancerek, Grzegorz and Byliński, Czesław and Grabowski, Adam and Korniłowicz, Artur and Matuszewski, Roman and Naumowicz, Adam and Pąk, Karol},
	month = jun,
	year = {2018},
	pages = {9--32},
	file = {Bancerek2018_Article_TheRoleOfTheMizarMathematicalL.pdf:/home/sam/Books/Bancerek2018_Article_TheRoleOfTheMizarMathematicalL.pdf:application/pdf}
}


@inproceedings{slind_hol4_2008,
	address = {Berlin, Heidelberg},
	title = {A {Brief} {Overview} of {HOL4}},
	isbn = {978-3-540-71067-7},
	abstract = {The HOLF proof assistant supports specification and proof in classical higher order logic. It is the latest in a long line of similar systems. In this short overview, we give an outline of the HOLF system and how it may be applied in formal verification.},
	booktitle = {Theorem {Proving} in {Higher} {Order} {Logics}},
	publisher = {Springer Berlin Heidelberg},
	author = {Slind, Konrad and Norrish, Michael},
	editor = {Mohamed, Otmane Ait and Muñoz, César and Tahar, Sofiène},
	year = {2008},
	pages = {28--32},
	file = {2008_Book_TheoremProvingInHigherOrderLog.pdf:/home/sam/Books/2008_Book_TheoremProvingInHigherOrderLog.pdf:application/pdf}
}

@inproceedings{myreen_hoare_2007,
	address = {Berlin, Heidelberg},
	title = {Hoare {Logic} for {Realistically} {Modelled} {Machine} {Code}},
	isbn = {978-3-540-71209-1},
	abstract = {This paper presents a mechanised Hoare-style programming logic framework for assembly level programs. The framework has been designed to fit on top of operational semantics of realistically modelled machine code. Many ad hoc restrictions and features present in real machine-code are handled, including finite memory, data and code in the same memory space, the behavior of status registers and hazards of corrupting special purpose registers (e.g. the program counter, procedure return register and stack pointer). Despite accurately modeling such low level details, the approach yields concise specifications for machine-code programs without using common simplifying assumptions (like an unbounded state space). The framework is based on a flexible state representation in which functional and resource usage specifications are written in a style inspired by separation logic. The presented work has been formalised in higher-order logic, mechanised in the HOL4 system and is currently being used to verify ARM machine-code implementations of arithmetic and cryptographic operations.},
	booktitle = {Tools and {Algorithms} for the {Construction} and {Analysis} of {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Myreen, Magnus O. and Gordon, Michael J. C.},
	editor = {Grumberg, Orna and Huth, Michael},
	year = {2007},
	pages = {568--582},
	file = {2007_Book_ToolsAndAlgorithmsForTheConstr.pdf:/home/sam/Books/2007_Book_ToolsAndAlgorithmsForTheConstr.pdf:application/pdf}
}


@article{asperti_content_2000,
	title = {Content {Centric} {Logical} {Environments}},
	author = {Asperti, Andrea and Padovani, Luca and Sacerdoti Coen, Claudio and Schena, Irene},
	year = {2000},
	file = {Content_Centric_Logical_Environments.pdf:/home/sam/Books/Content_Centric_Logical_Environments.pdf:application/pdf}
}


@article{brady_idris_2013,
	title = {Idris, a general-purpose dependently typed programming language: {Design} and implementation},
	volume = {23},
	number = {5},
	journal = {Journal of functional programming},
	author = {Brady, Edwin},
	year = {2013},
	note = {Publisher: Cambridge University Press},
	pages = {552},
	file = {impldtp.pdf:/home/sam/Books/impldtp.pdf:application/pdf}
}


@book{wiedijk_seventeen_2006,
	title = {The seventeen provers of the world: {Foreword} by {Dana} {S}. {Scott}},
	volume = {3600},
	publisher = {Springer},
	author = {Wiedijk, Freek},
	year = {2006},
	file = {2006_Book_TheSeventeenProversOfTheWorld.pdf:/home/sam/Books/2006_Book_TheSeventeenProversOfTheWorld.pdf:application/pdf}
}


@incollection{nipkow_programming_2014,
	address = {Cham},
	title = {Programming and {Proving}},
	isbn = {978-3-319-10542-0},
	url = {https://doi.org/10.1007/978-3-319-10542-0_2},
	abstract = {This chapter introduces HOL as a functional programming language and shows how to prove properties of functional programs by induction.},
	booktitle = {Concrete {Semantics}: {With} {Isabelle}/{HOL}},
	publisher = {Springer International Publishing},
	author = {Nipkow, Tobias and Klein, Gerwin},
	year = {2014},
	doi = {10.1007/978-3-319-10542-0_2},
	pages = {5--25}
}


@book{tobias_nipkow_gerwin_klein_concrete_nodate,
	title = {Concrete {Semantics}},
	author = {{Tobias Nipkow, Gerwin Klein}},
	file = {concrete-semantics.pdf:/home/sam/Books/concrete-semantics.pdf:application/pdf}
}


@book{HACL,
	title = {{HACL}*: {A} {Verified} {Modern} {Cryptographic} {Library}},
	author = {Jean Karim Zinzindohoué, Karthikeyan Bhargavan, Jonathan Protzenko, Benjamin Beurdouche},
	year = {2017},
	note = {Published: Cryptology ePrint Archive, Report 2017/536},
	file = {2017-536.pdf:/home/sam/Books/2017-536.pdf:application/pdf}
}

@inproceedings{Lean,
	address = {Cham},
	title = {The {Lean} {Theorem} {Prover} ({System} {Description})},
	isbn = {978-3-319-21401-6},
	abstract = {Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.},
	booktitle = {Automated {Deduction} - {CADE}-25},
	publisher = {Springer International Publishing},
	author = {de Moura, Leonardo and Kong, Soonho and Avigad, Jeremy and van Doorn, Floris and von Raumer, Jakob},
	editor = {Felty, Amy P. and Middeldorp, Aart},
	year = {2015},
	pages = {378--388},
	file = {2015_Book_AutomatedDeduction-CADE-25.pdf:/home/sam/Books/2015_Book_AutomatedDeduction-CADE-25.pdf:application/pdf}
}


@inproceedings{harrison_history_2014,
	title = {History of {Interactive} {Theorem} {Proving}},
	booktitle = {Computational {Logic}},
	author = {Harrison, J. and Urban, J. and Wiedijk, F.},
	year = {2014},
	file = {joerg.pdf:/home/sam/Books/joerg.pdf:application/pdf}
}


@article{kreitz_nuprl_nodate,
	title = {The {Nuprl} {Proof} {Development} {System}, {Version} 5: {Reference} {Manual} and {User}’s {Guide}},
	author = {Kreitz, Christoph}
}


@inproceedings{slaney_minlog_1997,
	address = {Berlin, Heidelberg},
	title = {Minlog: {A} minimal logic theorem prover},
	isbn = {978-3-540-69140-2},
	abstract = {Minlog is a theorem prover for propositional minimal logic and Heyting's intuitionist logic. It implements a decision procedure based on a cut-free sequent calculus formulation of these systems. While the method it uses is rather unsophisticated, on small problems Minlog is fast. It achieves speed by being carefully coded (in C) and by eliminating many obvious redundancies in proof searches.},
	booktitle = {Automated {Deduction}—{CADE}-14},
	publisher = {Springer Berlin Heidelberg},
	author = {Slaney, John},
	editor = {McCune, William},
	year = {1997},
	pages = {268--271},
	file = {1997_Book_AutomatedDeductionCADE-14.pdf:/home/sam/Books/1997_Book_AutomatedDeductionCADE-14.pdf:application/pdf}
}



@phdthesis{kadoda_formal_1997,
	title = {Formal software development tools: an investigation into usability},
	url = {https://repository.lboro.ac.uk/articles/thesis/Formal_software_development_tools_an_investigation_into_usability/9407444},
	author = {Kadoda, Gada F.},
	year = {1997},
	file = {Thesis-1997-Kadoda.pdf:/home/sam/Books/Thesis-1997-Kadoda.pdf:application/pdf}
}


@phdthesis{zammit_readability_1999,
	address = {University of Kent},
	title = {On the {Readability} of {Machine} {Checkable} {Formal} {Proofs}},
	url = {https://kar.kent.ac.uk/21861/},
	abstract = {It is possible to implement mathematical proofs in a machine-readable language. Indeed, certain proofs, especially those deriving properties of safety-critical systems, are often required to be checked by machine in order to avoid human errors. However, machine checkable proofs are very hard to follow by a human reader. Because of their unreadability, such proofs are hard to implement, and more difficult still to maintain and modify. In this thesis we study the possibility of implementing machine checkable proofs in a more readable format. We design a declarative proof language, SPL, which is based on the Mizar language. We also implement a proof checker for SPL which derives theorems in the HOL system from SPL proof scripts. The language and its proof checker are extensible, in the sense that the user can modify and extend the syntax of the language and the deductive power of the proof checker during the mechanisation of a theory. A deductive database of trivial knowledge is used by the proof checker to derive facts which are considered trivial by the developer of mechanised theories so that the proofs of such facts can be omitted. We also introduce the notion of structured straightforward justifications, in which simple facts, or conclusions, are justified by a number of premises together with a number of inferences which are used in deriving the conclusion from the given premises. A tableau prover for first-order logic with equality is implemented as a HOL derived rule and used during the proof checking of SPL scripts. The work presented in this thesis also includes a case study involving the mechanisation of a number of results in group theory in SPL, in which the deductive power of the SPL proof checker is extended throughout the development of the theory.},
	author = {Zammit, Vincent},
	month = mar,
	year = {1999},
	file = {on_the_readability_of_machine_checkable_zammit.pdf:/home/sam/Books/on_the_readability_of_machine_checkable_zammit.pdf:application/pdf}
}


@inproceedings{kadoda_desirable_1999,
	title = {Desirable features of educational theorem provers - a cognitive dimensions viewpoint},
	booktitle = {{PPIG}},
	author = {Kadoda, Gada F. and Stone, R. and Diaper, D.},
	year = {1999},
	file = {Kadoda - Desirable features of educational theorem provers.pdf:/home/sam/Books/Kadoda - Desirable features of educational theorem provers.pdf:application/pdf}
}


@inproceedings{beckert_usability_2015,
	address = {Cham},
	title = {A {Usability} {Evaluation} of {Interactive} {Theorem} {Provers} {Using} {Focus} {Groups}},
	isbn = {978-3-319-15201-1},
	abstract = {The effectiveness of interactive theorem provers (ITPs) increased such that the bottleneck in the proof process shifted from effectiveness to efficiency. While in principle large theorems are provable, it takes much effort for the user to interact with the system. A major obstacle for the user is to understand the proof state in order to guide the prover in successfully finding a proof. We conducted two focus groups to evaluate the usability of ITPs. We wanted to evaluate the impact of the gap between the user’s model of the proof and the actual proof performed by the provers’ strategies. In addition, our goals are to explore which mechanisms already exist and to develop, based on the existing mechanisms, new mechanisms that help the user in bridging this gap.},
	booktitle = {Software {Engineering} and {Formal} {Methods}},
	publisher = {Springer International Publishing},
	author = {Beckert, Bernhard and Grebing, Sarah and Böhl, Florian},
	editor = {Canal, Carlos and Idani, Akram},
	year = {2015},
	pages = {3--19},
	file = {2015_Book_SoftwareEngineeringAndFormalMe.pdf:/home/sam/Books/2015_Book_SoftwareEngineeringAndFormalMe.pdf:application/pdf}
}


@article{green_usability_1996,
	title = {Usability {Analysis} of {Visual} {Programming} {Environments}: {A} ‘{Cognitive} {Dimensions}’ {Framework}},
	volume = {7},
	issn = {1045-926X},
	url = {https://www.sciencedirect.com/science/article/pii/S1045926X96900099},
	doi = {https://doi.org/10.1006/jvlc.1996.0009},
	abstract = {The cognitive dimensions framework is a broad-brush evaluation technique for interactive devices and for non-interactive notations. It sets out a small vocabulary of terms designed to capture the cognitively-relevant aspects of structure, and shows how they can be traded off against each other. The purpose of this paper is to propose the framework as an evaluation technique for visual programming environments. We apply it to two commercially-available dataflow languages (with further examples from other systems) and conclude that it is effective and insightful; other HCI-based evaluation techniques focus on different aspects and would make good complements. Insofar as the examples we used are representative, current VPLs are successful in achieving a good ‘closeness of match’, but designers need to consider the ‘viscosity ’ (resistance to local change) and the ‘secondary notation’ (possibility of conveying extra meaning by choice of layout, colour, etc.).},
	number = {2},
	journal = {Journal of Visual Languages \& Computing},
	author = {Green, T. R. G. and Petre, M.},
	year = {1996},
	pages = {131--174},
	file = {cognitivedimensions.pdf:/home/sam/Books/cognitivedimensions.pdf:application/pdf}
}


@inproceedings{posnett_simpler_2011,
	address = {New York, NY, USA},
	series = {{MSR} '11},
	title = {A {Simpler} {Model} of {Software} {Readability}},
	isbn = {978-1-4503-0574-7},
	url = {https://doi.org/10.1145/1985441.1985454},
	doi = {10.1145/1985441.1985454},
	abstract = {Software readability is a property that influences how easily a given piece of code can be read and understood. Since readability can affect maintainability, quality, etc., programmers are very concerned about the readability of code. If automatic readability checkers could be built, they could be integrated into development tool-chains, and thus continually inform developers about the readability level of the code. Unfortunately, readability is a subjective code property, and not amenable to direct automated measurement. In a recently published study, Buse et al. asked 100 participants to rate code snippets by readability, yielding arguably reliable mean readability scores of each snippet; they then built a fairly complex predictive model for these mean scores using a large, diverse set of directly measurable source code properties. We build on this work: we present a simple, intuitive theory of readability, based on size and code entropy, and show how this theory leads to a much sparser, yet statistically significant, model of the mean readability scores produced in Buse's studies. Our model uses well-known size metrics and Halstead metrics, which are easily extracted using a variety of tools. We argue that this approach provides a more theoretically well-founded, practically usable, approach to readability measurement.},
	booktitle = {Proceedings of the 8th {Working} {Conference} on {Mining} {Software} {Repositories}},
	publisher = {Association for Computing Machinery},
	author = {Posnett, Daryl and Hindle, Abram and Devanbu, Premkumar},
	year = {2011},
	note = {event-place: Waikiki, Honolulu, HI, USA},
	keywords = {entropy, halstead, readability, replication},
	pages = {73--82}
}


@article{buse_learning_2010,
	title = {Learning a {Metric} for {Code} {Readability}},
	volume = {36},
	doi = {10.1109/TSE.2009.70},
	number = {4},
	journal = {IEEE Transactions on Software Engineering},
	author = {Buse, R. P. L. and Weimer, W. R.},
	year = {2010},
	pages = {546--558},
	file = {weimer-tse2010-readability-preprint.pdf:/home/sam/Books/weimer-tse2010-readability-preprint.pdf:application/pdf}
}


@book{halstead_elements_1977,
	address = {USA},
	title = {Elements of {Software} {Science} ({Operating} and {Programming} {Systems} {Series})},
	isbn = {0-444-00205-7},
	publisher = {Elsevier Science Inc.},
	author = {Halstead, Maurice H.},
	year = {1977}
}


@article{turing_computability_1937,
	title = {Computability and λ-{Definability}},
	volume = {2},
	issn = {00224812},
	url = {http://www.jstor.org/stable/2268280},
	doi = {10.2307/2268280},
	number = {4},
	urldate = {2021-03-01},
	journal = {The Journal of Symbolic Logic},
	author = {Turing, A. M.},
	year = {1937},
	note = {Publisher: [Association for Symbolic Logic, Cambridge University Press]},
	pages = {153--163}
}

@article{church_formulation_1940,
	title = {A {Formulation} of the {Simple} {Theory} of {Types}},
	volume = {5},
	issn = {00224812},
	url = {http://www.jstor.org/stable/2266170},
	doi = {10.2307/2266170},
	number = {2},
	urldate = {2021-03-01},
	journal = {The Journal of Symbolic Logic},
	author = {Church, Alonzo},
	year = {1940},
	note = {Publisher: Association for Symbolic Logic},
	pages = {56--68}
}

@article{mccarthy_history_1978,
	title = {History of {LISP}},
	volume = {13},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/960118.808387},
	doi = {10.1145/960118.808387},
	abstract = {This paper concentrates on the development of the basic ideas and distinguishes two periods - Summer 1958 through Summer 1958 when most of the key ideas were developed (some of which were implemented in the FORTRAN based FLPL), and Fall 1958 through 1962 when the programming language was implemented and applied to problems of artificial intelligence. After 1962, the development of LISP became multi-stranded, and different ideas were pursued in different places.},
	number = {8},
	journal = {SIGPLAN Not.},
	author = {McCarthy, John},
	month = aug,
	year = {1978},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	pages = {217--223}
}


@article{j_m_wing_specifiers_1990,
	title = {A specifier's introduction to formal methods},
	volume = {23},
	issn = {1558-0814},
	doi = {10.1109/2.58215},
	number = {9},
	journal = {Computer},
	author = {{J. M. Wing}},
	month = sep,
	year = {1990},
	pages = {8--22},
	file = {00058215.pdf:/home/sam/Books/00058215.pdf:application/pdf}
}

@book{potter_introduction_1992,
	address = {USA},
	title = {An {Introduction} to {Formal} {Specification} and {Z}},
	isbn = {0-13-478702-1},
	publisher = {Prentice-Hall, Inc.},
	author = {Potter, Ben and Sinclair, Jane and Till, David},
	year = {1992}
}

@book{jones_systematic_1990,
	address = {USA},
	title = {Systematic {Software} {Development} {Using} {VDM} (2nd {Ed}.)},
	isbn = {0-13-880733-7},
	publisher = {Prentice-Hall, Inc.},
	author = {Jones, Cliff B.},
	year = {1990}
}


@book{baier_principles_2008,
	title = {Principles of {Model} {Checking} ({Representation} and {Mind} {Series})},
	isbn = {0-262-02649-X},
	abstract = {Our growing dependence on increasingly complex computer and software systems necessitates the development of formalisms, techniques, and tools for assessing functional properties of these systems. One such technique that has emerged in the last twenty years is model checking, which systematically (and automatically) checks whether a model of a given system satisfies a desired property such as deadlock freedom, invariants, or request-response properties. This automated technique for verification and debugging has developed into a mature and widely used approach with many applications. Principles of Model Checking offers a comprehensive introduction to model checking that is not only a text suitable for classroom use but also a valuable reference for researchers and practitioners in the field. The book begins with the basic principles for modeling concurrent and communicating systems, introduces different classes of properties (including safety and liveness), presents the notion of fairness, and provides automata-based algorithms for these properties. It introduces the temporal logics LTL and CTL, compares them, and covers algorithms for verifying these logics, discussing real-time systems as well as systems subject to random phenomena. Separate chapters treat such efficiency-improving techniques as abstraction and symbolic manipulation. The book includes an extensive set of examples (most of which run through several chapters) and a complete set of basic results accompanied by detailed proofs. Each chapter concludes with a summary, bibliographic notes, and an extensive list of exercises of both practical and theoretical nature.},
	publisher = {The MIT Press},
	author = {Baier, Christel and Katoen, Joost-Pieter},
	year = {2008}
}


@article{aitken_analysis_2000,
	title = {An analysis of errors in interactive proof attempts},
	volume = {12},
	doi = {10.1016/S0953-5438(99)00023-5},
	number = {6},
	journal = {Interacting with Computers},
	author = {Aitken, S. and Melham, T.},
	year = {2000},
	pages = {565--586},
	file = {sdarticle6.pdf:/home/sam/Books/sdarticle6.pdf:application/pdf}
}


@inproceedings{beckert_evaluating_2012,
	title = {Evaluating the {Usability} of {Interactive} {Verification} {Systems}},
	booktitle = {{COMPARE}},
	author = {Beckert, Bernhard and Grebing, S.},
	year = {2012},
	file = {paper_4.pdf:/home/sam/Books/paper_4.pdf:application/pdf}
}


@article{beckert_how_2014,
	title = {How to {Put} {Usability} into {Focus}: {Using} {Focus} {Groups} to {Evaluate} the {Usability} of {Interactive} {Theorem} {Provers}},
	volume = {167},
	issn = {2075-2180},
	url = {http://dx.doi.org/10.4204/EPTCS.167.3},
	doi = {10.4204/eptcs.167.3},
	journal = {Electronic Proceedings in Theoretical Computer Science},
	author = {Beckert, Bernhard and Grebing, Sarah and Böhl, Florian},
	month = oct,
	year = {2014},
	note = {Publisher: Open Publishing Association},
	pages = {4--13},
	file = {1410.8215.pdf:/home/sam/Books/1410.8215.pdf:application/pdf}
}


@inproceedings{hentschel_empirical_2016,
	address = {New York, NY, USA},
	series = {{ASE} 2016},
	title = {An {Empirical} {Evaluation} of {Two} {User} {Interfaces} of an {Interactive} {Program} {Verifier}},
	isbn = {978-1-4503-3845-5},
	doi = {10.1145/2970276.2970303},
	abstract = {Theorem provers have highly complex interfaces, but there are not many systematic studies of their usability and effectiveness. Specifically, for interactive theorem provers the ability to quickly comprehend intermediate proof situations is of pivotal importance. In this paper we present the (as far as we know) first empirical study that systematically compares the effectiveness of different user interfaces of an interactive theorem prover. We juxtapose two different user interfaces of the interactive verifier KeY: the traditional one which focuses on proof objects and a more recent one that provides a view akin to an interactive debugger. We carefully designed a controlled experiment where users were given various proof understanding tasks that had to be solved with alternating interfaces. We provide statistical evidence that the conjectured higher effectivity of the debugger-like interface is not just a hunch.},
	booktitle = {Proceedings of the 31st {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Hentschel, Martin and Hähnle, Reiner and Bubel, Richard},
	year = {2016},
	note = {event-place: Singapore, Singapore},
	keywords = {Empirical Evaluation, Proof Understanding, Verification},
	pages = {403--413},
	file = {interfaceevaluation.pdf:/home/sam/Books/interfaceevaluation.pdf:application/pdf}
}


@incollection{grebing_usability_2020,
	address = {Cham},
	title = {Usability {Recommendations} for {User} {Guidance} in {Deductive} {Program} {Verification}},
	isbn = {978-3-030-64354-6},
	url = {https://doi.org/10.1007/978-3-030-64354-6_11},
	abstract = {Despite the increasing degree of automation, user input for guiding proof search and construction is still needed in interactive deductive program verification systems, even more so as the size of the investigated programs gets larger and the properties to be verified gain in complexity. We will present recommendations for the design of user interfaces in deductive program verification systems. The goal is to always provide the user with an easy but in depth understanding of the current proof status and guide him towards next expedient interactions. These recommendations are conclusions from a qualitative study with users of the KeY system and from our own experience in using and building different interactive verification systems. We will present the user study together with a summary of the main observations and insights.},
	booktitle = {Deductive {Software} {Verification}: {Future} {Perspectives}: {Reflections} on the {Occasion} of 20 {Years} of {KeY}},
	publisher = {Springer International Publishing},
	author = {Grebing, Sarah and Ulbrich, Mattias},
	editor = {Ahrendt, Wolfgang and Beckert, Bernhard and Bubel, Richard and Hähnle, Reiner and Ulbrich, Mattias},
	year = {2020},
	doi = {10.1007/978-3-030-64354-6_11},
	pages = {261--284},
	file = {978-3-030-64354-6.pdf:/home/sam/Books/978-3-030-64354-6.pdf:application/pdf}
}


@inproceedings{grebing_seamless_2020,
	address = {Cham},
	title = {Seamless {Interactive} {Program} {Verification}},
	isbn = {978-3-030-41600-3},
	abstract = {Deductive program verification has made considerable progress in recent years. Automation is the goal, but it is apparent that there will always be challenges that cannot be verified fully automatically, but require some form of user input. We present a novel user interaction concept that allows the user to interact with the verification system on different abstraction levels and on different verification/proof artifacts. The elements of the concept are based on the findings of qualitative user studies we conducted amongst users of interactive deductive program verification systems. Moreover, the concept implements state-of-the-art user interaction principles. We prototypically implemented our concept as an interactive verification tool for Dafny programs.},
	booktitle = {Verified {Software}. {Theories}, {Tools}, and {Experiments}},
	publisher = {Springer International Publishing},
	author = {Grebing, Sarah and Klamroth, Jonas and Ulbrich, Mattias},
	editor = {Chakraborty, Supratik and Navas, Jorge A.},
	year = {2020},
	pages = {68--86},
	file = {978-3-030-41600-3.pdf:/home/sam/Books/978-3-030-41600-3.pdf:application/pdf}
}


@article{aitken_interactive_1998,
	title = {Interactive {Theorem} {Proving}: {An} {Empirical} {Study} of {User} {Activity}},
	volume = {25},
	issn = {0747-7171},
	url = {https://www.sciencedirect.com/science/article/pii/S0747717197901759},
	doi = {https://doi.org/10.1006/jsco.1997.0175},
	abstract = {In this paper the interaction between users and the interactive theorem prover HOL is investigated from a human–computer interaction perspective. First, we outline three possible views of interaction, and give a brief survey of some current interfaces and how they may be described in terms of these views. Second, we describe and present the results of an empirical study of intermediate and expert HOL users. The results are analysed for evidence in support of the proposed view of proof activity in HOL. We believe that this approach provides a principled basis for the assessment and design of interfaces to theorem provers.},
	number = {2},
	journal = {Journal of Symbolic Computation},
	author = {Aitken, J. S. and Gray, P. and Melham, T. and Thomas, M.},
	year = {1998},
	pages = {263--284},
	file = {1-s2.0-S0747717197901759-main.pdf:/home/sam/Books/1-s2.0-S0747717197901759-main.pdf:application/pdf}
}


@inproceedings{asperti_considerations_2010,
	address = {Berlin, Heidelberg},
	series = {{AISC}'10/{MKM}'10/{Calculemus}'10},
	title = {Some {Considerations} on the {Usability} of {Interactive} {Provers}},
	isbn = {3-642-14127-7},
	abstract = {In spite of the remarkable achievements recently obtained in the field of mechanization of formal reasoning, the overall usability of interactive provers does not seem to be sensibly improved since the advent of the "second generation" of systems, in the mid of the eighties. We try to analyze the reasons of such a slow progress, pointing out the main problems and suggesting some possible research directions.},
	booktitle = {Proceedings of the 10th {ASIC} and 9th {MKM} {International} {Conference}, and 17th {Calculemus} {Conference} on {Intelligent} {Computer} {Mathematics}},
	publisher = {Springer-Verlag},
	author = {Asperti, Andrea and Coen, Claudio Sacerdoti},
	year = {2010},
	note = {event-place: Paris, France},
	pages = {147--156},
	file = {Some_Considerations_on_the_Usability_of_Interactiv.pdf:/home/sam/Books/Some_Considerations_on_the_Usability_of_Interactiv.pdf:application/pdf}
}


@inproceedings{lowe_lessons_1996,
	title = {Lessons from experience: making theorem provers more co-operative.},
	author = {Lowe, Helene and Cumming, A. and Smyth, M. and Varey, A.},
	year = {1996},
	file = {itpcooperative.pdf:/home/sam/Books/itpcooperative.pdf:application/pdf}
}


@book{benzmuller_blackboard_1998,
	series = {Lecture {Notes} in {Computer} {Science} (including subseries {Lecture} {Notes} in {Artificial} {Intelligence} and {Lecture} {Notes} in {Bioinformatics})},
	title = {A blackboard architecture for guiding interactive proofs},
	volume = {1480 LNAI},
	url = {https://www.scopus.com/inward/record.uri?eid=2-s2.0-84867755103&doi=10.1007%2fbfb0057438&partnerID=40&md5=c5a96dde947b49099f33943d1688fca0},
	author = {Benzmüller, C. and Sorge, V.},
	year = {1998},
	doi = {10.1007/bfb0057438},
	note = {Pages: 114},
	annote = {Cited By :12},
	annote = {Export Date: 12 March 2021},
	file = {BFb0057438.pdf:/home/sam/Books/BFb0057438.pdf:application/pdf}
}


@inproceedings{merriam_evaluating_1996,
	address = {Vienna},
	title = {Evaluating the {Interfaces} of {Three} {Theorem} {Proving} {Assistants}},
	isbn = {978-3-7091-7491-3},
	abstract = {A first step in systematically engineering better interfaces for theorem proving assistants (TPAs) is to assess what has already been achieved in the domain. We examine three TPAs employing quite different styles of interaction. We consider the support provided by the interfaces for each of four mechanisms for efficient interactive proof: planning, reuse, reflection and articulation. Common themes are observed, as are strengths and weaknesses of the interfaces and we discuss the general issues, attempting to abstract away from the particular artifacts studied.},
	booktitle = {Design, {Specification} and {Verification} of {Interactive} {Systems} ’96},
	publisher = {Springer Vienna},
	author = {Merriam, Nicholas A. and Harrison, Michael D.},
	editor = {Bodart, Francois and Vanderdonckt, Jean},
	year = {1996},
	pages = {330--346},
	file = {978-3-7091-7491-3.pdf:/home/sam/Books/978-3-7091-7491-3.pdf:application/pdf}
}

@article{kitchenham_evaluating_2008,
	title = {Evaluating guidelines for reporting empirical software engineering studies},
	volume = {13},
	issn = {1573-7616},
	url = {https://doi.org/10.1007/s10664-007-9053-5},
	doi = {10.1007/s10664-007-9053-5},
	abstract = {Several researchers have criticized the standards of performing and reporting empirical studies in software engineering. In order to address this problem, Jedlitschka and Pfahl have produced reporting guidelines for controlled experiments in software engineering. They pointed out that their guidelines needed evaluation. We agree that guidelines need to be evaluated before they can be widely adopted.},
	number = {1},
	journal = {Empirical Software Engineering},
	author = {Kitchenham, Barbara and Al-Khilidar, Hiyam and Babar, Muhammed Ali and Berry, Mike and Cox, Karl and Keung, Jacky and Kurniawati, Felicia and Staples, Mark and Zhang, He and Zhu, Liming},
	month = feb,
	year = {2008},
	pages = {97--121},
}



@inproceedings{runge_comparing_2020,
	address = {Cham},
	title = {Comparing {Correctness}-by-{Construction} with {Post}-{Hoc} {Verification}—{A} {Qualitative} {User} {Study}},
	isbn = {978-3-030-54997-8},
	abstract = {Correctness-by-construction (CbC) is a refinement-based methodology to incrementally create formally correct programs. Programs are constructed using refinement rules which guarantee that the resulting implementation is correct with respect to a pre-/postcondition specification. In contrast, with post-hoc verification (PhV) a specification and a program are created, and afterwards verified that the program satisfies the specification. In the literature, both methods are discussed with specific advantages and disadvantages. By letting participants construct and verify programs using CbC and PhV in a controlled experiment, we analyzed the claims in the literature. We evaluated defects in intermediate code snapshots and discovered a trial-and-error construction process to alter code and specification. The participants appreciated the good feedback of CbC and state that CbC is better than PhV in helping to find defects. Nevertheless, some defects in the constructed programs with CbC indicate that the participants need more time to adapt the CbC process.},
	booktitle = {Formal {Methods}. {FM} 2019 {International} {Workshops}},
	publisher = {Springer International Publishing},
	author = {Runge, Tobias and Thüm, Thomas and Cleophas, Loek and Schaefer, Ina and Watson, Bruce W.},
	editor = {Sekerinski, Emil and Moreira, Nelma and Oliveira, José N. and Ratiu, Daniel and Guidotti, Riccardo and Farrell, Marie and Luckcuck, Matt and Marmsoler, Diego and Campos, José and Astarte, Troy and Gonnord, Laure and Cerone, Antonio and Couto, Luis and Dongol, Brijesh and Kutrib, Martin and Monteiro, Pedro and Delmas, David},
	year = {2020},
	pages = {388--405},
}

@incollection{hahnle_deductive_2019,
	address = {Cham},
	title = {Deductive {Software} {Verification}: {From} {Pen}-and-{Paper} {Proofs} to {Industrial} {Tools}},
	isbn = {978-3-319-91908-9},
	url = {https://doi.org/10.1007/978-3-319-91908-9_18},
	abstract = {Deductive software verification aims at formally verifying that all possible behaviors of a given program satisfy formally defined, possibly complex properties, where the verification process is based on logical inference. We follow the trajectory of the field from its inception in the late 1960s via its current state to its promises for the future, from pen-and-paper proofs for programs written in small, idealized languages to highly automated proofs of complex library or system code written in mainstream languages. We take stock of the state-of-art and give a list of the most important challenges for the further development of the field of deductive software verification.},
	booktitle = {Computing and {Software} {Science}: {State} of the {Art} and {Perspectives}},
	publisher = {Springer International Publishing},
	author = {Hähnle, Reiner and Huisman, Marieke},
	editor = {Steffen, Bernhard and Woeginger, Gerhard},
	year = {2019},
	doi = {10.1007/978-3-319-91908-9_18},
	pages = {345--373},
}


@article{spichkova_human-centred_2017,
	title = {Human-centred analysis of the dependencies within sets of proofs},
	volume = {112},
	issn = {1877-0509},
	url = {https://www.sciencedirect.com/science/article/pii/S1877050917316654},
	doi = {10.1016/j.procs.2017.08.256},
	abstract = {A failure in safety-critical systems, such as vehicles, aircrafts, etc., may endanger human lives. It is crucial that these system behave correctly, in accordance to their specification and fulfilling all the safety-critical properties defined for them. Safety could be guaranteed through the application of analysis techniques, in the form of formal verification and testing. However, verification of a real-size system means having a large number of lemmas, depending on each other. An update in one lemma might require changes in many other lemmas. It would be inefficient to find the existing dependencies out when the proof process is already running. We present a methodology for analysis of the dependencies between lemmas within the provided set of proofs. The application of this methodology to the Isabelle/HOL theories is supported by a tool. The tool provides a quick automated analysis and easy-to-check representation of the results, as well as allows optimisation of the provided set of proofs.},
	journal = {Knowledge-Based and Intelligent Information \& Engineering Systems: Proceedings of the 21st International Conference, KES-20176-8 September 2017, Marseille, France},
	author = {Spichkova, Maria and Simic, Milan},
	month = jan,
	year = {2017},
	keywords = {Analysis, Intelligent systems, Modelling, Usability, Verification},
	pages = {2290--2298},
}

@inproceedings{Mitsch2016TheKX,
  title={The KeYmaera X Proof IDE - Concepts on Usability in Hybrid Systems Theorem Proving},
  author={Stefan Mitsch and A. Platzer},
  booktitle={F-IDE@FM},
  year={2016}
}

@MISC{Kadoda00acognitive,
    author = {Gada Kadoda},
    title = {A Cognitive Dimensions view of the differences between designers and users of theorem proving assistants},
    year = {2000}
}

@book{berman_development_2014,
	title = {Development and user testing of new user interfaces for mathematics and programming tools},
	abstract = {{\textless}p{\textgreater}Interactive theorem provers are software tools that help users create machine-checked proofs. Although difficult to use, they have been playing an important role in the effort to create highly reliable software. I present several novel user interface ideas for interactive theorem provers, generalizable to other mathematics and programming tools. Prototypes tailored to the Coq interactive theorem prover were developed and tested in an experiment with human participants. The results show promising directions for making interactive theorem provers easier to use.{\textless}/p{\textgreater}},
	language = {eng},
	publisher = {University of Iowa},
	author = {Berman, Benjamin Alexander},
	keywords = {Computer Sciences},
	year = {2014}
}


@book{kadoda_cognitive_2000,
	title = {A {Cognitive} {Dimensions} view of the differences between designers and users of theorem proving assistants},
	author = {Kadoda, Gada},
	year = {2000}
}


@phdthesis{zacchiroli_user_2007,
	type = {{PhD} {Thesis}},
	title = {User interaction widgets for interactive theorem proving},
	url = {http://amsdottorato.unibo.it/616/},
	school = {alma},
	author = {Zacchiroli, Stefano},
	month = apr,
	year = {2007},
	keywords = {Interactive theorem proving User interaction Mathematical knowledge Management}
}


@article{asperti_user_2007,
	title = {User {Interaction} with the {Matita} {Proof} {Assistant}},
	volume = {39},
	issn = {1573-0670},
	url = {https://doi.org/10.1007/s10817-007-9070-5},
	doi = {10.1007/s10817-007-9070-5},
	abstract = {Matita is a new, document-centric, tactic-based interactive theorem prover. This paper focuses on some of the distinctive features of the user interaction with Matita, characterized mostly by the organization of the library as a searchable knowledge base, the emphasis on a high-quality notational rendering, and the complex interplay between syntax, presentation, and semantics.},
	number = {2},
	journal = {Journal of Automated Reasoning},
	author = {Asperti, Andrea and Sacerdoti Coen, Claudio and Tassi, Enrico and Zacchiroli, Stefano},
	month = aug,
	year = {2007},
	pages = {109--139}
}


@inproceedings{nagashima_pamper_2018,
	address = {New York, NY, USA},
	series = {{ASE} 2018},
	title = {{PaMpeR}: {Proof} {Method} {Recommendation} {System} for {Isabelle}/{HOL}},
	isbn = {978-1-4503-5937-5},
	url = {https://doi-org.ezproxy.lib.rmit.edu.au/10.1145/3238147.3238210},
	doi = {10.1145/3238147.3238210},
	abstract = {Deciding which sub-tool to use for a given proof state requires expertise specific to each interactive theorem prover (ITP). To mitigate this problem, we present PaMpeR , a proof method recommendation system for Isabelle/HOL. Given a proof state, PaMpeR recommends proof methods to discharge the proof goal and provides qualitative explanations as to why it suggests these methods. PaMpeR generates these recommendations based on existing hand-written proof corpora, thus transferring experienced users’ expertise to new users. Our evaluation shows that PaMpeR correctly predicts experienced users’ proof methods invocation especially when it comes to special purpose proof methods.},
	booktitle = {Proceedings of the 33rd {ACM}/{IEEE} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Nagashima, Yutaka and He, Yilun},
	year = {2018},
	note = {event-place: Montpellier, France},
	keywords = {data mining, interactive theorem prover, Isabelle/HOL, proof method, recommendation system},
	pages = {362--372}
}


@article{mitsch_keymaera_2017,
	title = {The {KeYmaera} {X} {Proof} {IDE} - {Concepts} on {Usability} in {Hybrid} {Systems} {Theorem} {Proving}},
	volume = {240},
	issn = {2075-2180},
	url = {http://dx.doi.org/10.4204/EPTCS.240.5},
	doi = {10.4204/eptcs.240.5},
	journal = {Electronic Proceedings in Theoretical Computer Science},
	author = {Mitsch, Stefan and Platzer, André},
	month = jan,
	year = {2017},
	note = {Publisher: Open Publishing Association},
	pages = {67--81}
}

@inproceedings{bourke_challenges_2012,
	address = {Berlin, Heidelberg},
	title = {Challenges and {Experiences} in {Managing} {Large}-{Scale} {Proofs}},
	isbn = {978-3-642-31374-5},
	abstract = {Large-scale verification projects pose particular challenges. Issues include proof exploration, efficiency of the edit-check cycle, and proof refactoring for documentation and maintainability. We draw on insights from two large-scale verification projects, L4.verified and Verisoft, that both used the Isabelle/HOL prover. We identify the main challenges in large-scale proofs, propose possible solutions, and discuss the Levity tool, which we developed to automatically move lemmas to appropriate theories, as an example of the kind of tool required by such proofs.},
	booktitle = {Intelligent {Computer} {Mathematics}},
	publisher = {Springer Berlin Heidelberg},
	author = {Bourke, Timothy and Daum, Matthias and Klein, Gerwin and Kolanski, Rafal},
	editor = {Jeuring, Johan and Campbell, John A. and Carette, Jacques and Dos Reis, Gabriel and Sojka, Petr and Wenzel, Makarius and Sorge, Volker},
	year = {2012},
	pages = {32--48}
}

@article{grov_tinker_2018,
	title = {The {Tinker} tool for graphical tactic development},
	volume = {20},
	issn = {1433-2787},
	url = {https://doi.org/10.1007/s10009-017-0452-7},
	doi = {10.1007/s10009-017-0452-7},
	abstract = {PSGraph (Grov et al. in LPAR. Springer, Berlin, pp 324–339, 2013) is a graphical language to support the development and maintenance of proof tactics for interactive theorem provers. By using labelled hierarchical graphs this formalisation improves upon analysis and maintenance found in traditional tactic languages. Tool support for PSGraph is achieved by Tinker (Grov et al. in UITP 2014, ENTCS, vol 167. Open Publishing Association, London, pp 23–34, 2014; Lin et al. in Tools and algorithms for the construction and analysis of systems. Springer, Berlin, pp 573–579, 2016): a theorem prover-independent system, which is connected to several different provers, with a graphical user interface including novel features to develop and debug proof tactics graphically. In this paper we provide a detailed and formal account of PSGraph and show how theorem prover independence is achieved by Tinker. We then show practical use of PSGraph and Tinker by developing several proof patterns using the language and tool.},
	number = {2},
	journal = {International Journal on Software Tools for Technology Transfer},
	author = {Grov, Gudmund and Lin, Yuhui},
	month = apr,
	year = {2018},
	pages = {139--155}
}

@inproceedings{aspinall_towards_2016,
	address = {Berlin, Heidelberg},
	title = {Towards {Formal} {Proof} {Metrics}},
	isbn = {978-3-662-49665-7},
	abstract = {Recent years have seen increasing success in building large formal proof developments using interactive theorem provers (ITPs). Some proofs have involved many authors, years of effort, and resulted in large, complex interdependent sets of proof “source code” files. Developing these in the first place, and maintaining and extending them afterwards, is a considerable challenge. It has prompted the idea of Proof Engineering as a new sub-field, to find methods and tools to help. It is natural to try to borrow ideas from Software Engineering for this.},
	booktitle = {Fundamental {Approaches} to {Software} {Engineering}},
	publisher = {Springer Berlin Heidelberg},
	author = {Aspinall, David and Kaliszyk, Cezary},
	editor = {Stevens, Perdita and Wasowski, Andrzej},
	year = {2016},
	pages = {325--341}
}

@article{lin_understanding_2016,
	title = {Understanding and maintaining tactics graphically {OR} how we are learning that a diagram can be worth more than {10K} {LoC}},
	volume = {9},
	url = {https://jfr.unibo.it/article/view/6298},
	doi = {10.6092/issn.1972-5787/6298},
	abstract = {\&lt;p class=\&quot;p1\&quot;\&gt;The use of a functional language to implement proof strategies as proof tactics in interactive theorem provers, often provides short, concise and elegant implementations. Whilst being elegant, the use of higher order features and combinator languages often results in a very procedural view of a strategy, which may deviate significantly from the high-level ideas behind it. This can make a tactic hard to understand and hence difficult to to debug and maintain for experts and non-experts alike: one often has to tear apart complex combinations of lower level tactics manually in order to analyse a failure in the overall strategy.\&lt;/p\&gt;\&lt;p class=\&quot;p1\&quot;\&gt;In an industrial technology transfer project, we have been working on porting a very large and complex proof tactic into PSGraph, a graphical language for representing proof strategies. The goal of this work is to improve understandability and maintainability of tactics. Motivated by some initial successes with this, we here extend PSGraph with additional features for development and debugging. Through the re-implementation and refactoring of several existing tactics, we demonstrates the advantages of PSGraph compared with a typical sentential tactic language with respect to debugging, readability and maintenance. In order to act as guidance for others, we give a fairly detailed comparison of the user experience with the two approaches. The paper is supported by a web page providing further details about the implementation as well as interactive illustrations of the examples.\&lt;/p\&gt;},
	number = {2},
	urldate = {2021-06-01},
	journal = {Journal of Formalized Reasoning},
	author = {Lin, YuHui and Grov, Gudmund and Arthan, Rob},
	month = dec,
	year = {2016},
	pages = {69--130}
}

@inproceedings{roe_coqpie_2016,
	address = {Cham},
	title = {{CoqPIE}: {An} {IDE} {Aimed} at {Improving} {Proof} {Development} {Productivity}},
	isbn = {978-3-319-43144-4},
	abstract = {In this paper we present CoqPIE(CoqPIE is available for download at http://github.com/kendroe/CoqPIE), a new development environment for Coq which delivers editing functionality centered around common prover usage workflow not found in existing tools. The main contributions of CoqPIE build from having an integrated parser for both Coq source and for prover output. The primary novelty is not the parser but how it is used: CoqPIE includes tools to carry out complex editing functions such as lemma extraction and replay. In proof replay for example both new and old outputs of the proof script are parsed into ASTs. These ASTs allow replay to do updates such as fixing hypothesis references.},
	booktitle = {Interactive {Theorem} {Proving}},
	publisher = {Springer International Publishing},
	author = {Roe, Kenneth and Smith, Scott},
	editor = {Blanchette, Jasmin Christian and Merz, Stephan},
	year = {2016},
	pages = {491--499}
}


@article{eastaughffe_support_1998,
	title = {Support for {Interactive} {Theorem} {Proving}: {Some} {Design} {Principles} and {Their} {Application}},
	author = {Eastaughffe, Katherine},
	year = {1998}
}

@inproceedings{ringer_replica_2020,
	address = {New York, NY, USA},
	series = {{CPP} 2020},
	title = {{REPLica}: {REPL} {Instrumentation} for {Coq} {Analysis}},
	isbn = {978-1-4503-7097-4},
	url = {https://doi-org.ezproxy.lib.rmit.edu.au/10.1145/3372885.3373823},
	doi = {10.1145/3372885.3373823},
	abstract = {Proof engineering tools make it easier to develop and maintain large systems verified using interactive theorem provers. Developing useful proof engineering tools hinges on understanding the development processes of proof engineers. This paper breaks down one barrier to achieving that understanding: remotely collecting granular data on proof developments as they happen. We have built a tool called REPLica that instruments Coq’s interaction model in order to collect fine-grained data on proof developments. It is decoupled from the user interface, and designed in a way that generalizes to other interactive theorem provers with similar interaction models. We have used REPLica to collect data over the span of a month from a group of intermediate through expert proof engineers—enough data to reconstruct hundreds of interactive sessions. The data reveals patterns in fixing proofs and in changing programs and specifications useful for the improvement of proof engineering tools. Our experiences conducting this study suggest design considerations both at the level of the study and at the level of the interactive theorem prover that can facilitate future studies of this kind.},
	booktitle = {Proceedings of the 9th {ACM} {SIGPLAN} {International} {Conference} on {Certified} {Programs} and {Proofs}},
	publisher = {Association for Computing Machinery},
	author = {Ringer, Talia and Sanchez-Stern, Alex and Grossman, Dan and Lerner, Sorin},
	year = {2020},
	note = {event-place: New Orleans, LA, USA},
	keywords = {proof engineering, study methodologies, user interaction},
	pages = {99--113}
}

@inproceedings{hentschel_interactive_2016,
	address = {New York, NY, USA},
	series = {{ASE} 2016},
	title = {The {Interactive} {Verification} {Debugger}: {Effective} {Understanding} of {Interactive} {Proof} {Attempts}},
	isbn = {978-1-4503-3845-5},
	url = {https://doi-org.ezproxy.lib.rmit.edu.au/10.1145/2970276.2970292},
	doi = {10.1145/2970276.2970292},
	abstract = {The Symbolic Execution Debugger (SED) is an extension of the Eclipse debug platform for interactive symbolic execution. Like a traditional debugger, the SED can be used to locate the origin of a defect and to increase program understanding. However, as it is based on symbolic execution, all execution paths are explored simultaneously. We demonstrate an extension of the SED called Interactive Verification Debugger (IVD) for inspection and understanding of formal verification attempts. By a number of novel views, the IVD allows to quickly comprehend interactive proof situations and to debug the reasons for a proof attempt that got stuck. It is possible to perform interactive proofs completely from within the IVD. It can be experimentally demonstrated that the IVD is more effective in understanding proof attempts than a conventional prover user interface. A screencast explaining proof attempt inspection with the IVD is available at youtu.be/8e-q9Jf1h\_w.},
	booktitle = {Proceedings of the 31st {IEEE}/{ACM} {International} {Conference} on {Automated} {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Hentschel, Martin and Hähnle, Reiner and Bubel, Richard},
	year = {2016},
	note = {event-place: Singapore, Singapore},
	keywords = {Proof Understanding, Verification, Debugging, Program Execution Visualization, Symbolic Execution},
	pages = {846--851}
}

@inproceedings{beckert_interaction_2017,
	address = {Cham},
	title = {An {Interaction} {Concept} for {Program} {Verification} {Systems} with {Explicit} {Proof} {Object}},
	isbn = {978-3-319-70389-3},
	abstract = {Deductive program verification is a difficult task: in general, user guidance is required to control the proof search and construction. Providing the right guiding information is challenging for users and usually requires several reiterations. Supporting the user in this process can considerably reduce the effort of program verification.},
	booktitle = {Hardware and {Software}: {Verification} and {Testing}},
	publisher = {Springer International Publishing},
	author = {Beckert, Bernhard and Grebing, Sarah and Ulbrich, Mattias},
	editor = {Strichman, Ofer and Tzoref-Brill, Rachel},
	year = {2017},
	pages = {163--178}
}

@inproceedings{beckert_interactive_2015,
	title = {Interactive {Theorem} {Proving} - {Modelling} the {User} in the {Proof} {Process}},
	booktitle = {Bridging@{CADE}},
	author = {Beckert, Bernhard and Grebing, S.},
	year = {2015}
}

@inproceedings{wenzel_isabelle_2011,
	address = {Berlin, Heidelberg},
	title = {Isabelle as {Document}-{Oriented} {Proof} {Assistant}},
	isbn = {978-3-642-22673-1},
	abstract = {Proof assistants in the LCF tradition, such as Coq, Isabelle, and the HOL family, are notorious for old-fashioned command-line interaction with input and output of plain text. Established prover interfaces like Proof General merely add a thin layer on top of the read-eval-print loop in the background. More sophisticated mathematical editors, Web-services, Wiki-servers for mathematical content do exist, but any project that aims at fully formal proof-checking struggles with recurrent problems posed by ancient prover engines.},
	booktitle = {Intelligent {Computer} {Mathematics}},
	publisher = {Springer Berlin Heidelberg},
	author = {Wenzel, Makarius},
	editor = {Davenport, James H. and Farmer, William M. and Urban, Josef and Rabe, Florian},
	year = {2011},
	pages = {244--259}
}


@phdthesis{tassi_interactive_2008,
	type = {{PhD} {Thesis}},
	title = {Interactive theorem provers: issues faced as a user and tackled as a developer},
	url = {http://amsdottorato.unibo.it/917/},
	school = {alma},
	author = {Tassi, Enrico},
	month = apr,
	year = {2008},
	keywords = {proof assistant coercions}
}


@inproceedings{becker_lassie_2021,
	address = {New York, NY, USA},
	series = {{CPP} 2021},
	title = {Lassie: {HOL4} {Tactics} by {Example}},
	isbn = {978-1-4503-8299-1},
	url = {https://doi-org.ezproxy.lib.rmit.edu.au/10.1145/3437992.3439925},
	doi = {10.1145/3437992.3439925},
	abstract = {Proof engineering efforts using interactive theorem proving have yielded several impressive projects in software systems and mathematics. A key obstacle to such efforts is the requirement that the domain expert is also an expert in the low-level details in constructing the proof in a theorem prover. In particular, the user needs to select a sequence of tactics that lead to a successful proof, a task that in general requires knowledge of the exact names and use of a large set of tactics. We present Lassie, a tactic framework for the HOL4 theorem prover that allows individual users to define their own tactic language by example and give frequently used tactics or tactic combinations easier-to-remember names. The core of Lassie is an extensible semantic parser, which allows the user to interactively extend the tactic language through a process of definitional generalization. Defining tactics in Lassie thus does not require any knowledge in implementing custom tactics, while proofs written in Lassie retain the correctness guarantees provided by the HOL4 system. We show through case studies how Lassie can be used in small and larger proofs by novice and more experienced interactive theorem prover users, and how we envision it to ease the learning curve in a HOL4 tutorial.},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} {International} {Conference} on {Certified} {Programs} and {Proofs}},
	publisher = {Association for Computing Machinery},
	author = {Becker, Heiko and Bos, Nathaniel and Gavran, Ivan and Darulova, Eva and Majumdar, Rupak},
	year = {2021},
	note = {event-place: Virtual, Denmark},
	keywords = {HOL4, Interactive Theorem Proving, Semantic Parsing, Tactic Programming},
	pages = {212--223}
}

@inproceedings{hunter_agent-based_2005,
	address = {AUS},
	series = {{ACSC} '05},
	title = {Agent-{Based} {Distributed} {Software} {Verification}},
	isbn = {1-920682-20-1},
	abstract = {Despite decades of research, the takeup of formal methods for developing provably correct software in industry remains slow. One reason for this is the high cost of proof construction, an activity that, due to the complexity of the required proofs, is typically carried out using interactive theorem provers. In this paper we propose an agent-oriented architecture for interactive theorem proving with the aim of reducing the user interactions (and thus the cost) of constructing software verification proofs. We describe a prototype implementation of our architecture and discuss its application to a small, but non-trivial case study.},
	booktitle = {Proceedings of the {Twenty}-{Eighth} {Australasian} {Conference} on {Computer} {Science} - {Volume} 38},
	publisher = {Australian Computer Society, Inc.},
	author = {Hunter, Chris and Robinson, Peter and Strooper, Paul},
	year = {2005},
	note = {event-place: Newcastle, Australia},
	keywords = {formal methods, software engineering, trusted systems},
	pages = {159--164}
}

@inproceedings{barras_asynchronous_2015,
	address = {Cham},
	title = {Asynchronous {Processing} of {Coq} {Documents}: {From} the {Kernel} up to the {User} {Interface}},
	isbn = {978-3-319-22102-1},
	abstract = {The work described in this paper improves the reactivity of the Coq system by completely redesigning the way it processes a formal document. By subdividing such work into independent tasks the system can give precedence to the ones of immediate interest for the user and postpone the others. On the user side, a modern interface based on the PIDE middleware aggregates and presents in a consistent way the output of the prover. Finally postponed tasks are processed exploiting modern, parallel, hardware to offer better scalability.},
	booktitle = {Interactive {Theorem} {Proving}},
	publisher = {Springer International Publishing},
	author = {Barras, Bruno and Tankink, Carst and Tassi, Enrico},
	editor = {Urban, Christian and Zhang, Xingyuan},
	year = {2015},
	pages = {51--66}
}

@inproceedings{wenzel_asynchronous_2014,
	address = {Cham},
	title = {Asynchronous {User} {Interaction} and {Tool} {Integration} in {Isabelle}/{PIDE}},
	isbn = {978-3-319-08970-6},
	abstract = {Historically, the LCF tradition of interactive theorem proving was tied to the read-eval-print loop, with sequential and synchronous evaluation of prover commands given on the command-line. This user-interface technology was adequate when R. Milner introduced his LCF proof assistant in the 1970-ies, but it severely limits the potential of current multicore hardware and advanced IDE front-ends.},
	booktitle = {Interactive {Theorem} {Proving}},
	publisher = {Springer International Publishing},
	author = {Wenzel, Makarius},
	editor = {Klein, Gerwin and Gamboa, Ruben},
	year = {2014},
	pages = {515--530}
}

@phdthesis{hentschel_integrating_2016,
	type = {{PhD} {Thesis}},
	title = {Integrating {Symbolic} {Execution}, {Debugging} and {Verification}},
	url = {http://tuprints.ulb.tu-darmstadt.de/5399/},
	abstract = {In modern software development, almost all activities are centered around an integrated development environment (IDE). Besides the main use cases to write, execute and debug source code, an IDE serves also as front-end for other tools involved in the development process such as a version control system or an application lifecycle management. Independent from the applied development process, the techniques to ensure correct software are always the same. The general goal is to find defects as soon as possible, because the sooner a defect is found, the easier and cheaper it is to fix. In the first place, the programming language helps to prevent some kinds of defects. Once something is written, it is effective to review it not only to find defects, but also to increase its quality. Also tools which statically analyze the source code help to find defects automatically. In addition, testing is used to ensure that selected usage scenarios behave as expected. However, a test can only show the presence of a failure and not its absence. To ensure that a program is correct, it needs to be proven that the program complies to a formal specification describing the desired behavior. This is done by formal verification tools. Finally, whenever a failure is observed, debugging takes place to locate the defect. This thesis extends the software development tool suite by an interactive debugger based on symbolic execution, a technique to explore all feasible execution paths up to a given depth simultaneously. Such a tool can not only be used for classical debugging activities, but also during code reviews or in order to present results of an analysis based on symbolic execution. The contribution is an extension of symbolic execution to explore the full program behavior even in presence of loops and recursive method calls. This is achieved by integrating specifications in form of loop invariants and methods contracts into a symbolic execution engine. How such a symbolic execution engine based on verification proofs can be realized is presented as well. In addition, the presented Symbolic Execution Debugger (SED) makes the Eclipse platform ready for debuggers based on symbolic execution. Its functionality goes beyond that of traditional interactive debuggers. For instance, debugging can start directly at any method or statement and all program execution paths are explored simultaneously. To support program comprehension, program execution paths as well as intermediate states are visualized. By default, the SED comes with a symbolic execution engine implemented on top of the KeY verification system. Statistical evidence that the SED increases effectiveness of code reviews is gained from a controlled experiment. Another novelty of the SED is that arbitrary verification proofs can be inspected. Whereas traditional user interfaces of verification tools present proof states in a mathematical fashion, the SED analyzes the full proof and presents different aspects of it using specialized views. A controlled experiment gives statistical evidence that proof understanding tasks are more effective using the SED by comparing its user interface with the original one of KeY. The SED allows one to interact with the underlying prover by adapting code and specifications in an auto-active flavor, which creates the need to manage proofs directly within an IDE. A presented concept achieves this, by integrating a semi-automatic verification tool into an IDE. It includes several optimizations to reduce the overall proof time and can be realized without changing the verification tool. An optimal user experience is achieved only if all aspects of verification are directly supported within the IDE. Thus a thorough integration of KeY into Eclipse is presented, which for instance includes in addition to the proof management capabilities to edit JML specifications and to setup the needed infrastructure for verification with KeY. Altogether, a platform for tools based on symbolic execution and related to verification is presented, which offers a seamless integration into an IDE and furthers a usage in combination. Furthermore, many aspects, like the way the SED presents proof attempts to users, help to reduce the barrier of using formal methods.},
	school = {Technische Universität Darmstadt},
	author = {Hentschel, Martin},
	month = jan,
	year = {2016},
	keywords = {Empirical Evaluation, Proof Understanding, Verification, Debugging, Program Execution Visualization, Symbolic Execution, Code Review, Integration of Formal Methods into Software Engineering Practice}
}

@inproceedings{shams_accessible_2018,
	address = {Cham},
	title = {Accessible {Reasoning} with {Diagrams}: {From} {Cognition} to {Automation}},
	isbn = {978-3-319-91376-6},
	abstract = {High-tech systems are ubiquitous and often safety and security critical: reasoning about their correctness is paramount. Thus, precise modelling and formal reasoning are necessary in order to convey knowledge unambiguously and accurately. Whilst mathematical modelling adds great rigour, it is opaque to many stakeholders which leads to errors in data handling, delays in product release, for example. This is a major motivation for the development of diagrammatic approaches to formalisation and reasoning about models of knowledge. In this paper, we present an interactive theorem prover, called iCon, for a highly expressive diagrammatic logic that is capable of modelling OWL 2 ontologies and, thus, has practical relevance. Significantly, this work is the first to design diagrammatic inference rules using insights into what humans find accessible. Specifically, we conducted an experiment about relative cognitive benefits of primitive (small step) and derived (big step) inferences, and use the results to guide the implementation of inference rules in iCon.},
	booktitle = {Diagrammatic {Representation} and {Inference}},
	publisher = {Springer International Publishing},
	author = {Shams, Zohreh and Sato, Yuri and Jamnik, Mateja and Stapleton, Gem},
	editor = {Chapman, Peter and Stapleton, Gem and Moktefi, Amirouche and Perez-Kriz, Sarah and Bellucci, Francesco},
	year = {2018},
	pages = {247--263}
}

@inproceedings{kawabata_traf_2018,
	address = {Cham},
	title = {Traf: {A} {Graphical} {Proof} {Tree} {Viewer} {Cooperating} with {Coq} {Through} {Proof} {General}},
	isbn = {978-3-030-02768-1},
	abstract = {Traf is a graphical proof tree viewer that cooperates with the Coq proof assistant and is controlled through Proof General. Among other proof tree viewers and tools for browsing proof scripts, Traf is well suited for daily proving of Coq problems as it is easy to use, non-disturbing, and helpful. Proof trees dynamically updated by Traf during interactive sessions with Proof General are informative and as readable as Gentzen-style natural deduction proofs. Traf facilitates browsing and investigating tactic-based proof scripts, which are often burdensome to read. Traf can also be used for typesetting proof trees with . The current version of Traf was developed as an extension to the Prooftree proof tree viewer and makes use of many of its facilities. Traf provides functionalities that are useful to both novice Coq users and experienced Proof General users.},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Kawabata, Hideyuki and Tanaka, Yuta and Kimura, Mai and Hironaka, Tetsuo},
	editor = {Ryu, Sukyoung},
	year = {2018},
	pages = {157--165}
}

@inproceedings{wenzel_structured_2006,
	address = {Berlin, Heidelberg},
	title = {Structured {Induction} {Proofs} in {Isabelle}/{Isar}},
	isbn = {978-3-540-37106-9},
	abstract = {Isabelle/Isar is a generic framework for human-readable formal proof documents, based on higher-order natural deduction. The Isar proof language provides general principles that may be instantiated to particular object-logics and applications. We discuss specific Isar language elements that support complex induction patterns of practical importance. Despite the additional bookkeeping required for induction with local facts and parameters, definitions, simultaneous goals and multiple rules, the resulting Isar proof texts turn out well-structured and readable. Our techniques can be applied to non-standard variants of induction as well, such as co-induction and nominal induction. This demonstrates that Isar provides a viable platform for building domain-specific tools that support fully-formal mathematical proof composition.},
	booktitle = {Mathematical {Knowledge} {Management}},
	publisher = {Springer Berlin Heidelberg},
	author = {Wenzel, Makarius},
	editor = {Borwein, Jonathan M. and Farmer, William M.},
	year = {2006},
	pages = {17--30}
}


@article{Category3-AFP,
  author  = {Eugene W. Stark},
  title   = {Category Theory with Adjunctions and Limits},
  journal = {Archive of Formal Proofs},
  month   = jun,
  year    = 2016,
  note    = {\url{https://isa-afp.org/entries/Category3.html},
            Formal proof development},
  ISSN    = {2150-914x},
}

@article{four_colour_2008,
  author = {Gonthier, Geogres},
  title = {Formal Proof — The Four-Color Theorem},
  journal = {Notices American Mathematical Society},
  year = {2008},
  pages = {1382–-1393},
}

@article{a_survey_of_itp,
author = {Marić, Filip},
year = {2015},
month = {07},
pages = {},
title = {A Survey of Interactive Theorem Proving},
journal = {Zbornik radova}
}

@inbook{history_of_itps,
author = {Harrison, John and Urban, Josef and Wiedijk, Freek},
year = {2014},
month = {12},
pages = {135-214},
title = {History of Interactive Theorem Proving},
volume = {9},
isbn = {9780444516244},
journal = {Handbook of the History of Logic},
doi = {10.1016/B978-0-444-51624-4.50004-6}
}

@misc{msc2021,
author = {{Associate Editors of Mathematical Reviews and zbMATH}},
year = {2020},
title = {MSC2020-Mathematics Subject Classification System}
}

@InProceedings{HOL_Light,
author="Harrison, John",
editor="Berghofer, Stefan
and Nipkow, Tobias
and Urban, Christian
and Wenzel, Makarius",
title="HOL Light: An Overview",
booktitle="Theorem Proving in Higher Order Logics",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="60--66",
abstract="HOL Light is an interactive proof assistant for classical higher-order logic, intended as a clean and simplified version of Mike Gordon's original HOL system. Theorem provers in this family use a version of ML as both the implementation and interaction language; in HOL Light's case this is Objective CAML (OCaml). Thanks to its adherence to the so-called `LCF approach', the system can be extended with new inference rules without compromising soundness. While retaining this reliability and programmability from earlier HOL systems, HOL Light is distinguished by its clean and simple design and extremely small logical kernel. Despite this, it provides powerful proof tools and has been applied to some non-trivial tasks in the formalization of mathematics and industrial formal verification.",
isbn="978-3-642-03359-9"
}

@inproceedings{HOL4,
author = {Slind, Konrad and Norrish, Michael},
title = {A Brief Overview of HOL4},
year = {2008},
isbn = {9783540710653},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-540-71067-7_6},
doi = {10.1007/978-3-540-71067-7_6},
abstract = {The HOLF proof assistant supports specification and proof in classical higher order
logic. It is the latest in a long line of similar systems. In this short overview,
we give an outline of the HOLF system and how it may be applied in formal verification.},
booktitle = {Proceedings of the 21st International Conference on Theorem Proving in Higher Order Logics},
pages = {28–32},
numpages = {5},
location = {Montreal, P.Q., Canada},
series = {TPHOLs '08}
}

@InProceedings{HOL_Zero,
author="Adams, Mark",
editor="Fukuda, Komei
and Hoeven, Joris van der
and Joswig, Michael
and Takayama, Nobuki",
title="Introducing HOL Zero",
booktitle="Mathematical Software -- ICMS 2010",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="142--143",
abstract="Theorem provers are now playing an important role in two diverse fields: computer system verification and mathematics. In computer system verification, they are a key component in toolsets that rigorously establish the absence of errors in critical computer hardware and software, such as processor design and safety-critical software, where traditional testing techniques provide inadequate assurance. In mathematics, they are used to check the veracity of recent high-profile proofs, such as the Four Colour Theorem and the Kepler Conjecture, whose scale and complexity have pushed traditional peer review to its limits.",
isbn="978-3-642-15582-6"
}

@msc{ProofPower,
  author={{R. Arthan}},
  title={{ProofPower–SLRP user guide. Technical report}},
  journal={{Lemma 1 Limited}},
  year={{2005}}
}

@Book{ACL2,
author="Kaufmann, Matt
and Manolios, Panagiotis
and Moore, J. Strother",
title="Computer-Aided Reasoning: An Approach",
year="2000",
publisher="Springer US",
address="Boston, MA",
pages="1--5",
abstract="This book is a textbook introduction to applied formal reasoning. We show how to use a formal logic to define concepts and to state and prove theorems. Moreover, we show how to carry out these tasks in cooperation with a particular computed-aided reasoning system.",
isbn="978-1-4615-4449-4",
doi="10.1007/978-1-4615-4449-4_1",
url="https://doi.org/10.1007/978-1-4615-4449-4_1"
}

@inproceedings{Agda,
author = {Norell, Ulf},
title = {Dependently Typed Programming in Agda},
year = {2009},
isbn = {9781605584201},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1481861.1481862},
doi = {10.1145/1481861.1481862},
abstract = {Dependently typed languages have for a long time been used to describe proofs about
programs. Traditionally, dependent types are used mostly for stating and proving the
properties of the programs and not in defining the programs themselves. An impressive
example is the certified compiler by Leroy (2006) implemented and proved correct in
Coq (Bertot and Cast\'{e}ran 2004).Recently there has been an increased interest in dependently
typed programming, where the aim is to write programs that use the dependent type
system to a much higher degree. In this way a lot of the properties that were previously
proved separately can be integrated in the type of the program, in many cases adding
little or no complexity to the definition of the program. New languages, such as Epigram
(McBride and McKinna 2004), are being designed, and existing languages are being extended
with new features to accomodate these ideas, for instance the work on dependently
typed programming in Coq by Sozeau (2007).This talk gives an overview of the Agda
programming language (Norell 2007), whose main focus is on dependently typed programming.
Agda provides a rich set of inductive types with a powerful mechanism for pattern
matching, allowing dependently typed programs to be written with minimal fuss. To
read about programming in Agda, see the lecture notes from the Advanced Functional
Programming summer school (Norell 2008) and the work by Oury and Swierstra (2008).In
the talk a number of examples of interesting dependently typed programs chosen from
the domain of programming language implementation are presented as they are implemented
in Agda.},
booktitle = {Proceedings of the 4th International Workshop on Types in Language Design and Implementation},
pages = {1–2},
numpages = {2},
keywords = {programming, dependent types},
location = {Savannah, GA, USA},
series = {TLDI '09}
}

@Book{Isabelle,
editor="Paulson, Lawrence C.",
title="Isabelle: A Generic Theorem Prover",
year="1994",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
isbn="978-3-540-48586-5",
doi="10.1007/BFb0030542",
url="https://doi.org/10.1007/BFb0030542"
}

@book{Metamath,
  author={{Norman Megill}},
  title={{Metamath: A Computer Language for Pure Mathematics}},
  publisher={{Lulu Press USA}},
  year={{2007}}
}

@article{Mizar, title={Mizar in a Nutshell}, volume={3}, url={https://jfr.unibo.it/article/view/1980}, DOI={10.6092/issn.1972-5787/1980}, abstractNote={This paper is intended to be a practical reference manual for basic Mizar terminology which may be helpful to get started using the system. The paper describes most important aspects of the Mizar language as well as some features of the verification software.}, number={2}, journal={Journal of Formalized Reasoning}, author={Grabowski, Adam and Kornilowicz, Artur and Naumowicz, Adam}, year={2010}, month={Jan.}, pages={153–245} }

@Inproceedings{RedPRL,
  author    = {Angiuli, Carlo and Cavallo, Evan and Hou (Favonia), Kuen-Bang and Harper, Robert and Sterling, Jonathan},
  year      = {2018},
  title     = {The RedPRL Proof Assistant (Invited Paper)},
  editor    = {Blanqui, Fr\'ed\'eric and Reis, Giselle},
  booktitle = {{\rm Proceedings of the 13th International Workshop on}
               Logical Frameworks and Meta-Languages: Theory and Practice,
               {\rm Oxford, UK, 7th July 2018}},
  series    = {Electronic Proceedings in Theoretical Computer Science},
  volume    = {274},
  publisher = {Open Publishing Association},
  pages     = {1-10},
  doi       = {10.4204/EPTCS.274.1},
}

@book{Coq,
author="Bertot, Yves
and Cast{\'e}ran, Pierre",
title="Interactive Theorem Proving and Program Development: Coq'Art: The Calculus of Inductive Constructions",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--11",
abstract="Coq [37] is a proof assistant with which students, researchers, or engineers can express specifications and develop programs that fulfill these specifications. This tool is well adapted to develop programs for which absolute trust is required: for example, in telecommunication, transportation, energy, banking, etc. In these domains the need for programs that rigorously conform to specifications justifies the effort required to verify these programs formally. We shall see in this book how a proof assistant like Coq can make this work easier.",
isbn="978-3-662-07964-5",
doi="10.1007/978-3-662-07964-5_1",
url="https://doi.org/10.1007/978-3-662-07964-5_1"
}

@INPROCEEDINGS{PVS,  author={Rushby, J.},  booktitle={Fourth IEEE International Conference on Software Engineering and Formal Methods (SEFM'06)},   title={Tutorial: Automated Formal Methods with PVS, SAL, and Yices},   year={2006},  volume={},  number={},  pages={262-262},  doi={10.1109/SEFM.2006.37}}

@book{JAPE,
  title={Proof and Disproof in Formal Logic: An Introduction for Programmers},
  author={Bornat, R.},
  isbn={9780198530268},
  lccn={2005019564},
  series={Oxford texts in logic},
  url={https://books.google.com.au/books?id=PxbY\_jIMdVEC},
  year={2005},
  publisher={Oxford University Press}
}

@article{LEO-II,
author = {Benzmüller, Christoph and Sultana, Nik and Paulson, Lawrence and Theiss, Frank},
year = {2015},
month = {12},
pages = {},
title = {The Higher-Order Prover Leo-II},
volume = {55},
journal = {Journal of Automated Reasoning},
doi = {10.1007/s10817-015-9348-y}
}

@InProceedings{Getfol,
author="Giunchiglia, Fausto
and Cimatti, Alessandro",
editor="Fribourg, Laurent
and Turini, Franco",
title="Introspective metatheoretic reasoning",
booktitle="Logic Program Synthesis and Transformation --- Meta-Programming in Logic",
year="1994",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="425--439",
abstract="This paper describes a reasoning system, called GETFOL, able to introspect (the code implementing) its own deductive machinery, to reason deductively about it in a declarative metatheory and to produce new executable code which can then be pushed back into the underlying implementation. In this paper we discuss the general architecture of GETFOL and the problems related to its implementation.",
isbn="978-3-540-49104-0"
}

@InProceedings{Z/EVES,
author="Saaltink, Mark",
editor="Bowen, Jonathan P.
and Hinchey, Michael G.
and Till, David",
title="The Z/EVES system",
booktitle="ZUM '97: The Z Formal Specification Notation",
year="1997",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="72--85",
abstract="We describe the Z/EVES system, which allows Z specifications to be analysed in a number of different ways. Among the significant features of Z/EVES are domain checking, which ensures that a specification is meaningful, and a theorem prover that includes a decision procedure for simple arithmetic and a heuristic rewriting mechanism that recognizes ``obvious'' facts.",
isbn="978-3-540-68490-9"
}

@misc{Atelier_B,
author = {Clearsy},
title = {The industrial tool to efficiently deploy the B method - Atelier B},
url = {https://www.atelierb.eu/}
}

@InProceedings{Counterexample_generators,
author="Manolios, Panagiotis",
editor="Blazy, Sandrine
and Paulin-Mohring, Christine
and Pichardie, David",
title="Counterexample Generation Meets Interactive Theorem Proving: Current Results and Future Opportunities",
booktitle="Interactive Theorem Proving",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="18--18",
abstract="This tutorial will explore the integration of counterexample generation with interactive theorem proving, a capability that has long been on the wish list of users and developers of interactive theorem provers. While the generation of counterexamples is an undecidable problem, recent methods have shown that it is possible to generate counterexamples to conjectures for many interesting problems. This tutorial will review current counterexample generation technology and how it can be used to design, analyze, and reason about systems. The tutorial will include a demo using ACL2s, the ACL2 Sedan. During the tutorial, we will also discuss the pedagogical use of counterexample generation in ACL2s to help freshmen students learn about logic and program verification. Finally, we will discuss future research opportunities.",
isbn="978-3-642-39634-2"
}


@InProceedings{Nitpick,
author="Blanchette, Jasmin Christian
and Nipkow, Tobias",
editor="Kaufmann, Matt
and Paulson, Lawrence C.",
title="Nitpick: A Counterexample Generator for Higher-Order Logic Based on a Relational Model Finder",
booktitle="Interactive Theorem Proving",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="131--146",
abstract="Nitpick is a counterexample generator for Isabelle/HOL that builds on Kodkod, a SAT-based first-order relational model finder. Nitpick supports unbounded quantification, (co)inductive predicates and datatypes, and (co)recursive functions. Fundamentally a finite model finder, it approximates infinite types by finite subsets. As case studies, we consider a security type system and a hotel key card system. Our experimental results on Isabelle theories and the TPTP library indicate that Nitpick generates more counterexamples than other model finders for higher-order logic, without restrictions on the form of the formulas to falsify.",
isbn="978-3-642-14052-5"
}


@phdthesis{Refute,
  author  = {Tjark Weber},
  title   = {{SAT}-based Finite Model Generation for Higher-Order Logic},
  school  = {Institut f{\"u}r Informatik, Technische Universit{\"a}t M{\"u}nchen},
  address = {Germany},
  month   = apr,
  year    = {2008},
  url     = {http://nbn-resolving.de/urn/resolver.pl?urn:nbn:de:bvb:91-diss-20081018-676608-1-8}
}

@pdfthesis{Quickcheck,
  title={Counterexample generation for higher-order logic using functional and logic programming},
  author={Lukas Bulwahn},
  year={2012}
}

@inproceedings{Nunchaku,
  author    = {Simon Cruanes and
               Jasmin Christian Blanchette},
  editor    = {Jasmin Christian Blanchette and
               Cezary Kaliszyk},
  title     = {Extending Nunchaku to Dependent Type Theory},
  booktitle = {Proceedings First International Workshop on Hammers for Type Theories,
               HaTT@IJCAR 2016, Coimbra, Portugal, July 1, 2016},
  series    = {{EPTCS}},
  volume    = {210},
  pages     = {3--12},
  year      = {2016},
  url       = {https://doi.org/10.4204/EPTCS.210.3},
  doi       = {10.4204/EPTCS.210.3},
  timestamp = {Sat, 19 Oct 2019 19:22:57 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/CruanesB16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{QED_Manifesto,
  title={The QED Manifesto Revisited},
  author={Freek Wiedijk},
  year={2007}
}

@misc{Four_Color,
  author={{G. Gonthier}},
  title={{Formal proof of the Four-Color theorem}},
  journal={{Notices of the American Mathematical Society}},
  edition={{55}},
  year={{2008}},
  pages={{182–1393}}
}

@misc{Twelf,
  author={Frank Pfenning and Carsten Schuermann},
  title={{Twelf's User Guide}},
  year={{2002}}
}
@inproceedings{Green2,
author={Green, T. R. G},
year={1989},
title={Cognitive dimensions of notations},
journal={A. Sutcliffe and L. Macaulay (Eds.) People and Computers V. Cambridge, UK: Cambridge University Press},
pages={443--460}
}

@article{Vega-Lite,
author = {Satyanarayan, Arvind and Moritz, Dominik and Wongsuphasawat, Kanit and Heer, Jeffrey},
title = {Vega-Lite: A Grammar of Interactive Graphics},
year = {2017},
issue_date = {January 2017},
publisher = {IEEE Educational Activities Department},
address = {USA},
volume = {23},
number = {1},
issn = {1077-2626},
url = {https://doi.org/10.1109/TVCG.2016.2599030},
doi = {10.1109/TVCG.2016.2599030},
abstract = {We present Vega-Lite, a high-level grammar that enables rapid specification of interactive
data visualizations. Vega-Lite combines a traditional grammar of graphics, providing
visual encoding rules and a composition algebra for layered and multi-view displays,
with a novel grammar of interaction. Users specify interactive semantics by composing
selections. In Vega-Lite, a selection is an abstraction that defines input event processing,
points of interest, and a predicate function for inclusion testing. Selections parameterize
visual encodings by serving as input data, defining scale extents, or by driving conditional
logic. The Vega-Lite compiler automatically synthesizes requisite data flow and event
handling logic, which users can override for further customization. In contrast to
existing reactive specifications, Vega-Lite selections decompose an interaction design
into concise, enumerable semantic units. We evaluate Vega-Lite through a range of
examples, demonstrating succinct specification of both customized interaction methods
and common techniques such as panning, zooming, and linked selection.},
journal = {IEEE Transactions on Visualization and Computer Graphics},
month = jan,
pages = {341–350},
numpages = {10}
}
@article{Flyspeck, title={A FORMAL PROOF OF THE KEPLER CONJECTURE}, volume={5}, DOI={10.1017/fmp.2017.1}, journal={Forum of Mathematics, Pi}, publisher={Cambridge University Press}, author={HALES, THOMAS and ADAMS, MARK and BAUER, GERTRUD and DANG, TAT DAT and HARRISON, JOHN and HOANG, LE TRUONG and KALISZYK, CEZARY and MAGRON, VICTOR and MCLAUGHLIN, SEAN and NGUYEN, TAT THANG and et al.}, year={2017}, pages={e2}}

@article{CertifiedSoftware,
author = {Shao, Zhong},
title = {Certified Software},
year = {2010},
issue_date = {December 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {53},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/1859204.1859226},
doi = {10.1145/1859204.1859226},
abstract = {Only if the programmer can prove (through formal machine-checkable proofs) it is free
of bugs with respect to a claim of dependability.},
journal = {Commun. ACM},
month = dec,
pages = {56–66},
numpages = {11}
}
@misc{FormalMethodsIndustry,
      title={Formal Methods: From Academia to Industrial Practice. A Travel Guide}, 
      author={Marieke Huisman and Dilian Gurov and Alexander Malkis},
      year={2020},
      eprint={2002.07279},
      archivePrefix={arXiv},
      primaryClass={cs.SE}
}

@InProceedings{Dijkstra,
  author="Moore, J. Strother
  and Zhang, Qiang",
  editor="Hurd, Joe
  and Melham, Tom",
  title="Proof Pearl: Dijkstra's Shortest Path Algorithm Verified with ACL2",
  booktitle="Theorem Proving in Higher Order Logics",
  year="2005",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="373--384",
  abstract="We briefly describe a mechanically checked proof of Dijkstra's shortest path algorithm for finite directed graphs with nonnegative edge lengths. The algorithm and proof are formalized in ACL2.",
  isbn="978-3-540-31820-0"
}
